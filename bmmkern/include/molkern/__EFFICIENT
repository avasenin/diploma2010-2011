-------------------------------- ЭФФЕКТИВНОСТЬ --------------------------------

091112. Потратил 3 дня на введение схемы, которая делит ячейку дополнительно на
8 подъячеек и откидывает при счете расстояний те пары подъячеек, расстояние между
которыми больше радиуса взаимодействия. Данная схема включает больше проверок в
коде, но меньше проверок во время счета, так как одна проверка верхнего уровня
(расстояние между подъячейками) заменяет собой множество проверок расстояний
между атомами.

Эффективность схемы 8% (g++) - 13% (icpc) по общему времени счета больших систем.
Если я отключаю счет взаимодействий, то получаю, что на все проверки уходит
1/6 времени и 5/6 на счет взаимодействий. То есть логично следует, что большую
эффективность на замене проверками верхнего уровня проверок нижнего уровня
далее добиться нельзя.

--------------------------------------------------------------------------------
091112. Домашний ПК. Думаю, что нет SSE для расчета потенциалов
Более точные данные для расчета без псевдопотениала (g++):

-w(before)  0.116 (cycles) + 0.478 (interactions) = 0.594 (all)
-w(after )  0.083 (cycles) + 0.458 (interactions) = 0.541 (all)

-w -m1gc1 (before)  4.208 (cycles) + 16.170 (int) = 20.378 (all)
-w -m1gc1 (after )  2.840 (cycles) + 15.474 (int) = 18.314 (all)

то есть, непроизводительные затраты в 19.5% (w) и 20.6%(1gc1) сокращаются до
15.3% (w) 15.5%(1gc1).


--------------------------------------------------------------------------------
091113. Рабочий ПК. Интел компилятор. Предполагаю, что Интел использует SSE для
расчета потенциалов, что существенно снижает время их счета.
Также сделана оптимизация непроизводительных расходов (снято дублирования при
прохождении ячеек).

Более точные данные для расчета без псевдопотениала (ipcp++):

-w(before)  0.115 (cycles) + 0.056 (interactions) = 0.171 (all)
-w(after )  0.086 (cycles) + 0.058 (interactions) = 0.144 (all)
-w(opt   )  0.077 (cycles) + 0.055 (interactions) = 0.132 (all)

-w -m1gc1 (before)  3.975 (cycles) + 2.076 (int) = 6.051 (all)
-w -m1gc1 (after )  2.930 (cycles) + 2.135 (int) = 5.065 (all)
-w -m1gc1 (opt   )  2.534 (cycles) + 1.701 (int) = 4.235 (all)

то есть, непроизводительные затраты в 205% (w) и 191%(1gc1) сокращаются до
148% (w) 137%(1gc1). Явно требуется SSE для анализа пар (взаимодействуют или нет).

--------------------------------------------------------------------------------
091120. Сделал SSE реализацию. Эффективность возросла непринципиально, что
подтверждает, что Интел-компилятор использует SSE при оптимизации.

-w -m1gc1 (большая ячейка)  2.26 (cycles) + 1.74 (int) = 4.00 (all) gcc
-w -m1gc1 (большая ячейка)  2.28 (cycles) + 1.19 (int) = 3.47 (all) icpc

091126. Подсчитал, что число неполных векторов, заполненных одним, двумя или тремя
числами составляет 22% от всех. Это значит, что фильтрация их, упаковка и перерасчет
отдельно не дадут существенного выигрыша.

091126. Оптимизация SSE кода.
-w -m1gc1 (большая ячейка)  2.48 (cycles) + 0.98 (int) = 3.46 (all) gcc
-w -m1gc1 (большая ячейка)  1.65 (cycles) + 1.25 (int) = 2.90 (all) icpc








