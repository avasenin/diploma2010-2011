#ifndef _WATER__F9ED1116_EDB9_5e17_25FF_F745B15D0111__H
#define _WATER__F9ED1116_EDB9_5e17_25FF_F745B15D0111__H

#include "molkern/__moldefs.h"
#include "molkern/complex/_region.h"

namespace molkern
{
	using namespace prgkern;

	/*
	 * Структура строится путем транслирования некоторой "элементарной" ячейки на вектора трансляции
	 * по осям XYZ. Удобная "элементарная" ячейка включает много (целых 8 атомов), но позволяет
	 * транслировать трансляцию по декартовым координатам. Список атомов этой ячейки приведен ниже.
	 * Образец ячейки лежит в файле unit_water.pdb, sample_water.pdb (8-кратно сдублированная).
	 * Координаты нормированы таким образом, что длина связи равна 1. Длина вектора трансляции для
	 * этой ячейки равна 4. Объем равен 64. Таким образом, для получения реальных значений координат
	 * и вектора трансляции нужно умножить все значения на длину связи, а объем на l**3.
	 */

	const vector_t WATER_UNIT_CELL_ATOMS[8] =
	{
		vector_t(0.0, 0.0, 0.0)
	, vector_t(1.0, 1.0, 1.0)
	, vector_t(2.0, 2.0, 0.0)
	, vector_t(3.0, 3.0, 1.0)
	, vector_t(2.0, 0.0, 2.0)
	, vector_t(3.0, 1.0, 3.0)
	, vector_t(0.0, 2.0, 2.0)
	, vector_t(1.0, 3.0, 3.0)
	};

	const vector_t WATER_UNIT_CELL_TRANSLATION = vector_t(4., 4., 4.);

#define _I(n, i1, i2, i3) index_<4, int>(n, i1, i2, i3)

	/*
	 * _I(n, ix, iy, iz) в строке m означает, что заданный атом m связан с атомом n в "элементарной"
	 * ячейке, но к атому n нужно добавить смещение {ix, iy, iz} умноженное на вектор трансляции
	 */
	const index_<4, int> WATER_UNIT_CELL_ATOM_HBOND[8][4] =
	{
	  { _I(1, 0, 0, 0), _I(3,-1,-1, 0), _I(5,-1, 0,-1), _I(7, 0,-1,-1) } /* 0 */
	, { _I(0, 0, 0, 0), _I(2, 0, 0, 0), _I(4, 0, 0, 0), _I(6, 0, 0, 0) } /* 1 */
  , { _I(1, 0, 0, 0), _I(3, 0, 0, 0), _I(5, 0, 0,-1), _I(7, 0, 0,-1) } /* 2 */
	, { _I(0, 1, 1, 0), _I(2, 0, 0, 0), _I(4, 0, 1, 0), _I(6, 1, 0, 0) } /* 3 */
  , { _I(1, 0, 0, 0), _I(3, 0,-1, 0), _I(5, 0, 0, 0), _I(7, 0,-1, 0) } /* 4 */
	, { _I(0, 1, 0, 1), _I(2, 0, 0, 1), _I(4, 0, 0, 0), _I(6, 1, 0, 0) } /* 5 */
  , { _I(1, 0, 0, 0), _I(3,-1, 0, 0), _I(5,-1, 0, 0), _I(7, 0, 0, 0) } /* 6 */
	, { _I(0, 0, 1, 1), _I(2, 0, 0, 1), _I(4, 0, 1, 0), _I(6, 0, 0, 0) } /* 7 */
	};


#undef _I

	/**
	*  Класс Water_ позволяет построить положение всех атомов воды в комплексе таким образом,
	*  чтобы минимизовать число клешей. Для этого делается оптимальное размещение воды в виде
	*  структуры льда (все связи направлены вдоль векторов на вертексы тетраэдра).
	*  Далее удаляется молекулы воды из региона, если они попадают на белок и лиганды.
	*
	*  Внимание! Расстояние между соседними молекулами воды (O-O расстояния) при размещении их
	*  согласно структуре льда равняется 2.68 A. Но, оптимальное расстояние между молекулами воды
	*  согласно ван-дер-ваальсому радиусу равно 3.54A. Таким образом получается значительная
	*  величина ван-дер-ваальсовых взаимодействий. Если размещать молекулы по декартовой сетке,
	*  в центрах кубов, то среднее расстояние между ними составит 3.1034A, что значительно лучше
	*  с точки зрения ван-дер-ваальсовых взаимодействий. Таким образом имеет значительную конкуренцию
	*  между ван-дер-ваальсом и водородными связями. Водородные связи требуют структуру льда, но это
	*  низкая плотность и высокий ван-дер-ваальс, а низкий ван-дер-ваальс это разупорядочение.
	*  Поскольку в AMBER нет явных водородных связей, то структура льда ничем не может быть поддержана.
	*  Значит она будет разрушена в симуляции. Водородные связи должны быть вставлены явно, чтобы
	*  получить возможность появления в симуляции кластеров льда.
	*
	*  http://rodnikzdorovia.ru/struktura.html
	*  Эксперимент показывает, что распределение расстояний между атомами кислорода при температуре,
	*  близкой к комнатной, даёт три максимума, на 2,8, 4,5 и 6,7. Первый соответствует расстоянию до
	*  ближайших соседей, и его значение примерно равно длине водородной связи. Второй максимум близок
	*  к средней длине ребра тетраэдра. А третий максимум, выраженный весьма слабо, соответствует
	*  расстоянию до третьих и более далёких соседей по водородной сетке.
	*  Таким образом, явно следует, что предложенное в AMBER силовое поле неадекватно. Возможно,
	*  также, что оно полагается на компенсацию за счет сильного кулона.
	*/
	class Water_
	{
		typedef index_<4, int> _Index;

		class generate_iterator
		{
			const Water_ *water_;
			range_iterator it_;

		public:

			generate_iterator(const Water_ *water, int pos) : water_(water), it_(pos) {}

			generate_iterator &operator++() { ++it_; return *this; }
			vector_t operator *() const
			{
				index_<4, int> ndx = memory_offset(*it_, water_->index_vector());
				vector_t v = WATER_UNIT_CELL_ATOMS[ndx[3]];
				vector_t t = vector_t(
				  WATER_UNIT_CELL_TRANSLATION[0] * ndx[0]
				, WATER_UNIT_CELL_TRANSLATION[1] * ndx[1]
				, WATER_UNIT_CELL_TRANSLATION[2] * ndx[2]);
				return (v + t) * water_->l_;
			}

			index_<4, int> hbonds() const
			{
//				index_<4, int> ndx = memory_offset(*it_, water_->index_vector());
//				vector_t v = WATER_UNIT_CELL_ATOMS[ndx[3]];
//				vector_t t = vector_t(
//				  WATER_UNIT_CELL_TRANSLATION[0] * ndx[0]
//				, WATER_UNIT_CELL_TRANSLATION[1] * ndx[1]
//				, WATER_UNIT_CELL_TRANSLATION[2] * ndx[2]);
//				return (v + t) * water_->l_;
				return index_<4, int>(0);
			}
			bool operator!=(const generate_iterator &it) const { return it_ != it.it_; }
		};

		vector_t region_T_; // вектор трансляции региона, максимально близкий к заданному
		index_<4, int> n_;  // число трансляций "элементарной" ячейки, чтобы покрыть заданный регион
		real_t l_, _1l_;    // коэффициент нормировки "элементарной" ячейки

	public:
		typedef generate_iterator const_iterator;

		/**
		 * @param T вектор трансляции региона
		 * @param density задаваемая плотность воды
		 * @return число молекул воды в новом регионе
		 */
		Water_(const vector_t &T, real_t density=NORMAL_WATER_DENSITY)
		{
			// коэффициент нормировки для обеспечения заданной плотности (и обратная величина)
			l_ = 0.5 * pow(density, -1./3);
			_1l_ = 1. / l_;

			// число дублирований элементарной ячейки по всем направлениям
			n_[0] = round(T[0] / (WATER_UNIT_CELL_TRANSLATION[0] * l_));
			n_[1] = round(T[1] / (WATER_UNIT_CELL_TRANSLATION[1] * l_));
			n_[2] = round(T[2] / (WATER_UNIT_CELL_TRANSLATION[2] * l_));
			n_[3] = 8;

			region_T_ = vector_t(
					WATER_UNIT_CELL_TRANSLATION[0] * n_[0] * l_
				, WATER_UNIT_CELL_TRANSLATION[1] * n_[1] * l_
				, WATER_UNIT_CELL_TRANSLATION[2] * n_[2] * l_);
				// Новый размер региона, для которого точно выдерживается плотность и число дублирований
				// вдоль ребер региона. При этом водородные связи не имеют клешей на границах региона.
		}

		unsigned count() const { return 8 * n_[0] * n_[1] * n_[2]; }
		const vector_t &region_vector() const { return region_T_; }
		const index_<4, int> &index_vector() const { return n_; }

		generate_iterator begin() const { return generate_iterator(this, 0); }
		generate_iterator end() const { return generate_iterator(this, count());	}

	};
}
#endif
