!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A0_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> A0_, A1_; \/\/ ускорения в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
A1_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> A0_, A1_; \/\/ ускорения в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
ACCUMULATE_	include/molkern/__moldefs.h	/^		ACCUMULATE_,         \/\/ ACCUMULATE_ matrix type$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ACCURACY	include/molkern/__moldefs.h	/^	const real_t ACCURACY = 10 * std::numeric_limits<real_t>::epsilon();$/;"	m	namespace:molkern
ACCURACY2	include/molkern/__moldefs.h	/^	const real_t ACCURACY2 = sqr(ACCURACY);$/;"	m	namespace:molkern
ADDR	include/prgkern/_minimize_lbfgs.h	122;"	d
ADDR	include/prgkern/_minimize_lbfgs.h	261;"	d
ADD_ATOMS	include/molkern/complex/_region.h	747;"	d
ADD_ATOMS	include/molkern/complex/_region.h	760;"	d
AMBER_SCALE_COUL14	include/molkern/__moldefs.h	/^	const real_t AMBER_SCALE_COUL14 = 0.8333; \/\/ opls.pdf$/;"	m	namespace:molkern
AMBER_SCALE_VDW14	include/molkern/__moldefs.h	/^	const real_t AMBER_SCALE_VDW14 = 0.5;$/;"	m	namespace:molkern
ANGLE_	include/molkern/__moldefs.h	/^		ANGLE_,              \/\/ валенный угол$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ARCHETYPE_	include/molkern/__moldefs.h	/^		ARCHETYPE_,          \/\/ архетип молекулы$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ASSERT_DIMENSIONS	include/prgkern/_mdense.h	127;"	d
ASSERT_DIMENSIONS	include/prgkern/_mdense.h	75;"	d
ASSERT_IMPL	include/prgkern/_assert.h	42;"	d
ASSERT_IMPL	include/prgkern/_assert.h	44;"	d
ASSIGN	include/prgkern/_m3x3dense.h	104;"	d
ASSIGN	include/prgkern/_m3x3dense.h	112;"	d
ASSIGN	include/prgkern/_m3x3dense.h	114;"	d
ASSIGN	include/prgkern/_m3x3dense.h	124;"	d
ASSIGN	include/prgkern/_m3x3dense.h	126;"	d
ASSIGN	include/prgkern/_m3x3dense.h	137;"	d
ASSIGN	include/prgkern/_m3x3dense.h	139;"	d
ASSIGN	include/prgkern/_m3x3dense.h	146;"	d
ASSIGN	include/prgkern/_m3x3dense.h	148;"	d
ASSIGN	include/prgkern/_m3x3dense.h	155;"	d
ASSIGN	include/prgkern/_m3x3dense.h	157;"	d
ASSIGN	include/prgkern/_m3x3dense.h	164;"	d
ATMOSPHERE_FACTOR	include/molkern/__moldefs.h	/^	const real_t ATMOSPHERE_FACTOR = (real_t) 16388.5070058; \/\/????$/;"	m	namespace:molkern
ATOMDATA_	include/molkern/__moldefs.h	/^		ATOMDATA_,           \/\/ параметры атома$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ATOM_	include/molkern/__moldefs.h	/^		ATOM_,               \/\/ атом$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
AUE_BOLTZMAN	include/molkern/__moldefs.h	/^	const real_t AUE_BOLTZMAN = (real_t) 8.314510e-1; \/\/ AUE\/(mol*K)$/;"	m	namespace:molkern
AXIS_ROTATOR_	include/prgkern/_rotator.h	/^	const int AXIS_ROTATOR_     = 2; \/\/ axis R(phi) rotator$/;"	m	namespace:prgkern
A_	include/prgkern/_rotator.h	/^		vdense_<3, T> A_, B_;$/;"	m	class:prgkern::Rotator
A_DET_	include/molkern/__moldefs.h	/^		A_DET_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
AminoAcidName	include/molkern/forcefield/_residue.h	/^	struct AminoAcidName$/;"	s	namespace:molkern
Angle_	include/molkern/forcefield/_angle.h	/^	template <int FORCEFIELD_TYPE> struct Angle_$/;"	s	namespace:molkern
Archetype_	include/molkern/complex/_archetype.h	/^		Archetype_(const _Forcefield *forcefield, const _Residome *residome, unsigned freedom_type)$/;"	f	class:molkern::Archetype_
Archetype_	include/molkern/complex/_archetype.h	/^	class Archetype_<FORCEFIELD_AMBER_, RESIDOME_AMBER_>$/;"	c	namespace:molkern
Atomdata_	include/molkern/forcefield/_atomdata.h	/^		Atomdata_() : fftype("  "), name("  "), sid(0), charge(0.), radius(0.),$/;"	f	struct:molkern::Atomdata_
Atomdata_	include/molkern/forcefield/_atomdata.h	/^	struct Atomdata_$/;"	s	namespace:molkern
Average_	include/prgkern/_average.h	/^		Average_(unsigned sz=0) : pos_(sz - 1), count_(0) { _Base::resize(sz); }$/;"	f	class:prgkern::Average_
Average_	include/prgkern/_average.h	/^	class Average_ : protected std::vector<S>$/;"	c	namespace:prgkern
BMM_HEADER_LEN	include/molkern/__moldefs.h	/^	const unsigned BMM_HEADER_LEN = 128;$/;"	m	namespace:molkern
BMM_QGRID_STEP	include/molkern/__moldefs.h	/^	const unsigned BMM_QGRID_STEP = 10000;$/;"	m	namespace:molkern
BMM_RECORD_LEN	include/molkern/__moldefs.h	/^	const unsigned BMM_RECORD_LEN = 18;$/;"	m	namespace:molkern
BMM_VGRID_STEP	include/molkern/__moldefs.h	/^	const unsigned BMM_VGRID_STEP = 100;$/;"	m	namespace:molkern
BMM_XGRID_STEP	include/molkern/__moldefs.h	/^	const unsigned BMM_XGRID_STEP = 100;$/;"	m	namespace:molkern
BOND_	include/molkern/__moldefs.h	/^		BOND_,               \/\/ связь$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	231;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	237;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	241;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	257;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	262;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	267;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	289;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	297;"	d
BOOST_PP_LOCAL_LIMITS	include/prgkern/_blas1.h	301;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	230;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	235;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	240;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	256;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	261;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	266;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	288;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	293;"	d
BOOST_PP_LOCAL_MACRO	include/prgkern/_blas1.h	300;"	d
BOX_	include/molkern/__moldefs.h	/^		BOX_,                \/\/ прямоугольная область пространства$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
BUILD2_TIMER_	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
BUILD_ALL	include/molkern/__moldefs.h	/^	const unsigned BUILD_ALL = BUILD_HYDROGENS$/;"	m	namespace:molkern
BUILD_AND_RETURN_TRUE	include/molkern/complex/_archetype.h	845;"	d
BUILD_AND_RETURN_TRUE	include/molkern/complex/_archetype.h	864;"	d
BUILD_ANGLES	include/molkern/__moldefs.h	/^	const unsigned BUILD_ANGLES        = 0x00000004;$/;"	m	namespace:molkern
BUILD_BONDS	include/molkern/__moldefs.h	/^	const unsigned BUILD_BONDS         = 0x00000002;$/;"	m	namespace:molkern
BUILD_CHAINS	include/molkern/__moldefs.h	/^	const unsigned BUILD_CHAINS        = 0x00000080;$/;"	m	namespace:molkern
BUILD_CONNECTS	include/molkern/__moldefs.h	/^	const unsigned BUILD_CONNECTS      = 0x00000020;$/;"	m	namespace:molkern
BUILD_HYDROGENS	include/molkern/__moldefs.h	/^	const unsigned BUILD_HYDROGENS     = 0x00000001;$/;"	m	namespace:molkern
BUILD_NOTHING	include/molkern/__moldefs.h	/^	const unsigned BUILD_NOTHING       = 0x00000000;$/;"	m	namespace:molkern
BUILD_PAIRS14	include/molkern/__moldefs.h	/^	const unsigned BUILD_PAIRS14       = 0x00000010;$/;"	m	namespace:molkern
BUILD_ROTAMERS	include/molkern/__moldefs.h	/^	const unsigned BUILD_ROTAMERS      = 0x00000040;$/;"	m	namespace:molkern
BUILD_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
BUILD_TORSIONS	include/molkern/__moldefs.h	/^	const unsigned BUILD_TORSIONS      = 0x00000008;$/;"	m	namespace:molkern
B_	include/prgkern/_rotator.h	/^		vdense_<3, T> A_, B_;$/;"	m	class:prgkern::Rotator
Bond_	include/molkern/forcefield/_bond.h	/^	template <int FORCEFIELD_TYPE> struct Bond_$/;"	s	namespace:molkern
Bool2Type_	include/prgkern/_type.h	/^	template <bool n> struct Bool2Type_ { enum { result = n }; };$/;"	s	namespace:prgkern
Box_	include/prgkern/_box.h	/^		Box_() { T inf = infinity<T>(); d_ = inf; u_ = -inf; }$/;"	f	class:prgkern::Box_
Box_	include/prgkern/_box.h	/^		Box_(T x0, T x1) { d_[0] = x0; u_[0] = x1; }$/;"	f	class:prgkern::Box_
Box_	include/prgkern/_box.h	/^		Box_(T x0, T y0, T x1, T y1)$/;"	f	class:prgkern::Box_
Box_	include/prgkern/_box.h	/^		Box_(T x0, T y0, T z0, T x1, T y1, T z1)$/;"	f	class:prgkern::Box_
Box_	include/prgkern/_box.h	/^		Box_(const _Vector &d, const _Vector &u) : d_(d), u_(u) {}$/;"	f	class:prgkern::Box_
Box_	include/prgkern/_box.h	/^	class Box_$/;"	c	namespace:prgkern
C612	include/molkern/forcefield/_interactions.h	/^	enum { C612, E612 };$/;"	e	enum:molkern::__anon13
CAL2AUE	include/molkern/__moldefs.h	/^	const real_t CAL2AUE = (real_t) 418.4; \/\/ US cal$/;"	m	namespace:molkern
CAL2J	include/molkern/__moldefs.h	/^	const real_t CAL2J = (real_t) 4.184; \/\/ US cal$/;"	m	namespace:molkern
CALC_ANGLE_	include/molkern/__moldefs.h	/^	const unsigned CALC_ANGLE_   = 0x00000002;$/;"	m	namespace:molkern
CALC_BOND_	include/molkern/__moldefs.h	/^	const unsigned CALC_BOND_    = 0x00000001;$/;"	m	namespace:molkern
CALC_NOTHING_	include/molkern/__moldefs.h	/^	const unsigned CALC_NOTHING_ = 0x00000000;$/;"	m	namespace:molkern
CALC_PAIR14_	include/molkern/__moldefs.h	/^	const unsigned CALC_PAIR14_  = 0x00000008;$/;"	m	namespace:molkern
CALC_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
CALC_TORSION_	include/molkern/__moldefs.h	/^	const unsigned CALC_TORSION_ = 0x00000004;$/;"	m	namespace:molkern
CHAIN_	include/molkern/__moldefs.h	/^		CHAIN_,              \/\/ цепь свзанных атомов$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
CHARGE1_	include/molkern/__moldefs.h	/^		CHARGE1_,            \/\/ расчет изменений заряда$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
CHARGE_	include/molkern/__moldefs.h	/^		CHARGE_,             \/\/ заряд$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
CHARGE_MESH_STEP	include/molkern/__moldefs.h	/^	const real_t CHARGE_MESH_STEP = 1.;$/;"	m	namespace:molkern
CHARGE_SMOOTH_RADIUS	include/molkern/__moldefs.h	/^	const real_t CHARGE_SMOOTH_RADIUS = 2.;$/;"	m	namespace:molkern
CODE_EOF	include/molkern/__moldefs.h	/^		CODE_EOF          \/\/ end of file$/;"	e	enum:molkern::code_error_
CODE_ERROR	include/molkern/__moldefs.h	/^		CODE_ERROR,       \/\/ unknown error$/;"	e	enum:molkern::code_error_
CODE_SUCCESS	include/molkern/__moldefs.h	/^		CODE_SUCCESS = 0, \/\/ no error$/;"	e	enum:molkern::code_error_
CONFIG__F9ED1116_3790_5da1_93E4_D94353B00A01__H	include/molkern/__config.h	2;"	d
CONNECT_	include/molkern/__moldefs.h	/^		CONNECT_,            \/\/ контакт$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
CONTROL_CONTACT	include/molkern/forcefield/_interactions.h	522;"	d
CONTROL_CONTACT	include/molkern/forcefield/_interactions.h	529;"	d
COUL14_	include/molkern/__moldefs.h	/^		COUL14_,             \/\/ кулоновское 1-4 взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
COUL_	include/molkern/__moldefs.h	/^		COUL_,               \/\/ кулоновское взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
COUT_MUTEX_LOCK	include/prgkern/_prgconfig.h	55;"	d
COUT_MUTEX_UNLOCK	include/prgkern/_prgconfig.h	56;"	d
CTERM_	include/molkern/__moldefs.h	/^		CTERM_,              \/\/ C терминал$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
CYCLE_EXPANSION_SIZE	include/prgkern/_prgconfig.h	63;"	d
Chain_	include/molkern/forcefield/_rotamer.h	/^	class Chain_$/;"	c	namespace:molkern
Complex	include/molkern/complex/_complex.h	/^	typedef Complex_<FORCEFIELD_AMBER_, RESIDOME_AMBER_> Complex;$/;"	t	namespace:molkern
Complex_	include/molkern/complex/_complex.h	/^		Complex_(const _Forcefield *forcefield, const _Residome *residome, _Region *region,$/;"	f	class:molkern::Complex_
Complex_	include/molkern/complex/_complex.h	/^	class Complex_$/;"	c	namespace:molkern
Configure	include/molkern/__config.h	/^		Configure(int argc, char *argv[]) :$/;"	f	class:molkern::Configure
Configure	include/molkern/__config.h	/^	class Configure$/;"	c	namespace:molkern
DEBUG_BOND_FACTOR	include/molkern/__moldefs.h	/^	const real_t DEBUG_BOND_FACTOR = 2.;$/;"	m	namespace:molkern
DEBUG_GUARD	include/prgkern/_pproc.h	136;"	d
DEBUG_PAIR_FACTOR	include/molkern/__moldefs.h	/^	const real_t DEBUG_PAIR_FACTOR = 0.5;$/;"	m	namespace:molkern
DECLARE_AS_RESTORING_ROUND_MODE	include/prgkern/_sse.h	361;"	d
DECLARE_AS_RESTORING_ROUND_MODE	include/prgkern/_sse.h	470;"	d
DEFAULT_ATOM_COUNT	include/molkern/__moldefs.h	/^	const int DEFAULT_ATOM_COUNT = 4000;$/;"	m	namespace:molkern
DEFAULT_ATOM_DENSITY	include/molkern/__moldefs.h	/^	const real_t DEFAULT_ATOM_DENSITY = 0.05;$/;"	m	namespace:molkern
DEFAULT_COULOMB_SPLIT_RADIUS	include/molkern/forcefield/_potential.h	/^	const double DEFAULT_COULOMB_SPLIT_RADIUS = 8.;$/;"	m	namespace:molkern
DEFAULT_COUL_SPLIT_RADIUS	include/molkern/__moldefs.h	/^	const real_t DEFAULT_COUL_SPLIT_RADIUS = 8.0f;$/;"	m	namespace:molkern
DEFAULT_DISPOSE_ITERATIONS	include/molkern/__moldefs.h	/^	const unsigned DEFAULT_DISPOSE_ITERATIONS = 10;$/;"	m	namespace:molkern
DEFAULT_FTOL	include/prgkern/_minimize.h	/^	INLINE T DEFAULT_FTOL() { return (T) 10. * std::numeric_limits<T>::epsilon(); }$/;"	f	namespace:prgkern
DEFAULT_GETLINE_LEN	include/prgkern/_os.h	/^	const std::streamsize DEFAULT_GETLINE_LEN = 120;$/;"	m	namespace:prgkern
DEFAULT_GTOL	include/prgkern/_minimize.h	/^	INLINE T DEFAULT_GTOL() { return 1e-3; }$/;"	f	namespace:prgkern
DEFAULT_INTEGRATION_TIME_STEP	include/molkern/__moldefs.h	/^	const unsigned DEFAULT_INTEGRATION_TIME_STEP = 1; \/\/ 1 fs$/;"	m	namespace:molkern
DEFAULT_M	include/prgkern/_minimize.h	/^	const unsigned DEFAULT_M = 7;$/;"	m	namespace:prgkern
DEFAULT_MAXFEV	include/prgkern/_minimize.h	/^	const unsigned DEFAULT_MAXFEV = 200; \/\/ need large value ~200 for first iteration$/;"	m	namespace:prgkern
DEFAULT_MAX_HALTS	include/prgkern/_minimize.h	/^	const unsigned DEFAULT_MAX_HALTS = 3;$/;"	m	namespace:prgkern
DEFAULT_MAX_X	include/molkern/__moldefs.h	/^	const real_t DEFAULT_MAX_X = (real_t) 0.2; \/\/ [A]$/;"	m	namespace:molkern
DEFAULT_PADDING_SIZE	include/prgkern/_pproc.h	26;"	d
DEFAULT_RESIDUE_COUNT	include/molkern/forcefield/_residome_amber.h	/^		static const int DEFAULT_RESIDUE_COUNT = 120;$/;"	m	class:molkern::Residome_
DEFAULT_RSKIN_STEP	include/molkern/__moldefs.h	/^	const double DEFAULT_RSKIN_STEP = 0.1;$/;"	m	namespace:molkern
DEFAULT_RSKIN_WIDTH	include/molkern/__moldefs.h	/^	const double DEFAULT_RSKIN_WIDTH = 1.2;$/;"	m	namespace:molkern
DEFAULT_SAMPLING_TIME_STEP	include/molkern/__moldefs.h	/^	const unsigned DEFAULT_SAMPLING_TIME_STEP = 10; \/\/ 10 fs$/;"	m	namespace:molkern
DEFAULT_STEEP_ITERATIONS	include/prgkern/_minimize.h	/^	const int DEFAULT_STEEP_ITERATIONS = 10;$/;"	m	namespace:prgkern
DEFAULT_STPMAX	include/prgkern/_minimize.h	/^	const float DEFAULT_STPMAX = 0.100;$/;"	m	namespace:prgkern
DEFAULT_STPMIN	include/prgkern/_minimize.h	/^	const float DEFAULT_STPMIN = 0.001;$/;"	m	namespace:prgkern
DEFAULT_TARGET_TEMPERATURE	include/molkern/__moldefs.h	/^	const real_t DEFAULT_TARGET_TEMPERATURE = (real_t) 300.; \/\/ 309.6 = 36.6 C$/;"	m	namespace:molkern
DEFAULT_WOLFE1	include/prgkern/_minimize.h	/^	const float DEFAULT_WOLFE1 = 0.1;$/;"	m	namespace:prgkern
DEFAULT_WOLFE2	include/prgkern/_minimize.h	/^	const float DEFAULT_WOLFE2 = 0.1;$/;"	m	namespace:prgkern
DEFAULT_XTOL	include/prgkern/_minimize.h	/^	INLINE T DEFAULT_XTOL() { return (T) 10. * std::numeric_limits<T>::epsilon(); }$/;"	f	namespace:prgkern
DEFINE_TAG	include/molkern/__molkern.h	57;"	d
DEFINE_TAG_CONST	include/molkern/__moldefs.h	275;"	d
DEFINE_TAG_CONST	include/molkern/__moldefs.h	355;"	d
DEFINE_TAG_LOGICAL_CONST	include/molkern/__moldefs.h	757;"	d
DEFINE_TAG_LOGICAL_CONST	include/molkern/__moldefs.h	762;"	d
DEFINE_VECTOR_ACCESS_FUNCTION	include/molkern/__moldefs.h	740;"	d
DEFINE_VECTOR_ACCESS_FUNCTION	include/molkern/__molkern.h	56;"	d
DEG2RAD	include/prgkern/_math.h	/^	const double DEG2RAD = M_PI \/ 180.;$/;"	m	namespace:prgkern
DELETE	include/molkern/complex/_thermostat.h	264;"	d
DELETE	include/molkern/complex/_thermostat.h	268;"	d
DIELECTRIC_PROTEIN	include/molkern/__moldefs.h	/^	const real_t DIELECTRIC_PROTEIN = (real_t) 4.0;$/;"	m	namespace:molkern
DIELECTRIC_WATER	include/molkern/__moldefs.h	/^	const real_t DIELECTRIC_WATER = (real_t) 78.5;$/;"	m	namespace:molkern
DIRECTION_	include/molkern/__moldefs.h	/^		DIRECTION_,          \/\/ типы упорядочиваний по направлениям$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
Degree	include/prgkern/_math.h	/^	template <int S, unsigned DEGREE> struct Degree$/;"	s	namespace:prgkern
Degree	include/prgkern/_math.h	/^	template <int S> struct Degree<S, 0> { enum { value = 1 }; };$/;"	s	namespace:prgkern
Descriptor_	include/molkern/__config.h	/^		Descriptor_(std::string s) : altpos('A'), count(1), is_random(false),$/;"	f	struct:molkern::Descriptor_
Descriptor_	include/molkern/__config.h	/^		Descriptor_(std::string s) : freedom_type(0)$/;"	f	struct:molkern::Descriptor_
Descriptor_	include/molkern/__config.h	/^		Descriptor_(std::string s) : name(""), use_hydrogens(false), use_water(false)$/;"	f	struct:molkern::Descriptor_
Descriptor_	include/molkern/__config.h	/^		Descriptor_<OPTIMIZER_>(const Configure &config)$/;"	f	struct:molkern::Descriptor_
Descriptor_	include/molkern/__config.h	/^		Descriptor_<THERMOSTATE_>(const Configure &config) : ensamble(config.ensamble),$/;"	f	struct:molkern::Descriptor_
Descriptor_	include/molkern/__config.h	/^	template <> struct Descriptor_<FILE_>$/;"	s	namespace:molkern
Descriptor_	include/molkern/__config.h	/^	template <> struct Descriptor_<MOLECULE_>$/;"	s	namespace:molkern
Descriptor_	include/molkern/__config.h	/^	template <> struct Descriptor_<OPTIMIZER_>$/;"	s	namespace:molkern
Descriptor_	include/molkern/__config.h	/^	template <> struct Descriptor_<THERMOSTATE_>$/;"	s	namespace:molkern
Descriptor_	include/molkern/__config.h	/^	template <> struct Descriptor_<WATER_>$/;"	s	namespace:molkern
Dfft	include/prgkern/_transforms.h	/^		Dfft(const fft_index &ndx) : _Base(ndx)$/;"	f	class:prgkern::Dfft
Dfft	include/prgkern/_transforms.h	/^		Dfft(const fft_index &ndx, int direction) : _Base(ndx)$/;"	f	class:prgkern::Dfft
Dfft	include/prgkern/_transforms.h	/^	class Dfft<_N, _Real, std::complex<_Real> > : public fftw3_connect<_N, _Real>$/;"	c	namespace:prgkern
Dfft	include/prgkern/_transforms.h	/^	class Dfft<_N, std::complex<_Real>, _Real> : public fftw3_connect<_N, _Real>$/;"	c	namespace:prgkern
Dfft	include/prgkern/_transforms.h	/^	class Dfft<_N, std::complex<_Real>, std::complex<_Real> >$/;"	c	namespace:prgkern
Dfft	include/prgkern/_transforms.h	/^	class Dfft<_N, vdense_<_M, std::complex<_Real> >, vdense_<_M, _Real> >$/;"	c	namespace:prgkern
Dk_	include/prgkern/_minimize_lbfgs.h	/^		_Vector Dk_; \/\/ diag[S0(T)Y0, ..., Sk-1(T)Yk-1]$/;"	m	class:prgkern::Updater
E612	include/molkern/forcefield/_interactions.h	/^	enum { C612, E612 };$/;"	e	enum:molkern::__anon13
EDGE_	include/molkern/__moldefs.h	/^		EDGE_,              \/\/ ротамерные оси$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EDGE_LENGTH_	include/molkern/__moldefs.h	/^		EDGE_LENGTH_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ELECTRIC_FACTOR	include/molkern/__moldefs.h	/^	const real_t ELECTRIC_FACTOR = (real_t) 138935.485;$/;"	m	namespace:molkern
EMPTY_DIRECTION_	include/molkern/__moldefs.h	/^		EMPTY_DIRECTION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EQTY_DISTANCE_	include/molkern/__moldefs.h	/^		EQTY_DISTANCE_,      \/\/ distance between types in table (we use the nearest)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EQUI_	include/molkern/__moldefs.h	/^		EQUI_,               \/\/ тип эквивалентности$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EULER_ROTATOR_	include/prgkern/_rotator.h	/^	const int EULER_ROTATOR_    = 1; \/\/ euler R(alpha, beta, gamma) rotator$/;"	m	namespace:prgkern
EXTERNAL_DENSE_TYPEDEFS	include/prgkern/_dense.h	99;"	d
EXTERNAL_DENSE_TYPEDEFS	include/prgkern/_mdense.h	/^		EXTERNAL_DENSE_TYPEDEFS;$/;"	m	class:prgkern::mdense_
EXTERNAL_DENSE_TYPEDEFS	include/prgkern/_vdense.h	/^		EXTERNAL_DENSE_TYPEDEFS;$/;"	m	class:prgkern::vdense_
EXT_CONTACT_NEXT_	include/molkern/__moldefs.h	/^		EXT_CONTACT_NEXT_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EXT_CONTACT_PREV_	include/molkern/__moldefs.h	/^		EXT_CONTACT_PREV_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
EXT_ID_	include/molkern/__moldefs.h	/^		EXT_ID_,             \/\/ внешний идентификатор атома$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
Ensemble_	include/molkern/complex/_ensemble.h	/^		Ensemble_() {}$/;"	f	class:molkern::Ensemble_
Ensemble_	include/molkern/complex/_ensemble.h	/^		Ensemble_(real_t target_energy, unsigned ns) : T_(ns), target_energy_(target_energy) {}$/;"	f	class:molkern::Ensemble_
Ensemble_	include/molkern/complex/_ensemble.h	/^		Ensemble_(real_t target_pressure, unsigned ns)$/;"	f	class:molkern::Ensemble_
Ensemble_	include/molkern/complex/_ensemble.h	/^		Ensemble_(real_t target_temperature, unsigned ns)$/;"	f	class:molkern::Ensemble_
Ensemble_	include/molkern/complex/_ensemble.h	/^	template <> class Ensemble_<NVE>$/;"	c	namespace:molkern
Ensemble_	include/molkern/complex/_ensemble.h	/^	template <> class Ensemble_<NVT>$/;"	c	namespace:molkern
Ensemble_	include/molkern/complex/_ensemble.h	/^	template<> class Ensemble_<NVP>$/;"	c	namespace:molkern
F	include/molkern/complex/_complex.h	/^			vector_t F; \/\/\/< текущая сила (coul + vdw), действующая на атом$/;"	m	struct:molkern::Complex_::_LJAtom
F	include/molkern/complex/_complex.h	/^			vector_t F; \/\/\/< частичные силы от невалентных взаимодействий$/;"	m	struct:molkern::Complex_::_Atom
FAIL	include/prgkern/_minimize.h	/^		enum { FAIL, INTERVAL_OK, FUNCTION_DIFFERENCE_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Line_minimizer_::__anon35
FAIL	include/prgkern/_minimize_round.h	/^		enum { FAIL, INTERVAL_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Round_minimizer_::__anon30
FFTW3_CONNECT_BRIDGE_MACRO	include/prgkern/_transforms.h	200;"	d
FILE_	include/molkern/__moldefs.h	/^		FILE_,               \/\/ файл$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FILTER_TIMER_	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
FORCEFIELD_	include/molkern/__moldefs.h	/^		FORCEFIELD_,         \/\/ силовое поле$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORCEFIELD_AMBER_	include/molkern/__moldefs.h	/^		FORCEFIELD_AMBER_,    \/\/ AMBER protein forcefield$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORCEFIELD_GAFF_	include/molkern/__moldefs.h	/^		FORCEFIELD_GAFF_,     \/\/ AMBER inorganic ligand forcefield$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORCEFIELD__F9ED1116_E190_5bc1_48A9_DB43E7FD0700__H	include/molkern/forcefield/_forcefield.h	2;"	d
FORMAT_BMM_	include/molkern/__moldefs.h	/^		FORMAT_BMM_,          \/\/ формат пакета MOLKERN$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORMAT_CONTROL	include/molkern/__config.h	341;"	d
FORMAT_CONTROL	include/molkern/__config.h	383;"	d
FORMAT_CONTROL	include/molkern/__config.h	417;"	d
FORMAT_HIN_	include/molkern/__moldefs.h	/^		FORMAT_HIN_,          \/\/ HIN file format$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORMAT_MOL2_	include/molkern/__moldefs.h	/^		FORMAT_MOL2_,         \/\/ MOL2 file format$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORMAT_PDB_	include/molkern/__moldefs.h	/^		FORMAT_PDB_,          \/\/ PDB file format$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FORMAT_UNKNOWN_	include/molkern/__moldefs.h	/^		FORMAT_UNKNOWN_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_	include/molkern/__moldefs.h	/^		FREEDOM_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_ATOM_	include/molkern/__moldefs.h	/^		FREEDOM_ATOM_,        \/\/ свобода движения всех атомов$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_CHAIN_	include/molkern/__moldefs.h	/^		FREEDOM_CHAIN_,      \/\/ свобода движения подцепей как целого (цепи не синхронны)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_CM_	include/molkern/__moldefs.h	/^		FREEDOM_CM_,         \/\/ свобода движения центра масс (все цепи молекулы синхронны)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_FIXED_	include/molkern/__moldefs.h	/^		FREEDOM_FIXED_,      \/\/ нет свободы движения$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_ROTAMER_	include/molkern/__moldefs.h	/^		FREEDOM_ROTAMER_,    \/\/ свобода вращения ротамеров$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREEDOM_TYPE_	include/molkern/__moldefs.h	/^		FREEDOM_TYPE_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FREE_	include/molkern/__moldefs.h	/^		FREE_,               \/\/ свободные атомы$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
FUNCTION_DIFFERENCE_OK	include/prgkern/_minimize.h	/^		enum { FAIL, INTERVAL_OK, FUNCTION_DIFFERENCE_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Line_minimizer_::__anon35
ForceField	include/molkern/forcefield/_forcefield_amber.h	/^	typedef Forcefield_<FORCEFIELD_AMBER_> ForceField;$/;"	t	namespace:molkern
Forcefield_	include/molkern/forcefield/_forcefield.h	/^	template <int FORCEFIELD_TYPE> class Forcefield_ {};$/;"	c	namespace:molkern
Forcefield_	include/molkern/forcefield/_forcefield_amber.h	/^		Forcefield_() {}$/;"	f	class:molkern::Forcefield_
Forcefield_	include/molkern/forcefield/_forcefield_amber.h	/^		Forcefield_(const std::string &dirname) { load_dir(dirname); }$/;"	f	class:molkern::Forcefield_
Forcefield_	include/molkern/forcefield/_forcefield_amber.h	/^	template <> class Forcefield_<FORCEFIELD_AMBER_> :$/;"	c	namespace:molkern
GEOM_CENTER_	include/molkern/__moldefs.h	/^		GEOM_CENTER_,        \/\/ center of geometry$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
GON_TIMER_	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
GPOSITION_	include/molkern/__moldefs.h	/^		GPOSITION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
GRADIENT_	include/molkern/__moldefs.h	/^		GRADIENT_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
GSL_SIMPLEX_	include/prgkern/_minimize.h	/^	enum { SCITBX_LBFGS_, GSL_SIMPLEX_, STEEP_, LMBFGS_, ROUND_ };$/;"	e	enum:prgkern::__anon34
Gonnet_vector	include/molkern/complex/_region.h	/^	struct Gonnet_vector : public std::vector<std::pair<unsigned, real_t>  > \/\/ <индекс, хеш>$/;"	s	namespace:molkern
Group_	include/molkern/complex/_verlet.h	/^		struct Group_$/;"	s	class:molkern::_Verlet_table
Guard_	include/prgkern/_pproc.h	/^		Guard_(const char *message) : msg_(message)$/;"	f	class:prgkern::Guard_
Guard_	include/prgkern/_pproc.h	/^	template <int N> class Guard_$/;"	c	namespace:prgkern
H0_	include/prgkern/_minimize_lbfgs.h	/^		_Vector H0_; \/\/ start diagonal Hessian**(-1)$/;"	m	class:prgkern::Updater
HEAVY_MASS_FACTOR	include/molkern/__moldefs.h	/^	const real_t HEAVY_MASS_FACTOR = 2;$/;"	m	namespace:molkern
HYDROGEN_	include/molkern/__moldefs.h	/^		HYDROGEN_,           \/\/ водород$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
HYDROGEN_ATOM_DISTANCE	include/molkern/__moldefs.h	/^	const real_t HYDROGEN_ATOM_DISTANCE = 1.09;$/;"	m	namespace:molkern
IDENTS_OF_OBJECTS	include/molkern/__moldefs.h	/^	enum IDENTS_OF_OBJECTS$/;"	g	namespace:molkern
IMPLEMENT_4FUNCTION_1	include/prgkern/_sse.h	1067;"	d
IMPLEMENT_4FUNCTION_1	include/prgkern/_sse.h	1080;"	d
IMPLEMENT_4FUNCTION_1	include/prgkern/_sse.h	672;"	d
IMPLEMENT_4FUNCTION_1	include/prgkern/_sse.h	686;"	d
IMPLEMENT_4FUNCTION_2	include/prgkern/_sse.h	1054;"	d
IMPLEMENT_4FUNCTION_2	include/prgkern/_sse.h	1065;"	d
IMPLEMENT_4FUNCTION_2	include/prgkern/_sse.h	658;"	d
IMPLEMENT_4FUNCTION_2	include/prgkern/_sse.h	670;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1124;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1133;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1135;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1144;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1146;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	1155;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	734;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	743;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	745;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	754;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	756;"	d
IMPLEMENT_CMP_FUNCTION	include/prgkern/_sse.h	765;"	d
IMPLEMENT_MATRIX	include/molkern/__moldefs.h	680;"	d
IMPLEMENT_MATRIX	include/molkern/__moldefs.h	689;"	d
IMPLEMENT_MATRIX_OPERATOR	include/prgkern/_m3x3dense.h	100;"	d
IMPLEMENT_MATRIX_OPERATOR	include/prgkern/_m3x3dense.h	93;"	d
IMPLEMENT_MULTIPLE_FUNCTION	include/prgkern/_sse.h	1168;"	d
IMPLEMENT_MULTIPLE_FUNCTION	include/prgkern/_sse.h	1177;"	d
IMPLEMENT_MULTIPLE_FUNCTION	include/prgkern/_sse.h	779;"	d
IMPLEMENT_MULTIPLE_FUNCTION	include/prgkern/_sse.h	789;"	d
IMPLEMENT_MULTIPLE_NOT_FUNCTION	include/prgkern/_sse.h	1157;"	d
IMPLEMENT_MULTIPLE_NOT_FUNCTION	include/prgkern/_sse.h	1166;"	d
IMPLEMENT_MULTIPLE_NOT_FUNCTION	include/prgkern/_sse.h	767;"	d
IMPLEMENT_MULTIPLE_NOT_FUNCTION	include/prgkern/_sse.h	777;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	226;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	234;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	236;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	244;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	246;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	254;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	256;"	d
IMPLEMENT_OPERATOR	include/prgkern/_index.h	264;"	d
IMPLEMENT_OPERATOR_I1	include/prgkern/_dense.h	28;"	d
IMPLEMENT_OPERATOR_I2	include/prgkern/_dense.h	32;"	d
IMPLEMENT_SAVE_FUNCTION	include/molkern/complex/_molecule.h	101;"	d
IMPLEMENT_SAVE_FUNCTION	include/molkern/complex/_molecule.h	111;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_m3x3dense.h	76;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_m3x3dense.h	82;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_m3x3dense.h	85;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_m3x3dense.h	91;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_v3dense.h	176;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_v3dense.h	189;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_v3dense.h	78;"	d
IMPLEMENT_SCALAR_OPERATOR	include/prgkern/_v3dense.h	87;"	d
IMPLEMENT_TRUNCATE_FUNCTION	include/prgkern/_sse.h	1100;"	d
IMPLEMENT_TRUNCATE_FUNCTION	include/prgkern/_sse.h	1109;"	d
IMPLEMENT_TRUNCATE_FUNCTION	include/prgkern/_sse.h	709;"	d
IMPLEMENT_TRUNCATE_FUNCTION	include/prgkern/_sse.h	718;"	d
IMPLEMENT_TRUNCATE_FUNCTION_1	include/prgkern/_sse.h	1111;"	d
IMPLEMENT_TRUNCATE_FUNCTION_1	include/prgkern/_sse.h	1122;"	d
IMPLEMENT_TRUNCATE_FUNCTION_1	include/prgkern/_sse.h	720;"	d
IMPLEMENT_TRUNCATE_FUNCTION_1	include/prgkern/_sse.h	732;"	d
IMPLEMENT_VECTOR_OPERATOR	include/prgkern/_v3dense.h	191;"	d
IMPLEMENT_VECTOR_OPERATOR	include/prgkern/_v3dense.h	202;"	d
IMPLEMENT_VECTOR_OPERATOR	include/prgkern/_v3dense.h	89;"	d
IMPLEMENT_VECTOR_OPERATOR	include/prgkern/_v3dense.h	97;"	d
IMPORT_RUN_EXPORT	include/prgkern/_transforms.h	341;"	d
IMPULSE_	include/molkern/__moldefs.h	/^		IMPULSE_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
INERTIA_TENSOR_DET_	include/molkern/__moldefs.h	/^		INERTIA_TENSOR_DET_, \/\/ determinant of inertia tensor$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
INFINITE_ROTATOR_	include/prgkern/_rotator.h	/^	const int INFINITE_ROTATOR_ = 3; \/\/ moving rotator (R = infinity)$/;"	m	namespace:prgkern
INFINITY	include/molkern/__moldefs.h	/^	const real_t INFINITY = infinity<real_t>();$/;"	m	namespace:molkern
INFINITY	include/prgkern/_math.h	40;"	d
INLINE	include/prgkern/_prgconfig.h	38;"	d
INLINE	include/prgkern/_prgconfig.h	40;"	d
INSERT_CONNECTORS	include/molkern/complex/_archetype.h	2602;"	d
INSERT_CONNECTORS	include/molkern/complex/_archetype.h	2618;"	d
INSERT_MACRO	include/molkern/complex/_region.h	982;"	d
INSERT_MACRO	include/molkern/complex/_region.h	997;"	d
INSERT_PADDING	include/prgkern/_pproc.h	47;"	d
INTEGRAL__dOMEGA	include/molkern/__moldefs.h	/^	const real_t INTEGRAL__dOMEGA = (real_t) (8 * sqr(M_PI));$/;"	m	namespace:molkern
INTEGRAL__dXYZ	include/molkern/__moldefs.h	/^	const real_t INTEGRAL__dXYZ = (real_t) 1660;$/;"	m	namespace:molkern
INTERNAL_DENSE_TYPEDEFS	include/prgkern/_dense.h	94;"	d
INTERVAL_OK	include/prgkern/_minimize.h	/^		enum { FAIL, INTERVAL_OK, FUNCTION_DIFFERENCE_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Line_minimizer_::__anon35
INTERVAL_OK	include/prgkern/_minimize_round.h	/^		enum { FAIL, INTERVAL_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Round_minimizer_::__anon30
Int2Type_	include/prgkern/_type.h	/^	template <int n> struct Int2Type_ { enum { result = n }; };$/;"	s	namespace:prgkern
Integrator	include/molkern/complex/_mdynamics.h	/^	typedef Integrator_<LEAP_FROG_> Integrator;$/;"	t	namespace:molkern
Integrator_	include/molkern/complex/_mdynamics.h	/^		Integrator_() {}$/;"	f	class:molkern::Integrator_
Integrator_	include/molkern/complex/_mdynamics.h	/^		Integrator_(_Molecule *molecule,$/;"	f	class:molkern::Integrator_
Integrator_	include/molkern/complex/_mdynamics.h	/^	template <> class Integrator_<LEAP_FROG_>$/;"	c	namespace:molkern
Interaction	include/molkern/forcefield/_interactions.h	/^	typedef Interaction_<C612> Interaction;$/;"	t	namespace:molkern
Interaction	include/molkern/forcefield/_interactions.h	/^	typedef Interaction_<E612> Interaction;$/;"	t	namespace:molkern
Interaction1_	include/molkern/forcefield/_1interactions.h	/^	template <> struct Interaction1_<ANGLE_>$/;"	s	namespace:molkern
Interaction1_	include/molkern/forcefield/_1interactions.h	/^	template <> struct Interaction1_<BOND_>$/;"	s	namespace:molkern
Interaction1_	include/molkern/forcefield/_1interactions.h	/^	template <> struct Interaction1_<TORSION_>$/;"	s	namespace:molkern
Interaction_	include/molkern/forcefield/_interactions.h	/^		Interaction_(real_t cutoff, real_t barrier)$/;"	f	struct:molkern::Interaction_
Interaction_	include/molkern/forcefield/_interactions.h	/^		Interaction_(real_t split_radius=DEFAULT_COUL_SPLIT_RADIUS)$/;"	f	struct:molkern::Interaction_
Interaction_	include/molkern/forcefield/_interactions.h	/^	template <> struct Interaction_<C612>$/;"	s	namespace:molkern
Interaction_	include/molkern/forcefield/_interactions.h	/^	template <> struct Interaction_<E612>$/;"	s	namespace:molkern
J2CAL	include/molkern/__moldefs.h	/^	const real_t J2CAL = (real_t) (1. \/ CAL2J); \/\/ US cal$/;"	m	namespace:molkern
KT	include/molkern/__moldefs.h	/^	INLINE T KT(T temperature) { return (T)(AUE_BOLTZMAN * temperature); }$/;"	f	namespace:molkern
LEAP_FROG_	include/molkern/complex/_mdynamics.h	/^	enum { LEAP_FROG_};$/;"	e	enum:molkern::__anon17
LINKCELL__09ED1116_C3FE_55a4_CA63_F84536C80D02__H	include/molkern/complex/_linkcell.h	2;"	d
LJ_CALCULATE	include/molkern/forcefield/_interactions.h	552;"	d
LJ_INTERACT	include/molkern/forcefield/_interactions.h	580;"	d
LMBFGS_	include/prgkern/_minimize.h	/^	enum { SCITBX_LBFGS_, GSL_SIMPLEX_, STEEP_, LMBFGS_, ROUND_ };$/;"	e	enum:prgkern::__anon34
LOADED_ERR_MESSAGE	include/molkern/__moldefs.h	696;"	d
LOADED_OK_MESSAGE	include/molkern/__moldefs.h	691;"	d
Line_minimizer_	include/prgkern/_minimize.h	/^	class Line_minimizer_$/;"	c	namespace:prgkern
M	include/prgkern/_m3x3dense.h	192;"	d
M	include/prgkern/_m3x3dense.h	195;"	d
M	include/prgkern/_m3x3dense.h	202;"	d
M	include/prgkern/_m3x3dense.h	206;"	d
M	include/prgkern/_m3x3dense.h	212;"	d
M	include/prgkern/_m3x3dense.h	217;"	d
MACRO	include/molkern/complex/_thermostat.h	278;"	d
MACRO	include/prgkern/_v3dense.h	54;"	d
MACRO	include/prgkern/_v3dense.h	61;"	d
MAKE_CONTROL	include/molkern/complex/_region.h	129;"	d
MAKE_CONTROL	include/molkern/complex/_region.h	148;"	d
MAKE_DIRNAME	include/prgkern/_os.h	67;"	d
MAKE_EQ	include/prgkern/_minimize.h	119;"	d
MAKE_EQ	include/prgkern/_minimize.h	416;"	d
MAKE_EQ	include/prgkern/_minimize_round.h	20;"	d
MAKE_EQ	include/prgkern/_minimize_round.h	547;"	d
MAKE_STRING	include/molkern/__config.h	171;"	d
MAKE_STRING	include/molkern/__config.h	195;"	d
MAKE_STRING	include/molkern/__config.h	215;"	d
MAKE_STRING	include/molkern/__config.h	247;"	d
MAKE_STRING	include/molkern/__config.h	262;"	d
MAKE_STRING	include/molkern/__config.h	309;"	d
MAKE_STRING	include/prgkern/_string.h	163;"	d
MAKE_STRING	include/prgkern/_string.h	178;"	d
MAKE_STRING	include/prgkern/_string.h	180;"	d
MAKE_STRING	include/prgkern/_string.h	190;"	d
MASS_	include/molkern/__moldefs.h	/^		MASS_,               \/\/ масса$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
MASS_CENTER_	include/molkern/__moldefs.h	/^		MASS_CENTER_,        \/\/ center of mass$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
MATRIX_DEBUG_PRINT_COUNT	include/prgkern/_dense.h	/^	const size_t MATRIX_DEBUG_PRINT_COUNT = 10;$/;"	m	namespace:prgkern
MAX_ATOM_BOND	include/molkern/__moldefs.h	/^	const int MAX_ATOM_BOND = 6;$/;"	m	namespace:molkern
MAX_ATOM_NAME	include/molkern/__moldefs.h	/^	const int MAX_ATOM_NAME   = 4; \/\/ 2 + reserve + '\/n' (int)$/;"	m	namespace:molkern
MAX_EQUIVALENT	include/molkern/__moldefs.h	/^	const int MAX_EQUIVALENT = 20; \/\/ max number of atom equivalent$/;"	m	namespace:molkern
MAX_GROUP_ELEM	include/molkern/__moldefs.h	/^	const unsigned MAX_GROUP_ELEM = 32;$/;"	m	namespace:molkern
MAX_ITERATION	include/prgkern/_minimize.h	/^	const int MAX_ITERATION = 2000;$/;"	m	namespace:prgkern
MAX_LINE_LEN	include/prgkern/_string.h	/^	const int MAX_LINE_LEN = 256; \/\/ length of text file strings (*.dat)$/;"	m	namespace:prgkern
MAX_NAME	include/molkern/__moldefs.h	/^	const int MAX_NAME       = 256; \/\/ lenght of name (molecule, ..)$/;"	m	namespace:molkern
MAX_NUCLEAR_INDEX	include/molkern/forcefield/_nuclear.h	/^	const unsigned MAX_NUCLEAR_INDEX = 56;$/;"	m	namespace:molkern
MAX_STRING_LEN	include/prgkern/_string.h	/^	const int MAX_STRING_LEN  = 256; \/\/ length of text file strings (*.dat)$/;"	m	namespace:prgkern
MAX_VDW_RADIUS_	include/molkern/__moldefs.h	/^		MAX_VDW_RADIUS_,     \/\/ max forcefield atoms radius$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
MINIMAL_DISTANCE_BETWEEN_ATOMS	include/molkern/__moldefs.h	/^	const real_t MINIMAL_DISTANCE_BETWEEN_ATOMS = HYDROGEN_ATOM_DISTANCE - 0.2;$/;"	m	namespace:molkern
MINIMIZER_STEP_START	include/prgkern/_minimize.h	/^	const float MINIMIZER_STEP_START = 1e-6;$/;"	m	namespace:prgkern
MOLDEFS__F9ED1116_3790_5da1_93E4_D94353B00A01__H	include/molkern/__moldefs.h	2;"	d
MOLECULE_	include/molkern/__moldefs.h	/^		MOLECULE_,           \/\/ молекула$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
MOLKERN__0077A726_C744_52f9_4B92_B244A9C70800__H	include/molkern/__molkern.h	2;"	d
MOMENT_	include/molkern/__moldefs.h	/^		MOMENT_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
MULTISCALAR_OPERATOR	include/prgkern/_sse.h	1205;"	d
MULTISCALAR_OPERATOR	include/prgkern/_sse.h	475;"	d
MULTISCALAR_OPERATOR	include/prgkern/_sse.h	821;"	d
MULTISCALAR_OPERATOR	include/prgkern/_sse.h	829;"	d
M_	include/prgkern/_rotator.h	/^		mdense_<3, 3, T> M_;$/;"	m	class:prgkern::Rotator
M_1_SQRT_2	include/prgkern/_math.h	/^	const double M_1_SQRT_2 = 1. \/ M_SQRT_2;$/;"	m	namespace:prgkern
M_1_SQRT_3	include/prgkern/_math.h	/^	const double M_1_SQRT_3 = 1. \/ M_SQRT_3;$/;"	m	namespace:prgkern
M_2PI	include/prgkern/_math.h	/^	const double M_2PI = M_PI + M_PI;$/;"	m	namespace:prgkern
M_4PI	include/prgkern/_math.h	/^	const double M_4PI = M_2PI + M_2PI;$/;"	m	namespace:prgkern
M_COS_0	include/prgkern/_math.h	/^	const double M_COS_0  = 1.;$/;"	m	namespace:prgkern
M_COS_30	include/prgkern/_math.h	/^	const double M_COS_30 = 0.5 * M_SQRT_3;$/;"	m	namespace:prgkern
M_COS_45	include/prgkern/_math.h	/^	const double M_COS_45 = 0.5 * M_SQRT_2;$/;"	m	namespace:prgkern
M_COS_60	include/prgkern/_math.h	/^	const double M_COS_60 = 0.5;$/;"	m	namespace:prgkern
M_COS_90	include/prgkern/_math.h	/^	const double M_COS_90 = 0.;$/;"	m	namespace:prgkern
M_INV_2	include/prgkern/_math.h	/^	const double M_INV_2 = 1.\/ 2.;$/;"	m	namespace:prgkern
M_INV_3	include/prgkern/_math.h	/^	const double M_INV_3 = 1.\/ 3.;$/;"	m	namespace:prgkern
M_INV_4	include/prgkern/_math.h	/^	const double M_INV_4 = 1.\/ 4.;$/;"	m	namespace:prgkern
M_INV_5	include/prgkern/_math.h	/^	const double M_INV_5 = 1.\/ 5.;$/;"	m	namespace:prgkern
M_INV_6	include/prgkern/_math.h	/^	const double M_INV_6 = 1.\/ 6.;$/;"	m	namespace:prgkern
M_INV_7	include/prgkern/_math.h	/^	const double M_INV_7 = 1.\/ 7.;$/;"	m	namespace:prgkern
M_INV_8	include/prgkern/_math.h	/^	const double M_INV_8 = 1.\/ 8.;$/;"	m	namespace:prgkern
M_INV_9	include/prgkern/_math.h	/^	const double M_INV_9 = 1.\/ 9.;$/;"	m	namespace:prgkern
M_REVERSE_LN2	include/prgkern/_math.h	/^	const double M_REVERSE_LN2 = 1. \/ ::log(2.);$/;"	m	namespace:prgkern
M_REVERSE_SQRT_2PI	include/prgkern/_math.h	/^	const double M_REVERSE_SQRT_2PI = 1. \/ M_SQRT_2PI;$/;"	m	namespace:prgkern
M_REVERSE_SQRT_PI	include/prgkern/_math.h	/^	const double M_REVERSE_SQRT_PI = 1. \/ M_SQRT_PI;$/;"	m	namespace:prgkern
M_SIN_0	include/prgkern/_math.h	/^	const double M_SIN_0  = 0.;$/;"	m	namespace:prgkern
M_SIN_30	include/prgkern/_math.h	/^	const double M_SIN_30 = 0.5;$/;"	m	namespace:prgkern
M_SIN_45	include/prgkern/_math.h	/^	const double M_SIN_45 = 0.5 * M_SQRT_2;$/;"	m	namespace:prgkern
M_SIN_60	include/prgkern/_math.h	/^	const double M_SIN_60 = 0.5 * M_SQRT_3;$/;"	m	namespace:prgkern
M_SIN_90	include/prgkern/_math.h	/^	const double M_SIN_90 = 1.;$/;"	m	namespace:prgkern
M_SQRT_1	include/prgkern/_math.h	/^	const double M_SQRT_1  = 1.;$/;"	m	namespace:prgkern
M_SQRT_10	include/prgkern/_math.h	/^	const double M_SQRT_10 = ::sqrt(10.);$/;"	m	namespace:prgkern
M_SQRT_11	include/prgkern/_math.h	/^	const double M_SQRT_11 = ::sqrt(11.);$/;"	m	namespace:prgkern
M_SQRT_12	include/prgkern/_math.h	/^	const double M_SQRT_12 = ::sqrt(12.);$/;"	m	namespace:prgkern
M_SQRT_2	include/prgkern/_math.h	/^	const double M_SQRT_2  = ::sqrt(2.);$/;"	m	namespace:prgkern
M_SQRT_2PI	include/prgkern/_math.h	/^	const double M_SQRT_2PI = ::sqrt(M_2PI);$/;"	m	namespace:prgkern
M_SQRT_3	include/prgkern/_math.h	/^	const double M_SQRT_3  = ::sqrt(3.);$/;"	m	namespace:prgkern
M_SQRT_4	include/prgkern/_math.h	/^	const double M_SQRT_4  = 2.;$/;"	m	namespace:prgkern
M_SQRT_5	include/prgkern/_math.h	/^	const double M_SQRT_5  = ::sqrt(5.);$/;"	m	namespace:prgkern
M_SQRT_6	include/prgkern/_math.h	/^	const double M_SQRT_6  = ::sqrt(6.);$/;"	m	namespace:prgkern
M_SQRT_7	include/prgkern/_math.h	/^	const double M_SQRT_7  = ::sqrt(7.);$/;"	m	namespace:prgkern
M_SQRT_8	include/prgkern/_math.h	/^	const double M_SQRT_8  = ::sqrt(8.);$/;"	m	namespace:prgkern
M_SQRT_9	include/prgkern/_math.h	/^	const double M_SQRT_9  = 3.;$/;"	m	namespace:prgkern
M_SQRT_PI	include/prgkern/_math.h	/^	const double M_SQRT_PI = ::sqrt(M_PI);$/;"	m	namespace:prgkern
Mesh_	include/prgkern/_mesh.h	/^	class Mesh_$/;"	c	namespace:prgkern
Minimizer_	include/prgkern/_minimize_lbfgs.h	/^	template <int TYPE> class Minimizer_$/;"	c	namespace:prgkern
Minimizer_	include/prgkern/_minimize_round.h	/^	template <> class Minimizer_<ROUND_>$/;"	c	namespace:prgkern
Molecule_	include/molkern/complex/_molecule.h	/^		Molecule_(const _Archetype *archetype, unsigned freedom_type)$/;"	f	class:molkern::Molecule_
Molecule_	include/molkern/complex/_molecule.h	/^	class Molecule_$/;"	c	namespace:molkern
NAME_	include/molkern/__moldefs.h	/^		NAME_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NDX_PARAM_PAIR	include/molkern/forcefield/_fparams.h	107;"	d
NDX_PARAM_PAIR	include/molkern/forcefield/_fparams.h	407;"	d
NEAR_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
NEIGHBOR_	include/molkern/__moldefs.h	/^		NEIGHBOR_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NEW	include/molkern/complex/_thermostat.h	252;"	d
NEW	include/molkern/complex/_thermostat.h	259;"	d
NODE_	include/molkern/__moldefs.h	/^		NODE_,               \/\/ узел данных (или копьютера)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NODE_PAIR_	include/molkern/__moldefs.h	/^		NODE_PAIR_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NORMAL_AXIS_ROTATOR_	include/prgkern/_rotator.h	/^	const int NORMAL_AXIS_ROTATOR_ = 5;$/;"	m	namespace:prgkern
NORMAL_PH_WATER	include/molkern/__moldefs.h	/^	const int NORMAL_PH_WATER = 7;$/;"	m	namespace:molkern
NORMAL_WATER_DENSITY	include/molkern/__moldefs.h	/^	const real_t NORMAL_WATER_DENSITY = 0.10035; \/\/ [частиц (!) в ангстрем **3]$/;"	m	namespace:molkern
NO_ATOM_	include/molkern/__moldefs.h	/^	const unsigned NO_ATOM_     = 0x00000000;$/;"	m	namespace:molkern
NO_CLASHES	include/molkern/__moldefs.h	/^	const bool NO_CLASHES = false; \/\/ флаг запрета клеширования$/;"	m	namespace:molkern
NO_CM_	include/molkern/__moldefs.h	/^	const unsigned NO_CM_       = 0x00000000;$/;"	m	namespace:molkern
NO_EQUIVALENTS	include/molkern/__moldefs.h	717;"	d
NO_HETEROATOMS	include/molkern/__moldefs.h	/^	const bool NO_HETEROATOMS = false; \/\/ don't read heteroatoms from file$/;"	m	namespace:molkern
NO_HYDROGEN	include/molkern/__moldefs.h	/^	const bool NO_HYDROGEN = false; \/\/ don't print hydrogen atoms to file$/;"	m	namespace:molkern
NO_IMPLEMENTATION	include/prgkern/_assert.h	35;"	d
NO_PERIODIC_	include/molkern/__moldefs.h	/^	const bool NO_PERIODIC_ = false; \/\/ флаг отсутствия пространственной периодичности системы$/;"	m	namespace:molkern
NO_PRINT	include/molkern/__moldefs.h	/^	const bool NO_PRINT = false;$/;"	m	namespace:molkern
NO_ROTAMER_	include/molkern/__moldefs.h	/^	const unsigned NO_ROTAMER_  = 0x00000000;$/;"	m	namespace:molkern
NO_UNION_	include/molkern/__moldefs.h	/^	const unsigned NO_UNION_    = 0x00000000;$/;"	m	namespace:molkern
NTERM_	include/molkern/__moldefs.h	/^		NTERM_,              \/\/ N терминал$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NUCLEAR_	include/molkern/__moldefs.h	/^		NUCLEAR_,            \/\/ заряд ядра$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
NVE	include/molkern/complex/_ensemble.h	/^	enum { NVE, NVT, NVP };$/;"	e	enum:molkern::__anon18
NVP	include/molkern/complex/_ensemble.h	/^	enum { NVE, NVT, NVP };$/;"	e	enum:molkern::__anon18
NVT	include/molkern/complex/_ensemble.h	/^	enum { NVE, NVT, NVP };$/;"	e	enum:molkern::__anon18
Node_	include/molkern/complex/_region.h	/^		Node_() {}$/;"	f	class:molkern::Node_
Node_	include/molkern/complex/_region.h	/^	template <> class Node_<3, void>$/;"	c	namespace:molkern
Node_	include/molkern/complex/_region.h	/^	template <typename S> class Node_<3, S> : public Node_<3, void>$/;"	c	namespace:molkern
Nuclear	include/molkern/forcefield/_nuclear.h	/^	const struct Nuclear$/;"	s	namespace:molkern
OBJECT_UNKNOWN_	include/molkern/__moldefs.h	/^		OBJECT_UNKNOWN_$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
OK	include/molkern/complex/_region.h	274;"	d
OK	include/molkern/complex/_region.h	298;"	d
OPERATOR_EQ	include/prgkern/_pproc.h	57;"	d
OPERATOR_EQ2	include/prgkern/_pproc.h	75;"	d
OPERATOR_LT	include/prgkern/_pproc.h	63;"	d
OPERATOR_LT2	include/prgkern/_pproc.h	81;"	d
OPERATOR_NE	include/prgkern/_pproc.h	60;"	d
OPERATOR_NE2	include/prgkern/_pproc.h	78;"	d
OPERATOR_PMEQ	include/prgkern/_pproc.h	66;"	d
OPERATOR_PMLT	include/prgkern/_pproc.h	72;"	d
OPERATOR_PMNE	include/prgkern/_pproc.h	69;"	d
OPTIMIZATION_PRINT	include/prgkern/_minimize.h	30;"	d
OPTIMIZATION_PRINT	include/prgkern/_minimize.h	37;"	d
OPTIMIZER_	include/molkern/__moldefs.h	/^		OPTIMIZER_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
OPTIMIZE_PRINT_FREQUENCY	include/prgkern/_minimize.h	/^	const int OPTIMIZE_PRINT_FREQUENCY = 1;$/;"	m	namespace:prgkern
ORTOGONAL_UNIT_	include/prgkern/_dense.h	/^		ORTOGONAL_UNIT_ = 2$/;"	e	enum:prgkern::__anon36
O_	include/prgkern/_rotator.h	/^		vdense_<3, T> O_, W_;$/;"	m	class:prgkern::Rotator
O_	include/prgkern/_rotator.h	/^		vdense_<3, T> W_, O_;$/;"	m	class:prgkern::Rotator
Optimizer_	include/molkern/complex/_optimize.h	/^	class Optimizer_ : protected Minimizer_<OPTIMIZER_TYPE>$/;"	c	namespace:molkern
PADDED_STRUCT	include/prgkern/_pproc.h	44;"	d
PADDED_STRUCT_END	include/prgkern/_pproc.h	33;"	d
PADDED_STRUCT_START	include/prgkern/_pproc.h	30;"	d
PAIR14_	include/molkern/__moldefs.h	/^		PAIR14_,             \/\/ парное 1-4 взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
PAIR_	include/molkern/__moldefs.h	/^		PAIR_,               \/\/ парное взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
PARALL_	include/molkern/__moldefs.h	/^		PARALL_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
PDB_RESIDUE_NAME_	include/molkern/__moldefs.h	/^		PDB_RESIDUE_NAME_,   \/\/ standard PDB residue name (HIS instead HIE or HID etc)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
POSITION_	include/molkern/__moldefs.h	/^		POSITION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
PRESSURE_	include/molkern/__moldefs.h	/^		PRESSURE_,           \/\/ давление$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
PRINT_BREAK	include/prgkern/_string.h	66;"	d
PRINT_ERR	include/prgkern/_string.h	58;"	d
PRINT_LINE	include/prgkern/_pproc.h	85;"	d
PRINT_MESSAGE	include/prgkern/_string.h	51;"	d
ParallWorker_	include/molkern/complex/_parallel.h	/^	class ParallWorker_$/;"	c	namespace:molkern
Parall_	include/molkern/complex/_parallel.h	/^	class Parall_$/;"	c	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<ANGLE_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<ATOM_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<BOND_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<EQUI_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<NUCLEAR_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_fparams.h	/^	template <> struct Params<TORSION_, FORCEFIELD_AMBER_>$/;"	s	namespace:molkern
Params	include/molkern/forcefield/_residue_amber.h	/^		Params() {}$/;"	f	struct:molkern::Params
Params	include/molkern/forcefield/_residue_amber.h	/^		Params(index_type name__) : name(name__) {}$/;"	f	struct:molkern::Params
Params	include/molkern/forcefield/_residue_amber.h	/^	template <> struct Params<RESIDUE_, RESIDOME_AMBER_>$/;"	s	namespace:molkern
Pk_	include/prgkern/_minimize_lbfgs.h	/^		mdense Pk_; \/\/ MATR * Zk               - normal saving$/;"	m	class:prgkern::Updater
Potential	include/molkern/forcefield/_potential.h	/^		Potential(_Real split_radius=DEFAULT_COULOMB_SPLIT_RADIUS)$/;"	f	class:molkern::Potential
Potential	include/molkern/forcefield/_potential.h	/^	template <typename _Real> class Potential<COUL_, _Real>$/;"	c	namespace:molkern
RAD2DEG	include/prgkern/_math.h	/^	const double RAD2DEG = 180. \/ M_PI;$/;"	m	namespace:prgkern
RADIUS_H2O	include/molkern/__moldefs.h	/^	const real_t RADIUS_H2O = (real_t) 1.4; \/\/ Angstrom$/;"	m	namespace:molkern
RAN0_MASK	include/prgkern/_random.h	39;"	d
RAN0_MASK	include/prgkern/_random.h	84;"	d
RAN0_MAX	include/prgkern/_random.h	40;"	d
RAN0_MAX	include/prgkern/_random.h	83;"	d
READ_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
REBUILD_	include/molkern/__moldefs.h	/^		REBUILD_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
REGION_	include/molkern/__moldefs.h	/^		REGION_,             \/\/ область пространства модели$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RESIDOME_	include/molkern/__moldefs.h	/^		RESIDOME_,           \/\/ база данных топологии$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RESIDOME_AMBER_	include/molkern/__moldefs.h	/^		RESIDOME_AMBER_,      \/\/ AMBER protein residome$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RESIDUE_	include/molkern/__moldefs.h	/^		RESIDUE_,            \/\/ аминокислотный остаток$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RESIDUE_CONTACT_	include/molkern/__moldefs.h	/^		RESIDUE_CONTACT_,    \/\/ building internal residue contacts$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RESIDUE_NAME_	include/molkern/__moldefs.h	/^		RESIDUE_NAME_,       \/\/ building internal residue names$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROOT_ROTAMER_	include/molkern/__moldefs.h	/^		ROOT_ROTAMER_,      \/\/ ротамеры, являющиеся стартовыми в построении$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROTAMER_	include/molkern/__moldefs.h	/^		ROTAMER_,            \/\/ ротамер$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROTAMER_ADD_ATOM_	include/molkern/__moldefs.h	/^		ROTAMER_ADD_ATOM_,  \/\/ атом для расчетов относительных углов$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROTAMER_EXT_ATOM_	include/molkern/__moldefs.h	/^		ROTAMER_EXT_ATOM_,  \/\/ атом на стике, но вне ротамера$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROTAMER_INT_ATOM_	include/molkern/__moldefs.h	/^		ROTAMER_INT_ATOM_,  \/\/ атом на стике, принадлежащий ротамеру$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROTAMER_POSITION_	include/molkern/__moldefs.h	/^		ROTAMER_POSITION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
ROUND_	include/prgkern/_minimize.h	/^	enum { SCITBX_LBFGS_, GSL_SIMPLEX_, STEEP_, LMBFGS_, ROUND_ };$/;"	e	enum:prgkern::__anon34
RSKIN_	include/molkern/__moldefs.h	/^		RSKIN_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
RUNV_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
RUN_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
Range_	include/prgkern/_math.h	/^		Range_() : min(T()), max(infinity<T>()) {}$/;"	f	struct:prgkern::Range_
Range_	include/prgkern/_math.h	/^		Range_(T a, T b) : min(a), max(b) {}$/;"	f	struct:prgkern::Range_
Range_	include/prgkern/_math.h	/^		Range_(const Range_ &range) : min(range.min), max(range.max) {}$/;"	f	struct:prgkern::Range_
Range_	include/prgkern/_math.h	/^	struct Range_$/;"	s	namespace:prgkern
RegEx	include/prgkern/_regex.h	/^		RegEx(const std::string &mask) : compiled_regex_(mask) {}$/;"	f	class:prgkern::RegEx
RegEx	include/prgkern/_regex.h	/^	class RegEx$/;"	c	namespace:prgkern
Region	include/molkern/complex/_region.h	/^	typedef Region_<3> Region;$/;"	t	namespace:molkern
Region_	include/molkern/complex/_region.h	/^		Region_(const index_type &sz, real_t interaction_radius, const vector_t *T=0)$/;"	f	class:molkern::Region_
Region_	include/molkern/complex/_region.h	/^		Region_(const std::string &sbox, real_t interaction_radius, const vector_t *T=0)$/;"	f	class:molkern::Region_
Region_	include/molkern/complex/_region.h	/^	template <typename S> class Region_<3, S>$/;"	c	namespace:molkern
Residome	include/molkern/forcefield/_residome_amber.h	/^	typedef Residome_<RESIDOME_AMBER_>  Residome;$/;"	t	namespace:molkern
Residome_	include/molkern/forcefield/_residome_amber.h	/^		Residome_() {}$/;"	f	class:molkern::Residome_
Residome_	include/molkern/forcefield/_residome_amber.h	/^		Residome_(const std::string &dirname, const std::string &fileregex=_S(".*?\\\\.lib$"))$/;"	f	class:molkern::Residome_
Residome_	include/molkern/forcefield/_residome_amber.h	/^	template <> class Residome_<RESIDOME_AMBER_>$/;"	c	namespace:molkern
Residue_	include/molkern/forcefield/_residue_amber.h	/^		Residue_() {}$/;"	f	class:molkern::Residue_
Residue_	include/molkern/forcefield/_residue_amber.h	/^	template <> class Residue_<RESIDOME_AMBER_>$/;"	c	namespace:molkern
ResiduesPdbSequenceNumber_	include/molkern/forcefield/_residue_amber.h	/^		int ResiduesPdbSequenceNumber_; \/\/ число загруженных остатков$/;"	m	struct:molkern::Params
Rk_	include/prgkern/_minimize_lbfgs.h	/^		mdense Rk_; \/\/ S(t)[i-1]*Y[j-1], if i<=j & 0 otherwise  - effective saving$/;"	m	class:prgkern::Updater
RotamerConnect_	include/molkern/forcefield/_rotamer.h	/^		RotamerConnect_() {}$/;"	f	struct:molkern::RotamerConnect_
RotamerConnect_	include/molkern/forcefield/_rotamer.h	/^		RotamerConnect_(unsigned r1, unsigned s1, unsigned r2, unsigned s2)$/;"	f	struct:molkern::RotamerConnect_
RotamerConnect_	include/molkern/forcefield/_rotamer.h	/^	struct RotamerConnect_$/;"	s	namespace:molkern
Rotamer_	include/molkern/forcefield/_residue.h	/^		typedef struct Rotamer_$/;"	s	class:molkern::basic_residue_
Rotamer_	include/molkern/forcefield/_rotamer.h	/^	class Rotamer_$/;"	c	namespace:molkern
Rotator	include/prgkern/_rotator.h	/^		Rotator(const vdense_<3, T> &O, const vdense_<3, T> &A, const vdense_<3, T> &B)$/;"	f	class:prgkern::Rotator
Rotator	include/prgkern/_rotator.h	/^		Rotator(const vdense_<3, T> &W, T w, const vdense_<3, T> &O)$/;"	f	class:prgkern::Rotator
Rotator	include/prgkern/_rotator.h	/^		Rotator(const vdense_<3, T> &X0) : X_(X0) {}$/;"	f	class:prgkern::Rotator
Rotator	include/prgkern/_rotator.h	/^		Rotator(const vdense_<3, T> &angle, const vdense_<3, T> &X0)$/;"	f	class:prgkern::Rotator
Rotator	include/prgkern/_rotator.h	/^		Rotator(const vdense_<3, T> &angles, const vdense_<3, T> &X0) : X0_(X0)$/;"	f	class:prgkern::Rotator
Rotator	include/prgkern/_rotator.h	/^	template <typename T> class Rotator<AXIS_ROTATOR_, T>$/;"	c	namespace:prgkern
Rotator	include/prgkern/_rotator.h	/^	template <typename T> class Rotator<EULER_ROTATOR_, T>$/;"	c	namespace:prgkern
Rotator	include/prgkern/_rotator.h	/^	template <typename T> class Rotator<INFINITE_ROTATOR_, T>$/;"	c	namespace:prgkern
Rotator	include/prgkern/_rotator.h	/^	template <typename T> class Rotator<NORMAL_AXIS_ROTATOR_, T>$/;"	c	namespace:prgkern
Rotator	include/prgkern/_rotator.h	/^	template <typename T> class Rotator<XYZ_ROTATOR_, T>$/;"	c	namespace:prgkern
Round_minimizer_	include/prgkern/_minimize_round.h	/^	class Round_minimizer_$/;"	c	namespace:prgkern
SAMPLE	include/molkern/complex/_thermostat.h	274;"	d
SASA_	include/molkern/__moldefs.h	/^		SASA_,               \/\/ solvent accessible surface area$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
SAVED_OK_MESSAGE	include/molkern/__moldefs.h	701;"	d
SAVE_TIMER_	include/molkern/__moldefs.h	/^	enum { READ_TIMER_=1000, SAVE_TIMER_, RUN_TIMER_, RUNV_TIMER_, NEAR_TIMER_, BUILD_TIMER_, CALC_TIMER_,$/;"	e	enum:molkern::__anon14
SCALAR_ARG1	include/prgkern/_sse.h	1208;"	d
SCALAR_ARG1	include/prgkern/_sse.h	478;"	d
SCALAR_ARG1	include/prgkern/_sse.h	824;"	d
SCALAR_ARG1	include/prgkern/_sse.h	832;"	d
SCALAR_ARG2	include/prgkern/_sse.h	1209;"	d
SCALAR_ARG2	include/prgkern/_sse.h	479;"	d
SCALAR_ARG2	include/prgkern/_sse.h	825;"	d
SCALAR_ARG2	include/prgkern/_sse.h	833;"	d
SCALAR_EXPRESSION_1	include/prgkern/_blas1.h	33;"	d
SCALAR_OPERATOR	include/prgkern/_sse.h	1204;"	d
SCALAR_OPERATOR	include/prgkern/_sse.h	474;"	d
SCALAR_OPERATOR	include/prgkern/_sse.h	820;"	d
SCALAR_OPERATOR	include/prgkern/_sse.h	828;"	d
SCALING	include/molkern/complex/_thermostat.h	284;"	d
SCALING	include/molkern/complex/_thermostat.h	288;"	d
SCITBX_LBFGS_	include/prgkern/_minimize.h	/^	enum { SCITBX_LBFGS_, GSL_SIMPLEX_, STEEP_, LMBFGS_, ROUND_ };$/;"	e	enum:prgkern::__anon34
SET_	include/molkern/__moldefs.h	/^		SET_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
SHARE_PARAM_DEF	include/prgkern/_minimize.h	111;"	d
SHARE_PARAM_DEF	include/prgkern/_minimize.h	414;"	d
SHARE_PARAM_DEF	include/prgkern/_minimize_round.h	41;"	d
SHARE_PARAM_DEF	include/prgkern/_minimize_round.h	548;"	d
SHARE_PARAM_VAL	include/prgkern/_minimize.h	116;"	d
SHARE_PARAM_VAL	include/prgkern/_minimize.h	415;"	d
SHARE_PARAM_VAL	include/prgkern/_minimize_round.h	47;"	d
SHARE_PARAM_VAL	include/prgkern/_minimize_round.h	549;"	d
SKIP_ANGLS_ENERGY	include/molkern/__moldefs.h	56;"	d
SKIP_BONDS_ENERGY	include/molkern/__moldefs.h	55;"	d
SKIP_COUL_ENERGY	include/molkern/__moldefs.h	58;"	d
SKIP_LINE	include/molkern/__moldefs.h	706;"	d
SKIP_TORAS_ENERGY	include/molkern/__moldefs.h	57;"	d
SKIP_UNTIL_EMPTY_LINE	include/molkern/__moldefs.h	710;"	d
SKIP_UNTIL_EMPTY_VALUE	include/molkern/forcefield/_forcefield_amber.h	10;"	d
SKIP_UNTIL_EMPTY_VALUE	include/molkern/forcefield/_forcefield_amber.h	210;"	d
SOLID_TdS_	include/molkern/__moldefs.h	/^		SOLID_TdS_,          \/\/ entropy of elimination of center mass & rotation as whole$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
SQRT_ELECTRIC_FACTOR	include/molkern/__moldefs.h	/^	const real_t SQRT_ELECTRIC_FACTOR = (real_t) sqrt(ELECTRIC_FACTOR);$/;"	m	namespace:molkern
SS_BOND_LENGTH	include/molkern/__moldefs.h	/^	const real_t SS_BOND_LENGTH = 2.2;$/;"	m	namespace:molkern
START_POSITION_	include/molkern/__moldefs.h	/^		START_POSITION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
STATIC_ASSERT	include/prgkern/_assert.h	28;"	d
STATIC_DIMENSION	include/prgkern/_pproc.h	23;"	d
STEEP_	include/prgkern/_minimize.h	/^	enum { SCITBX_LBFGS_, GSL_SIMPLEX_, STEEP_, LMBFGS_, ROUND_ };$/;"	e	enum:prgkern::__anon34
STICK_	include/molkern/__moldefs.h	/^		STICK_,             \/\/ ось ротамера, по которой ротамеры связываются$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
STOP_AFTER_FIRST_TOPOLOGY_ERROR	include/molkern/__moldefs.h	87;"	d
SYSTEM_ERR	include/prgkern/_string.h	76;"	d
SYSTEM_MUTEX_LOCK	include/prgkern/_prgconfig.h	59;"	d
SYSTEM_MUTEX_UNLOCK	include/prgkern/_prgconfig.h	60;"	d
SYSTEM_WARN	include/prgkern/_string.h	91;"	d
Sk_	include/prgkern/_minimize_lbfgs.h	/^		std::vector<_Vector> Sk_; \/\/ X(k+1) - X(k)               - effective saving$/;"	m	class:prgkern::Updater
Stencil_	include/prgkern/_stencil.h	/^		Stencil_(T h, T radius) : h_ (h), radius2_(sqr(radius)), tune_param_(1.)$/;"	f	class:prgkern::Stencil_
Stencil_	include/prgkern/_stencil.h	/^		template <typename F> Stencil_(F fn)$/;"	f	class:prgkern::Stencil_
Stencil_	include/prgkern/_stencil.h	/^	template <typename T> class Stencil_<3, 0, T>$/;"	c	namespace:prgkern
Stencil_	include/prgkern/_stencil.h	/^	template <typename T> class Stencil_<3, 3, T>$/;"	c	namespace:prgkern
Stencil_	include/prgkern/_stencil.h	/^	template <typename T> class Stencil_<3, 5, T>$/;"	c	namespace:prgkern
TEMPERATURE_	include/molkern/__moldefs.h	/^		TEMPERATURE_,        \/\/ температура ансамбля (K)$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
TEMPLATE_ARG	include/molkern/complex/_archetype.h	3503;"	d
TEMPLATE_ARG	include/molkern/complex/_archetype.h	806;"	d
TEMPLATE_ARG	include/molkern/complex/_complex.h	1199;"	d
TEMPLATE_ARG	include/molkern/complex/_complex.h	412;"	d
TEMPLATE_ARG	include/molkern/complex/_linkcell.h	115;"	d
TEMPLATE_ARG	include/molkern/complex/_linkcell.h	553;"	d
TEMPLATE_ARG	include/molkern/complex/_molecule.h	168;"	d
TEMPLATE_ARG	include/molkern/complex/_molecule.h	235;"	d
TEMPLATE_ARG	include/molkern/complex/_region.h	1009;"	d
TEMPLATE_ARG	include/molkern/complex/_region.h	810;"	d
TEMPLATE_ARG	include/molkern/complex/_verlet.h	1307;"	d
TEMPLATE_ARG	include/molkern/complex/_verlet.h	205;"	d
TEMPLATE_ARG	include/molkern/forcefield/_forcefield.h	208;"	d
TEMPLATE_ARG	include/molkern/forcefield/_forcefield.h	602;"	d
TEMPLATE_ARG	include/molkern/forcefield/_forcefield_amber.h	113;"	d
TEMPLATE_ARG	include/molkern/forcefield/_forcefield_amber.h	208;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residome.h	104;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residome.h	71;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residome_amber.h	225;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residome_amber.h	287;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residue_amber.h	174;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residue_amber.h	505;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residue_amber.h	533;"	d
TEMPLATE_ARG	include/molkern/forcefield/_residue_amber.h	599;"	d
TEMPLATE_ARG	include/prgkern/_minimize_lbfgs.h	116;"	d
TEMPLATE_ARG	include/prgkern/_minimize_lbfgs.h	265;"	d
TEMPLATE_HEADER	include/molkern/complex/_archetype.h	3502;"	d
TEMPLATE_HEADER	include/molkern/complex/_archetype.h	805;"	d
TEMPLATE_HEADER	include/molkern/complex/_complex.h	1198;"	d
TEMPLATE_HEADER	include/molkern/complex/_complex.h	411;"	d
TEMPLATE_HEADER	include/molkern/complex/_linkcell.h	114;"	d
TEMPLATE_HEADER	include/molkern/complex/_linkcell.h	552;"	d
TEMPLATE_HEADER	include/molkern/complex/_molecule.h	167;"	d
TEMPLATE_HEADER	include/molkern/complex/_molecule.h	234;"	d
TEMPLATE_HEADER	include/molkern/complex/_region.h	1008;"	d
TEMPLATE_HEADER	include/molkern/complex/_region.h	809;"	d
TEMPLATE_HEADER	include/molkern/complex/_verlet.h	1306;"	d
TEMPLATE_HEADER	include/molkern/complex/_verlet.h	204;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_forcefield.h	207;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_forcefield.h	601;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_forcefield_amber.h	112;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_forcefield_amber.h	207;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residome.h	103;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residome.h	70;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residome_amber.h	224;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residome_amber.h	286;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residue_amber.h	173;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residue_amber.h	504;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residue_amber.h	532;"	d
TEMPLATE_HEADER	include/molkern/forcefield/_residue_amber.h	598;"	d
TEMPLATE_HEADER	include/prgkern/_minimize_lbfgs.h	115;"	d
TEMPLATE_HEADER	include/prgkern/_minimize_lbfgs.h	264;"	d
THERMOSTATE_	include/molkern/__moldefs.h	/^		THERMOSTATE_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
TIMER_1	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_2	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_3	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_4	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_5	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_6	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_7	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIMER_8	include/molkern/__moldefs.h	/^		GON_TIMER_, FILTER_TIMER_, BUILD2_TIMER_, TIMER_1, TIMER_2, TIMER_3, TIMER_4, TIMER_5, TIMER_6, TIMER_7, TIMER_8};$/;"	e	enum:molkern::__anon14
TIME_TESTING_FINISH	include/prgkern/_time.h	117;"	d
TIME_TESTING_FINISH	include/prgkern/_time.h	73;"	d
TIME_TESTING_START	include/prgkern/_time.h	116;"	d
TIME_TESTING_START	include/prgkern/_time.h	60;"	d
TOLERANCE_OK	include/prgkern/_minimize.h	/^		enum { FAIL, INTERVAL_OK, FUNCTION_DIFFERENCE_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Line_minimizer_::__anon35
TOLERANCE_OK	include/prgkern/_minimize_round.h	/^		enum { FAIL, INTERVAL_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Round_minimizer_::__anon30
TORSION_	include/molkern/__moldefs.h	/^		TORSION_,            \/\/ торсионный угол$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
T_	include/molkern/complex/_ensemble.h	/^		Average_<real_t> T_; \/\/ температура для разных точек фазового пространства$/;"	m	class:molkern::Ensemble_
T_	include/molkern/complex/_region.h	/^		vector_t T_, _1T_; \/\/ прямой и обратный вектор трансляции грида$/;"	m	class:molkern::Region_
TdS_	include/molkern/__moldefs.h	/^		TdS_,                \/\/ полная энтропия$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
Temperature	include/molkern/__moldefs.h	/^	INLINE T Temperature(T energy) { return  (T)(energy \/ AUE_BOLTZMAN); }$/;"	f	namespace:molkern
Thermostat	include/molkern/complex/_thermostat.h	/^		Thermostat(const Descriptor_<THERMOSTATE_> &desc, _Molecule *molecule)$/;"	f	class:molkern::Thermostat
Thermostat	include/molkern/complex/_thermostat.h	/^	class Thermostat$/;"	c	namespace:molkern
Tk_	include/prgkern/_minimize_lbfgs.h	/^		mdense Tk_; \/\/ Rk**(-1)                - normal saving$/;"	m	class:prgkern::Updater
Torsion_	include/molkern/forcefield/_torsion.h	/^	template <int FORCEFIELD_TYPE> struct Torsion_$/;"	s	namespace:molkern
U	include/molkern/complex/_archetype.h	/^	::U(_I2T<ANGLE_>, const _Atom *atoms, _Iterator start, _Iterator end, bool make_print) const$/;"	f	class:molkern::Archetype_
U	include/molkern/complex/_archetype.h	/^	::U(_I2T<BOND_>, const _Atom *atoms, _Iterator start, _Iterator end, bool make_print) const$/;"	f	class:molkern::Archetype_
U	include/molkern/complex/_archetype.h	/^	::U(_I2T<PAIR14_>, const _Atom *atoms, _Iterator start, _Iterator end, bool make_print) const$/;"	f	class:molkern::Archetype_
U	include/molkern/complex/_archetype.h	/^	::U(_I2T<TORSION_>, const _Atom *atoms, _Iterator start, _Iterator end, bool make_print) const$/;"	f	class:molkern::Archetype_
U	include/molkern/complex/_complex.h	/^	::U(bool make_print) const$/;"	f	class:molkern::Complex_
U	include/molkern/complex/_molecule.h	/^	::U(const _Atom *atoms, bool make_print) const$/;"	f	class:molkern::Molecule_
U	include/molkern/forcefield/_1interactions.h	/^		static real_t U(int curf, const int *n, const real_t *v, const real_t *phi,$/;"	f	struct:molkern::Interaction1_
U	include/molkern/forcefield/_1interactions.h	/^		static real_t U(real_t ke, real_t q0, const vector_t &A, const vector_t &B)$/;"	f	struct:molkern::Interaction1_
U	include/molkern/forcefield/_1interactions.h	/^		static real_t U(real_t ke, real_t q0, const vector_t &R)$/;"	f	struct:molkern::Interaction1_
U	include/molkern/forcefield/_bond.h	/^		real_t U(const vector_t &R) const$/;"	f	struct:molkern::Bond_
U	include/molkern/forcefield/_interactions.h	/^		static real_t U(_I2T<COUL_>, real_t sigma2, real_t charge,$/;"	f	struct:molkern::Interaction_
U	include/molkern/forcefield/_interactions.h	/^		static real_t U(_I2T<VDW_>, real_t sigma2, real_t eps,$/;"	f	struct:molkern::Interaction_
UNIT_	include/prgkern/_dense.h	/^		UNIT_ = 1,$/;"	e	enum:prgkern::__anon36
UNLIMITED_	include/prgkern/_dense.h	/^	const unsigned UNLIMITED_ = 0; \/\/ unlimited dimention of vector or matrix$/;"	m	namespace:prgkern
USES_EQUIVALENTS	include/molkern/__moldefs.h	725;"	d
USES_EQUIVALENTS	include/molkern/__moldefs.h	734;"	d
USES_EQUIVALENTS	include/molkern/__moldefs.h	737;"	d
USES_EQUIVALENTS	include/molkern/forcefield/_forcefield.h	14;"	d
USES_EQUIVALENTS	include/molkern/forcefield/_forcefield.h	604;"	d
USES_EQUIVALENTS	include/molkern/forcefield/_forcefield_amber.h	211;"	d
USES_EQUIVALENTS	include/molkern/forcefield/_forcefield_amber.h	27;"	d
USE_AS_FIXED_	include/molkern/__moldefs.h	/^	const unsigned_t USE_AS_FIXED_ = 0x80000000; \/\/ бит в 31 позиции$/;"	m	namespace:molkern
USE_AS_FREE_	include/molkern/__moldefs.h	/^	const unsigned_t USE_AS_FREE_  = 0x00000000; \/\/ нет битов$/;"	m	namespace:molkern
USE_FLOAT	include/molkern/__moldefs.h	111;"	d
USE_FLOAT	include/molkern/__moldefs.h	21;"	d
USE_GONNET	include/molkern/__moldefs.h	46;"	d
USE_HEAVY_HYDROGENS	include/molkern/__moldefs.h	96;"	d
USE_LINUX_SPECIFIC_CODE	include/prgkern/_prgconfig.h	31;"	d
USE_POSIX_2001	include/prgkern/_prgconfig.h	27;"	d
USE_SSE	include/molkern/__moldefs.h	27;"	d
USE_STATISTICS_CONTROL	include/molkern/__moldefs.h	99;"	d
USE_VECTORIZATION	include/molkern/__moldefs.h	112;"	d
USE_VECTORIZATION	include/molkern/__moldefs.h	24;"	d
USE_VERLET_TABLE	include/molkern/__moldefs.h	116;"	d
USE_WINDOWS_SPECIFIC_CODE	include/prgkern/_prgconfig.h	45;"	d
USING_FFTW3_CONNECT_DEFINES	include/prgkern/_transforms.h	299;"	d
U_	include/molkern/complex/_complex.h	/^	::U_(_I2T<PAIR_>, bool make_print) const$/;"	f	class:molkern::Complex_
Updater	include/prgkern/_minimize_lbfgs.h	/^		Updater(unsigned nmax, unsigned m=0, int=0) : n_(nmax) {}$/;"	f	class:prgkern::Updater
Updater	include/prgkern/_minimize_lbfgs.h	/^		Updater(unsigned nmax, unsigned mmax, int steep_iterations=DEFAULT_STEEP_ITERATIONS)$/;"	f	class:prgkern::Updater
Updater	include/prgkern/_minimize_lbfgs.h	/^	template <typename _Real> class Updater<LMBFGS_, _Real>$/;"	c	namespace:prgkern
Updater	include/prgkern/_minimize_lbfgs.h	/^	template <typename _Real> class Updater<STEEP_, _Real>$/;"	c	namespace:prgkern
V	include/molkern/complex/_complex.h	/^			vector_t V; \/\/\/< скорость атома$/;"	m	struct:molkern::Complex_::_Atom
V	include/molkern/forcefield/_atomdata.h	/^		vector_t V; \/\/ [angstrom \/ ps]$/;"	m	struct:molkern::Atomdata_
V0_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> V0_, V1_; \/\/ скорости в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
V1_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> V0_, V1_; \/\/ скорости в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
VALUE	include/prgkern/_fstring.h	40;"	d
VALUE	include/prgkern/_fstring.h	66;"	d
VDW14_	include/molkern/__moldefs.h	/^		VDW14_,              \/\/ ван-дер-ваальсово 1-4 взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
VDW_	include/molkern/__moldefs.h	/^		VDW_,                \/\/ ван-дер-ваальсово взаимодействие$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
VECTOR_ARG	include/prgkern/_sse.h	1207;"	d
VECTOR_ARG	include/prgkern/_sse.h	477;"	d
VECTOR_ARG	include/prgkern/_sse.h	823;"	d
VECTOR_ARG	include/prgkern/_sse.h	831;"	d
VECTOR_EXPRESSION_0	include/prgkern/_blas1.h	46;"	d
VECTOR_EXPRESSION_1	include/prgkern/_blas1.h	57;"	d
VECTOR_EXPRESSION_2	include/prgkern/_blas1.h	69;"	d
VECTOR_EXPRESSION_3	include/prgkern/_blas1.h	85;"	d
VECTOR_OPERATOR	include/prgkern/_sse.h	1203;"	d
VECTOR_OPERATOR	include/prgkern/_sse.h	473;"	d
VECTOR_OPERATOR	include/prgkern/_sse.h	819;"	d
VECTOR_OPERATOR	include/prgkern/_sse.h	827;"	d
VELOCITY_	include/molkern/__moldefs.h	/^		VELOCITY_,           \/\/ скорость$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
VERLET_DEBUG	include/molkern/__moldefs.h	84;"	d
VERLET_PAIR_	include/molkern/__moldefs.h	/^		VERLET_PAIR_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
VERLET__09ED1116_C3FE_55a4_CA63_F84536C80D01__H	include/molkern/complex/_verlet.h	2;"	d
VOLUME_	include/molkern/__moldefs.h	/^		VOLUME_,             \/\/ объем$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
WATER_	include/molkern/__moldefs.h	/^		WATER_,              \/\/ раствор$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
WATER_CLASH_RADIUS	include/molkern/__moldefs.h	/^	const real_t WATER_CLASH_RADIUS = 5.; \/\/ 3.3950 + 1.7683; (Cs + OW)$/;"	m	namespace:molkern
WOLFE_OK	include/prgkern/_minimize.h	/^		enum { FAIL, INTERVAL_OK, FUNCTION_DIFFERENCE_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Line_minimizer_::__anon35
WOLFE_OK	include/prgkern/_minimize_round.h	/^		enum { FAIL, INTERVAL_OK, WOLFE_OK, TOLERANCE_OK };$/;"	e	enum:prgkern::Round_minimizer_::__anon30
W_	include/prgkern/_rotator.h	/^		vdense_<3, T> O_, W_;$/;"	m	class:prgkern::Rotator
W_	include/prgkern/_rotator.h	/^		vdense_<3, T> W_, O_;$/;"	m	class:prgkern::Rotator
Wk_	include/prgkern/_minimize_lbfgs.h	/^		mdense Wk_; \/\/ Yk(T)*H0*Yk                              - effective saving$/;"	m	class:prgkern::Updater
X	include/molkern/__config.h	/^		vector_t X; \/\/ точка привязки локального ящика (при count = 1)$/;"	m	struct:molkern::Descriptor_
X	include/molkern/complex/_complex.h	/^			vector_t X; \/\/\/< текущая координата атома$/;"	m	struct:molkern::Complex_::_Atom
X	include/molkern/complex/_complex.h	/^			vector_t X; \/\/\/< текущая координата атома$/;"	m	struct:molkern::Complex_::_LJAtom
X	include/molkern/forcefield/_atomdata.h	/^		vector_t X; \/\/ [angstrom]$/;"	m	struct:molkern::Atomdata_
X0	include/molkern/forcefield/_residue.h	/^		vector_t X0; \/\/ позиция атома в остатке$/;"	m	struct:molkern::__ResidueAtomdata
X0_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> X0_, X1_; \/\/ координаты в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
X0_	include/prgkern/_rotator.h	/^		vdense_<3, T> X0_;$/;"	m	class:prgkern::Rotator
X1_	include/molkern/complex/_mdynamics.h	/^		std::vector<vector_t> X0_, X1_; \/\/ координаты в предыдущей, текущей точке$/;"	m	class:molkern::Integrator_
XPOSITION_	include/molkern/__moldefs.h	/^		XPOSITION_,$/;"	e	enum:molkern::IDENTS_OF_OBJECTS
XYZ_ROTATOR_	include/prgkern/_rotator.h	/^	const int XYZ_ROTATOR_      = 4;$/;"	m	namespace:prgkern
X_	include/molkern/complex/_region.h	/^		std::vector<vector_t> X_[8]; \/\/ координаты вставки элементов$/;"	m	class:molkern::Node_
X_	include/prgkern/_rotator.h	/^		vdense_<3, T> X_;$/;"	m	class:prgkern::Rotator
YES_ATOM_	include/molkern/__moldefs.h	/^	const unsigned YES_ATOM_     = 0x00000008;$/;"	m	namespace:molkern
YES_CLASHES	include/molkern/__moldefs.h	/^	const bool YES_CLASHES = true; \/\/ флаг разрешения клеширования$/;"	m	namespace:molkern
YES_CM_	include/molkern/__moldefs.h	/^	const unsigned YES_CM_       = 0x00000002;$/;"	m	namespace:molkern
YES_HETEROATOMS	include/molkern/__moldefs.h	/^	const bool YES_HETEROATOMS = true; \/\/ read heteroatoms from file$/;"	m	namespace:molkern
YES_HYDROGEN	include/molkern/__moldefs.h	/^	const bool YES_HYDROGEN = true; \/\/ print hydrogen atoms to file$/;"	m	namespace:molkern
YES_PERIODIC_	include/molkern/__moldefs.h	/^	const bool YES_PERIODIC_ = true; \/\/ флаг пространственной периодичности системы$/;"	m	namespace:molkern
YES_PRINT	include/molkern/__moldefs.h	/^	const bool YES_PRINT = true;$/;"	m	namespace:molkern
YES_ROTAMER_	include/molkern/__moldefs.h	/^	const unsigned YES_ROTAMER_  = 0x00000004;$/;"	m	namespace:molkern
YES_UNION_	include/molkern/__moldefs.h	/^	const unsigned YES_UNION_    = 0x00000001; \/\/ бит объединения подцепей в движении$/;"	m	namespace:molkern
Yk_	include/prgkern/_minimize_lbfgs.h	/^		std::vector<_Vector> Yk_; \/\/ grad(k+1) - grad(k)         - effective saving$/;"	m	class:prgkern::Updater
Zk_	include/prgkern/_minimize_lbfgs.h	/^		mdense Zk_; \/\/ [Sk(T)*qk, Yk(T)*H0*qk] - normal saving$/;"	m	class:prgkern::Updater
_128K	include/prgkern/_os.h	/^	const unsigned _128K = 0x00020000;$/;"	m	namespace:prgkern
_16K	include/prgkern/_os.h	/^	const unsigned _16K  = 0x00004000;$/;"	m	namespace:prgkern
_1INTERACTION__F9ED1116_D4D6_5cf5_C20E_AC432B290700__H	include/molkern/forcefield/_1interactions.h	2;"	d
_1K	include/prgkern/_os.h	/^	const unsigned _1K   = 0x00000400;$/;"	m	namespace:prgkern
_1M	include/prgkern/_os.h	/^	const unsigned _1M   = 0x00100000;$/;"	m	namespace:prgkern
_1T_	include/molkern/complex/_region.h	/^		vector_t T_, _1T_; \/\/ прямой и обратный вектор трансляции грида$/;"	m	class:molkern::Region_
_1h_	include/molkern/complex/_region.h	/^		real_t h_, _1h_;  \/\/ прямой и обратный шаг ячейки = 1 \/ h$/;"	m	class:molkern::Region_
_1h_	include/prgkern/_mesh.h	/^		_Real h_, _1h_; \/\/ шаг и обратный шаг сетки$/;"	m	class:prgkern::Mesh_
_1mass_	include/molkern/complex/_mdynamics.h	/^		std::vector<real_t> _1mass_;      \/\/ инверсные массы атомов (1 \/ mass)$/;"	m	class:molkern::Integrator_
_1name	include/molkern/forcefield/_residue.h	/^		char _1name;$/;"	m	struct:molkern::AminoAcidName
_1t_	include/molkern/complex/_region.h	/^		vecreal_<4, real_t> t_, _1t_;$/;"	m	class:molkern::Region_
_256K	include/prgkern/_os.h	/^	const unsigned _256K = 0x00040000;$/;"	m	namespace:prgkern
_2K	include/prgkern/_os.h	/^	const unsigned _2K   = 0x00000800;$/;"	m	namespace:prgkern
_2M	include/prgkern/_os.h	/^	const unsigned _2M   = 0x00200000;$/;"	m	namespace:prgkern
_32K	include/prgkern/_os.h	/^	const unsigned _32K  = 0x00008000;$/;"	m	namespace:prgkern
_3name	include/molkern/forcefield/_residue.h	/^		fstring _3name;$/;"	m	struct:molkern::AminoAcidName
_4K	include/prgkern/_os.h	/^	const unsigned _4K   = 0x00001000;$/;"	m	namespace:prgkern
_512K	include/prgkern/_os.h	/^	const unsigned _512K = 0x00080000;$/;"	m	namespace:prgkern
_64K	include/prgkern/_os.h	/^	const unsigned _64K  = 0x00010000;$/;"	m	namespace:prgkern
_8K	include/prgkern/_os.h	/^	const unsigned _8K   = 0x00002000;$/;"	m	namespace:prgkern
_A	include/prgkern/_index.h	45;"	d
_A	include/prgkern/_index.h	95;"	d
_A	include/prgkern/_m3x3dense.h	168;"	d
_A	include/prgkern/_m3x3dense.h	34;"	d
_A	include/prgkern/_v3dense.h	129;"	d
_A	include/prgkern/_v3dense.h	42;"	d
_A	include/prgkern/_vdense.h	153;"	d
_A	include/prgkern/_vdense.h	35;"	d
_ANGLE__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/forcefield/_angle.h	2;"	d
_ARCHETYPE__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_archetype.h	2;"	d
_ASSERT	include/prgkern/_dense.h	52;"	d
_ASSERT	include/prgkern/_dense.h	91;"	d
_ASSERT	include/prgkern/_mdense.h	41;"	d
_ASSERT__09267106_F08A_58bd_BC7E_BF415E780A02__H	include/prgkern/_assert.h	21;"	d
_ATOMDATA__F9ED1116_3BFB_5a4c_6CDD_F74523C50B00__H	include/molkern/forcefield/_atomdata.h	2;"	d
_ATOM__F9ED1116_DBE3_5136_EADB_F745B2F10100__H	include/molkern/forcefield/_atom.h	2;"	d
_AVERAGE__0077A726_F90F_5e24_13E9_DD43611C0B00__H	include/prgkern/_average.h	21;"	d
_Angle	include/molkern/complex/_archetype.h	/^		typedef Angle_<FORCEFIELD_AMBER_>       _Angle;$/;"	t	class:molkern::Archetype_
_Archetype	include/molkern/complex/_complex.h	/^		typedef Archetype_<FORCEFIELD_TYPE, RESIDOME_TYPE>  _Archetype;$/;"	t	class:molkern::Complex_
_Atom	include/molkern/complex/_complex.h	/^		struct _Atom$/;"	s	class:molkern::Complex_
_Atom	include/molkern/complex/_linkcell.h	/^		typedef typename _LPComplex::atom_type    _Atom;$/;"	t	class:molkern::_Link_cell
_Atom	include/molkern/complex/_verlet.h	/^		typedef typename _LPComplex::atom_type    _Atom;$/;"	t	class:molkern::_Verlet_table
_Atom	include/molkern/forcefield/_residue_amber.h	/^		} _Atom;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon1
_Atomdata	include/molkern/complex/_archetype.h	/^		typedef Atomdata_                       _Atomdata;$/;"	t	class:molkern::Archetype_
_Atomdata	include/molkern/complex/_complex.h	/^		typedef typename _Archetype::atom_type              _Atomdata;$/;"	t	class:molkern::Complex_
_Atomdata	include/molkern/complex/_molecule.h	/^		typedef typename _Archetype::atomdata_type  _Atomdata;$/;"	t	class:molkern::Molecule_
_Atompertinfo	include/molkern/forcefield/_residue_amber.h	/^		} _Atompertinfo;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon3
_B2T	include/prgkern/_type.h	33;"	d
_BLAS1__0077A726_4743_5b7f_B566_CE43E5B50700__H	include/prgkern/_blas1.h	21;"	d
_BOND__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/forcefield/_bond.h	2;"	d
_BOX__0077A726_9B21_5114_65E1_C84410790000__H	include/prgkern/_box.h	21;"	d
_Base	include/molkern/complex/_region.h	/^		typedef Node_<3, void>                _Base;$/;"	t	class:molkern::Node_
_Base	include/molkern/complex/_thermostat.h	/^		typedef variate_generator_<_Distribution>  _Base;$/;"	t	class:molkern::maxwell_distribution_
_Base	include/molkern/forcefield/_forcefield_amber.h	/^		typedef __Forcefield <FORCEFIELD_AMBER_> _Base;$/;"	t	class:molkern::Forcefield_
_Base	include/molkern/forcefield/_residome_amber.h	/^		typedef basic_residome_<RESIDOME_AMBER_>   _Base;$/;"	t	class:molkern::Residome_
_Base	include/molkern/forcefield/_residue_amber.h	/^		typedef basic_residue_<RESIDOME_AMBER_>    _Base;$/;"	t	class:molkern::Residue_
_Base	include/prgkern/_average.h	/^		typedef std::vector<S> _Base;$/;"	t	class:prgkern::Average_
_Base	include/prgkern/_dense.h	/^		typedef std::vector<T>                  _Base;$/;"	t	class:prgkern::basic_dense_
_Base	include/prgkern/_index.h	/^		typedef index_<N, T>  _Base;$/;"	t	struct:prgkern::sym_index_
_Base	include/prgkern/_index.h	/^		typedef index_cast_<N>  _Base;$/;"	t	class:prgkern::cycle_index_cast
_Base	include/prgkern/_random.h	/^		typedef boost::normal_distribution<_Real>  _Base;$/;"	t	class:prgkern::normal_distribution_
_Base	include/prgkern/_transforms.h	/^		typedef fftw3_connect<_N, _Real>  _Base;$/;"	t	class:prgkern::Dfft
_Base	include/prgkern/_transforms.h	/^		typedef fftw3_connect<_N, _Real> _Base;$/;"	t	class:prgkern::Dfft
_Bond	include/molkern/complex/_archetype.h	/^		typedef Bond_<FORCEFIELD_AMBER_>        _Bond;$/;"	t	class:molkern::Archetype_
_Bond	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int atom1x, atom2x, flags; } _Bond;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon5
_BoundBox	include/molkern/forcefield/_residue_amber.h	/^		} _BoundBox;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon4
_Box	include/molkern/complex/_archetype.h	/^		typedef Box_<3, real_t>                 _Box;$/;"	t	class:molkern::Archetype_
_Box	include/molkern/complex/_complex.h	/^		typedef Box_<3, real_t>                             _Box;$/;"	t	class:molkern::Complex_
_Box	include/molkern/complex/_region.h	/^		typedef Box_<3, real_t>      _Box;$/;"	t	class:molkern::Region_
_Box	include/prgkern/_mesh.h	/^		typedef Box_<N, _Real>       _Box;   \/\/\/< область пространства$/;"	t	class:prgkern::Mesh_
_C	include/molkern/complex/_region.h	198;"	d
_C	include/molkern/complex/_region.h	213;"	d
_COMPLEX__09ED1116_C3FE_55a4_CA63_F84536C80D00__H	include/molkern/complex/_complex.h	2;"	d
_Chain	include/molkern/complex/_archetype.h	/^		typedef Chain_                          _Chain;$/;"	t	class:molkern::Archetype_
_Chain	include/molkern/complex/_complex.h	/^		typedef typename _Archetype::chain_type             _Chain;$/;"	t	class:molkern::Complex_
_Chain	include/molkern/complex/_molecule.h	/^		typedef typename _Archetype::chain_type     _Chain;$/;"	t	class:molkern::Molecule_
_Connect	include/molkern/forcefield/_residue_amber.h	/^		typedef int _Connect; \/\/ used as array of 2 elements ([0] - prev, [1] - next)$/;"	t	struct:molkern::Params
_DEBUG	include/prgkern/_prgconfig.h	32;"	d
_DEBUG	include/prgkern/_prgconfig.h	35;"	d
_DEBUG_GUARD	include/prgkern/_pproc.h	132;"	d
_DEBUG___0077A726_E6E3_58a1_C16D_CE436AB90500__H	include/prgkern/_debug.h	21;"	d
_DENSE__0077A726_4743_5b7f_B566_CE43E5B50700__H	include/prgkern/_dense.h	21;"	d
_Descriptor	include/molkern/complex/_thermostat.h	/^		typedef Descriptor_<THERMOSTATE_>  _Descriptor;$/;"	t	class:molkern::Thermostat
_Distribution	include/molkern/complex/_thermostat.h	/^		typedef maxwell_distribution_<_Real>        _Distribution;$/;"	t	class:molkern::maxwell_distribution_ensemble_
_Distribution	include/molkern/complex/_thermostat.h	/^		typedef normal_distribution_<_Real>        _Distribution;$/;"	t	class:molkern::maxwell_distribution_
_E	include/prgkern/_type.h	71;"	d
_ENSEMBLE__F9ED1116_EDB9_5e17_25FF_F745B15D0101__H	include/molkern/complex/_ensemble.h	2;"	d
_EQ	include/prgkern/_assert.h	57;"	d
_Edge	include/molkern/complex/_archetype.h	/^		typedef RotamerConnect_                 _Edge;$/;"	t	class:molkern::Archetype_
_Edge	include/molkern/complex/_molecule.h	/^		typedef typename _Archetype::edge_type      _Edge;$/;"	t	class:molkern::Molecule_
_Ensemble	include/molkern/complex/_thermostat.h	/^		typedef std::map<unsigned, _Distribution>   _Ensemble;$/;"	t	class:molkern::maxwell_distribution_ensemble_
_Equi	include/molkern/forcefield/_residome_amber.h	/^		struct _Equi$/;"	s	namespace:molkern::amber
_FLOG2	include/prgkern/_math.h	/^	template <> struct _FLOG2<1> { enum { result = 0 }; };$/;"	s	namespace:prgkern
_FLOG2	include/prgkern/_math.h	/^	template <int N> struct _FLOG2 { enum { result = 1 + _FLOG2<(N >> 1)>::result }; };$/;"	s	namespace:prgkern
_FORCRFIELD_AMBER__0077A726_F6D3_5e58_EF3F_E84517630500__H	include/molkern/forcefield/_forcefield_amber.h	2;"	d
_FOR__0077A726_AC88_55c0_4A44_CE4344760601__H	include/prgkern/_for.h	21;"	d
_FPARAMS__F9ED1116_B3CD_5e56_EF64_DB4362A40D00__H	include/molkern/forcefield/_fparams.h	2;"	d
_FSTRING__FC42EF6_3B55_5d9a_1B59_514158A70601__H	include/prgkern/_fstring.h	21;"	d
_Fn	include/molkern/complex/_parallel.h	/^		typedef void (Object::*_Fn)(unsigned, void *, void *);$/;"	t	class:molkern::ParallWorker_
_Fn	include/molkern/complex/_parallel.h	/^		typedef void (Object::*_Fn)(void *, void *, void *);$/;"	t	class:molkern::Parall_
_Forcefield	include/molkern/complex/_archetype.h	/^		typedef Forcefield_<FORCEFIELD_AMBER_>  _Forcefield;$/;"	t	class:molkern::Archetype_
_Forcefield	include/molkern/complex/_complex.h	/^		typedef Forcefield_<FORCEFIELD_TYPE>                _Forcefield;$/;"	t	class:molkern::Complex_
_GE	include/prgkern/_assert.h	66;"	d
_GEOM_TOOL__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_geom_tool.h	2;"	d
_GRAPH___0077A726_E6E3_58a1_C16D_CE436AB90501__H	include/prgkern/_graph.h	21;"	d
_GT	include/prgkern/_assert.h	63;"	d
_GridAtom	include/molkern/complex/_linkcell.h	/^		typedef typename _Region::value_type      _GridAtom;$/;"	t	class:molkern::_Link_cell
_GridAtom	include/molkern/complex/_verlet.h	/^		typedef typename _Region::value_type      _GridAtom;$/;"	t	class:molkern::_Verlet_table
_Hierarchy	include/molkern/forcefield/_residue_amber.h	/^		} _Hierarchy;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon6
_I2T	include/prgkern/_type.h	29;"	d
_INDEX__0077A726_7DF9_5da9_5082_D74308840100__H	include/prgkern/_index.h	21;"	d
_INTERACTION__F9ED1116_D4D6_5cf5_C20E_AC432B290700__H	include/molkern/forcefield/_interactions.h	2;"	d
_ITERATOR__F9ED1116_5C6E_5fd6_C36C_114687FB0400__H	include/prgkern/_iterator.h	21;"	d
_Index	include/molkern/complex/_linkcell.h	/^		typedef typename _Region::index_type      _Index;$/;"	t	class:molkern::_Link_cell
_Index	include/molkern/complex/_region.h	/^		typedef _Base::_Index                 _Index;$/;"	t	class:molkern::Node_
_Index	include/molkern/complex/_region.h	/^		typedef index_<3, unsigned>  _Index;$/;"	t	class:molkern::Node_
_Index	include/molkern/complex/_region.h	/^		typedef index_<3, unsigned>  _Index;$/;"	t	class:molkern::Region_
_Index	include/molkern/complex/_verlet.h	/^		typedef typename _Region::index_type      _Index;$/;"	t	class:molkern::_Verlet_table
_Index	include/molkern/forcefield/_residue.h	/^		typedef typename _ParamT::index_type  _Index;$/;"	t	class:molkern::basic_residue_
_Index	include/prgkern/_dense.h	/^		typedef index_<N, unsigned>             _Index;$/;"	t	class:prgkern::basic_dense_
_Index	include/prgkern/_index.h	/^		typedef index_<N, int>  _Index;$/;"	t	class:prgkern::index_cast_
_Index	include/prgkern/_index.h	/^		typedef typename _Base::_Index   _Index;$/;"	t	class:prgkern::cycle_index_cast
_Index	include/prgkern/_mesh.h	/^		typedef index_<N, int>       _Index; \/\/\/< многомерный индекс точки$/;"	t	class:prgkern::Mesh_
_Index	include/prgkern/_stencil.h	/^		typedef index_<3, int>  _Index;$/;"	t	class:prgkern::Stencil_
_Index1	include/prgkern/_index.h	/^		typedef index_<1, int>  _Index1;$/;"	t	class:prgkern::index_cast_
_Index1	include/prgkern/_index.h	/^		typedef typename _Base::_Index1  _Index1;$/;"	t	class:prgkern::cycle_index_cast
_Index2	include/prgkern/_index.h	/^		typedef index_<2, int>  _Index2;$/;"	t	class:prgkern::index_cast_
_Index2	include/prgkern/_index.h	/^		typedef typename _Base::_Index2  _Index2;$/;"	t	class:prgkern::cycle_index_cast
_Index2	include/prgkern/_mesh.h	/^		typedef index_<2, int>       _Index2;$/;"	t	class:prgkern::Mesh_
_Index3	include/prgkern/_index.h	/^		typedef index_<3, int>  _Index3;$/;"	t	class:prgkern::index_cast_
_Index3	include/prgkern/_index.h	/^		typedef typename _Base::_Index3  _Index3;$/;"	t	class:prgkern::cycle_index_cast
_Index3	include/prgkern/_mesh.h	/^		typedef index_<3, int>       _Index3;$/;"	t	class:prgkern::Mesh_
_Index4	include/prgkern/_mesh.h	/^		typedef index_<4, int>       _Index4;$/;"	t	class:prgkern::Mesh_
_IndexA	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamA::index_type _IndexA;$/;"	t	class:molkern::__Forcefield
_IndexB	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamB::index_type _IndexB;$/;"	t	class:molkern::__Forcefield
_IndexD	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamD::index_type _IndexD;$/;"	t	class:molkern::__Forcefield
_IndexE	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamE::index_type _IndexE;$/;"	t	class:molkern::__Forcefield
_IndexS	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamS::index_type _IndexS;$/;"	t	class:molkern::__Forcefield
_IndexT	include/molkern/forcefield/_forcefield.h	/^		typedef typename _ParamT::index_type _IndexT;$/;"	t	class:molkern::__Forcefield
_Interaction	include/molkern/complex/_archetype.h	/^		typedef Interaction                     _Interaction;$/;"	t	class:molkern::Archetype_
_Interaction	include/molkern/complex/_complex.h	/^		typedef Interaction                                 _Interaction;$/;"	t	class:molkern::Complex_
_Interaction	include/molkern/complex/_linkcell.h	/^		typedef Interaction                       _Interaction;$/;"	t	class:molkern::_Link_cell
_Interaction	include/molkern/complex/_verlet.h	/^		typedef Interaction                       _Interaction;$/;"	t	class:molkern::_Verlet_table
_Key	include/molkern/complex/_linkcell.h	/^		typedef typename _Region::key_type        _Key;$/;"	t	class:molkern::_Link_cell
_Key	include/molkern/complex/_region.h	/^		typedef index_<3, int>       _Key;$/;"	t	class:molkern::Node_
_Key	include/molkern/complex/_region.h	/^		typedef index_<3, int>       _Key;$/;"	t	class:molkern::Region_
_Key	include/molkern/complex/_verlet.h	/^		typedef typename _Region::key_type        _Key;$/;"	t	class:molkern::_Verlet_table
_LCell	include/molkern/complex/_complex.h	/^		typedef _Link_cell<Complex_>                        _LCell;$/;"	t	class:molkern::Complex_
_LE	include/prgkern/_assert.h	72;"	d
_LJAtom	include/molkern/complex/_complex.h	/^			_LJAtom() : X(0.f), charge(0.f), sigma(1.f), eps(0.f),$/;"	f	struct:molkern::Complex_::_LJAtom
_LJAtom	include/molkern/complex/_complex.h	/^		struct _LJAtom$/;"	s	class:molkern::Complex_
_LJAtom	include/molkern/complex/_linkcell.h	/^		typedef __LJAtom<vreal_t, vint_t>         _LJAtom;$/;"	t	class:molkern::_Link_cell
_LJAtom	include/molkern/complex/_verlet.h	/^		typedef __LJAtom<vreal_t, vint_t>         _LJAtom;$/;"	t	class:molkern::_Verlet_table
_LT	include/prgkern/_assert.h	69;"	d
_Link_cell	include/molkern/complex/_linkcell.h	/^		_Link_cell(_LPComplex *complex) : complex_(complex), region_(complex->get(REGION))$/;"	f	class:molkern::_Link_cell
_Link_cell	include/molkern/complex/_linkcell.h	/^	class _Link_cell : public near_range_integrator<_LPComplex>$/;"	c	namespace:molkern
_M	include/prgkern/_m3x3dense.h	315;"	d
_M	include/prgkern/_m3x3dense.h	320;"	d
_M3X3DENSE___0077A726_ABC2_5180_A573_CE435B530E00__H	include/prgkern/_m3x3dense.h	21;"	d
_MATH__0077A726_728A_56f7_9465_CE437EC80000__H	include/prgkern/_math.h	21;"	d
_MDENSE___0077A726_2963_5882_057A_CE43D46B0000__H	include/prgkern/_mdense.h	21;"	d
_MDYNAMICS__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_mdynamics.h	2;"	d
_MD_TOOL__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_charge_dynamics.h	2;"	d
_MESH__0077A726_56A4_5b9b_E3D3_D1451DA80101__H	include/prgkern/_mesh.h	21;"	d
_MINIMIZE__0077A726_478A_5b23_91D7_D9448B790B00__H	include/prgkern/_minimize.h	21;"	d
_MM_SET_ROUNDING_MODE	include/prgkern/_sse.h	471;"	d
_MOLECULE__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_molecule.h	2;"	d
_MSG	include/prgkern/_debug.h	25;"	d
_MSG1	include/prgkern/_debug.h	27;"	d
_MSG2	include/prgkern/_debug.h	30;"	d
_MSG3	include/prgkern/_debug.h	34;"	d
_MSG4	include/prgkern/_debug.h	39;"	d
_MSG5	include/prgkern/_debug.h	45;"	d
_Molecule	include/molkern/complex/_complex.h	/^		typedef Molecule_<_Archetype>                       _Molecule;$/;"	t	class:molkern::Complex_
_N	include/prgkern/_vdense.h	152;"	d
_N	include/prgkern/_vdense.h	36;"	d
_NE	include/prgkern/_assert.h	60;"	d
_NUCLEAR__0077A726_CBE6_5c54_73A2_F9434C9C0000__H	include/molkern/forcefield/_nuclear.h	2;"	d
_Name	include/molkern/forcefield/_residue_amber.h	/^		typedef std::string _Name; \/\/ used$/;"	t	struct:molkern::Params
_Node	include/molkern/complex/_complex.h	/^		typedef typename _Region::node_type                 _Node;$/;"	t	class:molkern::Complex_
_Node	include/molkern/complex/_linkcell.h	/^		typedef typename _Region::node_type       _Node;$/;"	t	class:molkern::_Link_cell
_Node	include/molkern/complex/_region.h	/^		typedef Node_<3, S>          _Node;$/;"	t	class:molkern::Region_
_Node	include/molkern/complex/_verlet.h	/^		typedef typename _Region::node_type       _Node;$/;"	t	class:molkern::_Verlet_table
_OPTIMIZER_LBFGS_0077A726_0C5C_5a4e_DCD8_D144196A0C00__H	include/prgkern/_minimize_lbfgs.h	2;"	d
_OPTIMIZER_ROUND_0077A726_0C5C_5a4e_DCD8_D144196A0C01__H	include/prgkern/_minimize_round.h	2;"	d
_OPTIMIZE__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_optimize.h	2;"	d
_OS__1C505E08_33B0_4526_8B7F_E892B34B0A53__H	include/prgkern/_os.h	21;"	d
_PARALLEL__09ED1116_C3FE_55a4_CA63_F84536C80D11__H	include/molkern/complex/_parallel.h	2;"	d
_PHYS_TOOL__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_phys_tool.h	2;"	d
_POTENTIAL__0077A726_C0DA_57a5_2C2E_29442B440B00__H	include/molkern/forcefield/_potential.h	2;"	d
_PREPROCESSOR__0077A726_7A2B_5be2_F165_CE43ECC00900__H	include/prgkern/_pproc.h	21;"	d
_PRGCONFIG___0077A726_E6E3_58a1_C16D_CE436AB90500__H	include/prgkern/_prgconfig.h	21;"	d
_PROTONIZATION__0077A726_81CC_5dce_36BD_A3453EED0200__H	include/molkern/complex/_protonization.h	2;"	d
_Pair	include/molkern/complex/_complex.h	/^		typedef std::pair<unsigned, unsigned>               _Pair;$/;"	t	class:molkern::Complex_
_Pair	include/molkern/complex/_region.h	/^		typedef std::pair<unsigned, real_t>  _Pair;$/;"	t	struct:molkern::Gonnet_vector
_Pair	include/molkern/complex/_thermostat.h	/^		typedef std::pair<unsigned, _Distribution>  _Pair;$/;"	t	class:molkern::maxwell_distribution_ensemble_
_Pair	include/molkern/forcefield/_residue.h	/^		typedef std::pair<_Index, _ParamT>    _Pair;$/;"	t	class:molkern::basic_residue_
_Pair14	include/molkern/complex/_archetype.h	/^		typedef index_<2>                       _Pair14;$/;"	t	class:molkern::Archetype_
_PairA	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexA, _ParamA> _PairA;$/;"	t	class:molkern::__Forcefield
_PairB	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexB, _ParamB> _PairB;$/;"	t	class:molkern::__Forcefield
_PairD	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexD, _ParamD> _PairD;$/;"	t	class:molkern::__Forcefield
_PairE	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexE, _ParamE> _PairE;$/;"	t	class:molkern::__Forcefield
_PairS	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexS, _ParamS> _PairS;$/;"	t	class:molkern::__Forcefield
_PairT	include/molkern/forcefield/_forcefield.h	/^		typedef std::pair<_IndexT, _ParamT> _PairT;$/;"	t	class:molkern::__Forcefield
_Parall	include/molkern/complex/_linkcell.h	/^		typedef Parall_<_Link_cell>               _Parall;$/;"	t	class:molkern::_Link_cell
_Parall	include/molkern/complex/_verlet.h	/^		typedef Parall_<_Verlet_table>            _Parall;$/;"	t	class:molkern::_Verlet_table
_Param	include/molkern/forcefield/_residue_amber.h	/^		typedef Params<RESIDUE_, RESIDOME_AMBER_>  _Param;$/;"	t	class:molkern::Residue_
_ParamA	include/molkern/forcefield/_forcefield.h	/^		typedef Params<ANGLE_,   FORCEFIELD_TYPE> _ParamA; \/\/ params of Angles$/;"	t	class:molkern::__Forcefield
_ParamB	include/molkern/forcefield/_forcefield.h	/^		typedef Params<BOND_,    FORCEFIELD_TYPE> _ParamB; \/\/ params of Bonds$/;"	t	class:molkern::__Forcefield
_ParamD	include/molkern/forcefield/_forcefield.h	/^		typedef Params<TORSION_, FORCEFIELD_TYPE> _ParamD; \/\/ params of torsions (Dihedrals)$/;"	t	class:molkern::__Forcefield
_ParamE	include/molkern/forcefield/_forcefield.h	/^		typedef Params<EQUI_,    FORCEFIELD_TYPE> _ParamE; \/\/ params of Equivalents$/;"	t	class:molkern::__Forcefield
_ParamS	include/molkern/forcefield/_forcefield.h	/^		typedef Params<NUCLEAR_, FORCEFIELD_TYPE> _ParamS; \/\/ params of nuclear Symbols$/;"	t	class:molkern::__Forcefield
_ParamT	include/molkern/forcefield/_forcefield.h	/^		typedef Params<ATOM_,    FORCEFIELD_TYPE> _ParamT; \/\/ params of aToms$/;"	t	class:molkern::__Forcefield
_ParamT	include/molkern/forcefield/_residue.h	/^		typedef __ResidueAtomdata             _ParamT;$/;"	t	class:molkern::basic_residue_
_Point	include/prgkern/_mesh.h	/^		typedef vdense_<N, _Real>    _Point; \/\/\/< координаты точки$/;"	t	class:prgkern::Mesh_
_Point2	include/prgkern/_mesh.h	/^		typedef vdense_<2, _Real>    _Point2;$/;"	t	class:prgkern::Mesh_
_Point3	include/prgkern/_mesh.h	/^		typedef vdense_<3, _Real>    _Point3;$/;"	t	class:prgkern::Mesh_
_Point4	include/prgkern/_mesh.h	/^		typedef vdense_<4, _Real>    _Point4;$/;"	t	class:prgkern::Mesh_
_Position	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Position;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon7
_RANDOM__F9ED1116_22BE_5068_B247_C1442B540601__H	include/prgkern/_random.h	21;"	d
_REGEX__0077A726_56A4_5b9b_E3D3_D1451DA80100__H	include/prgkern/_regex.h	21;"	d
_REGION__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_region.h	2;"	d
_RESIDOME_AMBER__F9ED1116_EFB9_53a5_11E1_EA4512720100__H	include/molkern/forcefield/_residome_amber.h	2;"	d
_RESIDOME__F9ED1116_2CEA_59cc_BFDF_EA45A58E0100__H	include/molkern/forcefield/_residome.h	2;"	d
_RESIDUE_AMBER__F9ED1116_23AF_57d7_F2EA_EA45CD1D0B00__H	include/molkern/forcefield/_residue_amber.h	2;"	d
_RESIDUE__F9ED1116_412E_59a7_5CEB_EA459CD20E00__H	include/molkern/forcefield/_residue.h	2;"	d
_ROTAMER__F9ED1116_DBE3_5136_EADB_F745B2F10101__H	include/molkern/forcefield/_rotamer.h	2;"	d
_ROTATOR__BFC42EF6_195A_5a1e_6CF1_6F41AEE10300__H	include/prgkern/_rotator.h	21;"	d
_Region	include/molkern/complex/_complex.h	/^		typedef Region_<3, _LJAtom>                         _Region;$/;"	t	class:molkern::Complex_
_Region	include/molkern/complex/_linkcell.h	/^		typedef typename _LPComplex::region_type  _Region;$/;"	t	class:molkern::_Link_cell
_Region	include/molkern/complex/_verlet.h	/^		typedef typename _LPComplex::region_type  _Region;$/;"	t	class:molkern::_Verlet_table
_Residata	include/molkern/forcefield/_residome_amber.h	/^		typedef Params<RESIDUE_, RESIDOME_AMBER_>  _Residata;$/;"	t	class:molkern::Residome_
_Residome	include/molkern/complex/_archetype.h	/^		typedef Residome_  <RESIDOME_AMBER_>    _Residome;$/;"	t	class:molkern::Archetype_
_Residome	include/molkern/complex/_complex.h	/^		typedef Residome_<RESIDOME_TYPE>                    _Residome;$/;"	t	class:molkern::Complex_
_Residue	include/molkern/complex/_archetype.h	/^		typedef _Residome::residue_type         _Residue;$/;"	t	class:molkern::Archetype_
_Residue	include/molkern/forcefield/_residome.h	/^		typedef Residue_<RESIDOME_TYPE> _Residue;$/;"	t	class:molkern::basic_residome_
_Residue	include/molkern/forcefield/_residue_amber.h	/^		} _Residue;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon9
_Residueconnect	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon8
_Rotamer	include/molkern/complex/_archetype.h	/^		typedef Rotamer_                        _Rotamer;$/;"	t	class:molkern::Archetype_
_Rotamer	include/molkern/complex/_complex.h	/^		typedef typename _Archetype::rotamer_type           _Rotamer;$/;"	t	class:molkern::Complex_
_Rotamer	include/molkern/complex/_molecule.h	/^		typedef typename _Archetype::rotamer_type   _Rotamer;$/;"	t	class:molkern::Molecule_
_Rotamer	include/molkern/forcefield/_residue.h	/^		} _Rotamer;$/;"	t	class:molkern::basic_residue_	typeref:struct:molkern::basic_residue_::Rotamer_
_Rotamer	include/molkern/forcefield/_residue_amber.h	/^		} _Rotamer;$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon2
_S	include/prgkern/_string.h	42;"	d
_S	include/prgkern/_string.h	43;"	d
_SSE___0077A726_E6E3_58a1_C16D_CE436AB90502__H	include/prgkern/_sse.h	21;"	d
_STENCIL__0077A726_2C84_57b4_2A66_CE43B6700100__H	include/prgkern/_stencil.h	21;"	d
_Short	include/molkern/forcefield/_residome_amber.h	/^		struct _Short$/;"	s	namespace:molkern::amber
_Solventcap	include/molkern/forcefield/_residue_amber.h	/^		typedef real_t _Solventcap; \/\/ don't used$/;"	t	struct:molkern::Params
_Stick	include/molkern/complex/_molecule.h	/^		typedef typename _Rotamer::stick_type       _Stick;$/;"	t	class:molkern::Molecule_
_Stick	include/molkern/forcefield/_rotamer.h	/^		typedef index_<3> _Stick;$/;"	t	class:molkern::Rotamer_
_T	include/prgkern/_mdense.h	159;"	d
_T	include/prgkern/_mdense.h	32;"	d
_THERMOSTAT__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/complex/_thermostat.h	2;"	d
_TIME__0077A726_0EE7_5e96_7E5A_CE432FBA0800__H	include/prgkern/_time.h	21;"	d
_TORSION__F9ED1116_EDB9_5e17_25FF_F745B15D0100__H	include/molkern/forcefield/_torsion.h	2;"	d
_TRANSFORMS__0077A726_E6E3_58a1_C16D_CE436AB90500__H	include/prgkern/_transforms.h	21;"	d
_TYPE__0077A726_AC88_55c0_4A44_CE4344760600__H	include/prgkern/_type.h	21;"	d
_Torsion	include/molkern/complex/_archetype.h	/^		typedef Torsion_<FORCEFIELD_AMBER_>     _Torsion;$/;"	t	class:molkern::Archetype_
_USE_MATH_DEFINES	include/prgkern/_prgconfig.h	24;"	d
_V3DENSE___0077A726_E6E3_58a1_C16D_CE436AB90500__H	include/prgkern/_v3dense.h	21;"	d
_VAL	include/prgkern/_debug.h	52;"	d
_VAL1	include/prgkern/_debug.h	55;"	d
_VAL2	include/prgkern/_debug.h	58;"	d
_VAL3	include/prgkern/_debug.h	62;"	d
_VAL4	include/prgkern/_debug.h	67;"	d
_VAL5	include/prgkern/_debug.h	73;"	d
_VDENSE___0077A726_9715_5da8_D372_CE433D550D00__H	include/prgkern/_vdense.h	21;"	d
_Value	include/prgkern/_dense.h	/^		typedef T                               _Value;$/;"	t	class:prgkern::basic_dense_
_Vector	include/prgkern/_box.h	/^		typedef vdense_<N, T>  _Vector;$/;"	t	class:prgkern::Box_
_Vector	include/prgkern/_minimize_lbfgs.h	/^		typedef std::vector<_Real>                      _Vector;$/;"	t	class:prgkern::Updater
_Vector3	include/prgkern/_stencil.h	/^		typedef vdense_<3, T>   _Vector3;$/;"	t	class:prgkern::Stencil_
_VectorA	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairA> _VectorA;$/;"	t	class:molkern::__Forcefield
_VectorB	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairB> _VectorB;$/;"	t	class:molkern::__Forcefield
_VectorD	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairD> _VectorD;$/;"	t	class:molkern::__Forcefield
_VectorE	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairE> _VectorE;$/;"	t	class:molkern::__Forcefield
_VectorR	include/molkern/forcefield/_residome.h	/^		typedef std::vector<_Residue>   _VectorR;$/;"	t	class:molkern::basic_residome_
_VectorR	include/molkern/forcefield/_residome_amber.h	/^		typedef std::vector<_Residata>             _VectorR;$/;"	t	class:molkern::Residome_
_VectorS	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairS> _VectorS;$/;"	t	class:molkern::__Forcefield
_VectorT	include/molkern/forcefield/_forcefield.h	/^		typedef std::vector<_PairT> _VectorT;$/;"	t	class:molkern::__Forcefield
_VectorT	include/molkern/forcefield/_residue.h	/^		typedef std::vector<_Pair>            _VectorT;$/;"	t	class:molkern::basic_residue_
_Velocity	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Velocity; \/\/ don't used$/;"	t	struct:molkern::Params	typeref:struct:molkern::Params::__anon10
_Verlet	include/molkern/complex/_complex.h	/^		typedef _Verlet_table<Complex_>                     _Verlet;$/;"	t	class:molkern::Complex_
_Verlet_table	include/molkern/complex/_verlet.h	/^		_Verlet_table(_LPComplex *complex) : complex_(complex) { parall_.init(this); }$/;"	f	class:molkern::_Verlet_table
_Verlet_table	include/molkern/complex/_verlet.h	/^	class _Verlet_table : public near_range_integrator<_LPComplex>$/;"	c	namespace:molkern
__EQ_000	include/prgkern/_stencil.h	173;"	d
__EQ_000	include/prgkern/_stencil.h	349;"	d
__EQ_x00	include/prgkern/_stencil.h	165;"	d
__EQ_x00	include/prgkern/_stencil.h	345;"	d
__EQ_x00	include/prgkern/_stencil.h	348;"	d
__EQ_xx0	include/prgkern/_stencil.h	151;"	d
__EQ_xx0	include/prgkern/_stencil.h	342;"	d
__EQ_xx0	include/prgkern/_stencil.h	347;"	d
__EQ_xxx	include/prgkern/_stencil.h	115;"	d
__EQ_xxx	include/prgkern/_stencil.h	340;"	d
__EQ_xxx	include/prgkern/_stencil.h	346;"	d
__EQ_xxz	include/prgkern/_stencil.h	341;"	d
__EQ_xxz	include/prgkern/_stencil.h	343;"	d
__EQ_xxz	include/prgkern/_stencil.h	89;"	d
__EQ_xy0	include/prgkern/_stencil.h	125;"	d
__EQ_xy0	include/prgkern/_stencil.h	344;"	d
__EQ_xyz	include/prgkern/_stencil.h	39;"	d
__Forcefield	include/molkern/forcefield/_forcefield.h	/^		__Forcefield() {}$/;"	f	class:molkern::__Forcefield
__Forcefield	include/molkern/forcefield/_forcefield.h	/^	class __Forcefield$/;"	c	namespace:molkern
__LJAtom	include/molkern/complex/_region.h	/^	struct __LJAtom$/;"	s	namespace:molkern
__LOCATE__	include/prgkern/_string.h	48;"	d
__LOCATE__	include/prgkern/_string.h	49;"	d
__ResidueAtomdata	include/molkern/forcefield/_residue.h	/^	struct __ResidueAtomdata$/;"	s	namespace:molkern
__STRING	include/prgkern/_string.h	45;"	d
__STRING	include/prgkern/_string.h	46;"	d
__STRING__FC42EF6_3B55_5d9a_1B59_514158A70601__H	include/prgkern/_string.h	21;"	d
__V	include/prgkern/_stencil.h	519;"	d
__V	include/prgkern/_stencil.h	524;"	d
_assign	include/prgkern/_v3dense.h	43;"	d
_base	include/prgkern/_os.h	/^		typedef fs::directory_iterator _base;$/;"	t	class:prgkern::directory_iterator
_choose	include/prgkern/_v3dense.h	151;"	d
_piece	include/prgkern/_iterator.h	/^		typedef std::pair<T *, unsigned>   _piece;$/;"	t	class:prgkern::piecewise_vector
abovetype	include/molkern/forcefield/_residue_amber.h	/^			std::string abovetype;$/;"	m	struct:molkern::Params::__anon6
abovex	include/molkern/forcefield/_residue_amber.h	/^			int abovex;$/;"	m	struct:molkern::Params::__anon6
abs	include/prgkern/_math.h	/^	template <typename T> INLINE T abs(T a) { return a >= 0 ? a : -a; }$/;"	f	namespace:prgkern
abs	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> abs(vecint_<1, int> a)$/;"	f	namespace:prgkern
abs	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> abs(vecint_<4, int> a) { vecbool_<4, int> f = (a < 0); return _mm_sub_epi32(_mm_xor_si128(f, a), f); }$/;"	f	namespace:prgkern
abs	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> abs(vecint_<4, int> a)$/;"	f	namespace:prgkern
abs	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> abs(vecint_<4, int> a, vecbool_<4, int> less_zero)$/;"	f	namespace:prgkern
accumulate_count	include/prgkern/_time.h	/^		static long unsigned accumulate_count[NT + 1];$/;"	m	class:prgkern::function_timer_t
accumulate_count	include/prgkern/_time.h	/^	template <int N, unsigned NT> long unsigned function_timer_t<N, NT>::accumulate_count[NT + 1];$/;"	m	class:prgkern::function_timer_t
accumulate_time	include/prgkern/_time.h	/^		static double accumulate_time[NT + 1];$/;"	m	class:prgkern::function_timer_t
accumulate_time	include/prgkern/_time.h	/^	template <int N, unsigned NT> double function_timer_t<N, NT>::accumulate_time[NT + 1];$/;"	m	class:prgkern::function_timer_t
all_pieces_	include/prgkern/_iterator.h	/^		std::vector<_piece> all_pieces_;$/;"	m	class:prgkern::piecewise_vector
alpha	include/molkern/forcefield/_potential.h	/^		_Real alpha() const { return alpha_; }$/;"	f	class:molkern::Potential
alpha_	include/molkern/forcefield/_interactions.h	/^		static real_t alpha_; \/\/ параметр, связанный с радиусом разделения потенциала на ближнюю и дальнюю части$/;"	m	struct:molkern::Interaction_
alpha_	include/molkern/forcefield/_interactions.h	/^		static real_t alpha_; \/\/\/< значение vdw псевдопотенциала в 0 (в единицах eps)$/;"	m	struct:molkern::Interaction_
alpha_	include/molkern/forcefield/_potential.h	/^		_Real alpha_; \/\/\/< параметр, связанный с радиусом разделения потенциала $/;"	m	class:molkern::Potential
alpha_	src/__moldefs.cpp	/^	real_t Interaction_<C612>::alpha_;$/;"	m	class:molkern::Interaction_	file:
alpha_	src/__moldefs.cpp	/^	real_t Interaction_<E612>::alpha_;$/;"	m	class:molkern::Interaction_	file:
altloc	include/molkern/forcefield/_atomdata.h	/^		char altloc;$/;"	m	struct:molkern::Atomdata_
altpos	include/molkern/__config.h	/^		char altpos; \/\/ идентификатор альтернативной загрузки$/;"	m	struct:molkern::Descriptor_
am_matrix_	include/molkern/complex/_complex.h	/^		std::vector<std::vector<int> > am_matrix_;$/;"	m	class:molkern::Complex_
amber	include/molkern/forcefield/_residome_amber.h	/^	namespace amber$/;"	n	namespace:molkern
amino_acid_name	include/molkern/forcefield/_residue.h	/^	const AminoAcidName amino_acid_name[] =$/;"	m	namespace:molkern
andnot	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> andnot(vecbool_<1, int> a, vecbool_<1, int> b) { return (!a) && b; }$/;"	f	namespace:prgkern
andnot	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> andnot(vecbool_<4, int> a, vecbool_<4, int> b) { return (!a) && b; }$/;"	f	namespace:prgkern
andnot	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> andnot(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_andnot_ps(a, b)); }$/;"	f	namespace:prgkern
angl_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorA angl_params_;$/;"	m	class:molkern::__Forcefield
angle	include/molkern/forcefield/_residue_amber.h	/^			real_t angle;$/;"	m	struct:molkern::Params::__anon4
angle_type	include/molkern/complex/_archetype.h	/^		typedef _Angle        angle_type;$/;"	t	class:molkern::Archetype_
angles_	include/molkern/complex/_archetype.h	/^		std::vector<_Angle>     angles_;    \/\/ все валентные углы молекулы$/;"	m	class:molkern::Archetype_
archetype_	include/molkern/complex/_molecule.h	/^		const _Archetype *archetype_; \/\/ прототип молекулы$/;"	m	class:molkern::Molecule_
archetype_type	include/molkern/complex/_complex.h	/^		typedef _Archetype      archetype_type;$/;"	t	class:molkern::Complex_
archetypes_	include/molkern/complex/_complex.h	/^		std::vector<_Archetype*> archetypes_; \/\/ указатели на типы молекул комплекса$/;"	m	class:molkern::Complex_
array_iterator	include/prgkern/_iterator.h	/^		array_iterator() : it_(), v_(0) {}$/;"	f	class:prgkern::array_iterator
array_iterator	include/prgkern/_iterator.h	/^		array_iterator(S *v, const Iterator &it) : it_(it), v_(v) {}$/;"	f	class:prgkern::array_iterator
array_iterator	include/prgkern/_iterator.h	/^		array_iterator(const array_iterator &it) : it_(it.it_), v_(it.v_) {}$/;"	f	class:prgkern::array_iterator
array_iterator	include/prgkern/_iterator.h	/^	class array_iterator$/;"	c	namespace:prgkern
atom	include/molkern/forcefield/_residue.h	/^			std::vector<fstring> atom;$/;"	m	struct:molkern::basic_residue_::Rotamer_
atom	include/molkern/forcefield/_residue_amber.h	/^			std::vector<fstring> atom;  \/\/ вращаемые атомы$/;"	m	struct:molkern::Params::__anon2
atom1x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int atom1x, atom2x, flags; } _Bond;$/;"	m	struct:molkern::Params::__anon5
atom2x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int atom1x, atom2x, flags; } _Bond;$/;"	m	struct:molkern::Params::__anon5
atom_moment	include/molkern/forcefield/_rotamer.h	/^	INLINE real_t atom_moment(const vector_t &W, const vector_t &O, const vector_t &F,$/;"	f	namespace:molkern
atom_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorT atom_params_;$/;"	m	class:molkern::__Forcefield
atom_start_	include/molkern/complex/_complex.h	/^		std::vector<unsigned> atom_start_;  \/\/ стартовые номера атомов молекул в массиве атомов$/;"	m	class:molkern::Complex_
atom_type	include/molkern/complex/_archetype.h	/^		typedef _Atomdata     atom_type;$/;"	t	class:molkern::Archetype_
atom_type	include/molkern/complex/_complex.h	/^		typedef _Atom           atom_type;$/;"	t	class:molkern::Complex_
atom_type	include/molkern/forcefield/_residue.h	/^		typedef __ResidueAtomdata atom_type;$/;"	t	class:molkern::basic_residue_
atomdata	include/molkern/complex/_complex.h	/^			const _Atomdata *atomdata; \/\/\/< ссылка на основные параметры атома$/;"	m	struct:molkern::Complex_::_Atom
atomdata_	include/molkern/complex/_archetype.h	/^		std::vector<_Atomdata>  atomdata_;  \/\/ первоначально загруженные атомы$/;"	m	class:molkern::Archetype_
atomdata_type	include/molkern/complex/_archetype.h	/^		typedef _Atomdata     atomdata_type;$/;"	t	class:molkern::Archetype_
atomnum	include/molkern/forcefield/_residue_amber.h	/^			int atomnum; \/\/ число вращаемых атомов$/;"	m	struct:molkern::Params::__anon2
atoms	include/molkern/forcefield/_residue_amber.h	/^		std::vector<_Atom> atoms;$/;"	m	struct:molkern::Params
atoms_	include/molkern/complex/_complex.h	/^		std::vector<_Atom> atoms_; \/\/ все атомы комплекса$/;"	m	class:molkern::Complex_
average	include/molkern/complex/_linkcell.h	/^		real_t average(_I2T<RSKIN_>) const { return rcut_; }$/;"	f	class:molkern::_Link_cell
average	include/molkern/complex/_verlet.h	/^		real_t average(_I2T<RSKIN_>) const { return rskin_average_; }$/;"	f	class:molkern::_Verlet_table
axis	include/molkern/forcefield/_residue.h	/^			std::pair<fstring, fstring> axis;$/;"	m	struct:molkern::basic_residue_::Rotamer_
axis	include/molkern/forcefield/_residue_amber.h	/^			std::pair<fstring, fstring> axis; \/\/ атомы оси$/;"	m	struct:molkern::Params::__anon2
b_	include/prgkern/_index.h	/^		_Index b_; \/\/\/< нижняя граница области (по умалчиванию 0)$/;"	m	class:prgkern::index_cast_
b_	include/prgkern/_sse.h	/^		__m128 b_;$/;"	m	class:prgkern::vecbool_
ba	include/prgkern/_string.h	234;"	d
ba	include/prgkern/_string.h	26;"	d
barrier	include/molkern/__config.h	/^		real_t barrier; \/\/ высота барьера в 0 для 6-12 псевдопотенциала$/;"	m	class:molkern::Configure
basename	include/prgkern/_os.h	/^	INLINE std::string basename(const std::string &s)$/;"	f	namespace:prgkern
basic_dense_	include/prgkern/_dense.h	/^		basic_dense_() {}$/;"	f	class:prgkern::basic_dense_
basic_dense_	include/prgkern/_dense.h	/^	class basic_dense_ : public std::vector<T>$/;"	c	namespace:prgkern
basic_residome_	include/molkern/forcefield/_residome.h	/^		basic_residome_() {}$/;"	f	class:molkern::basic_residome_
basic_residome_	include/molkern/forcefield/_residome.h	/^	class basic_residome_$/;"	c	namespace:molkern
basic_residue_	include/molkern/forcefield/_residue.h	/^		basic_residue_() : name("UNK"), has_connects_(false),$/;"	f	class:molkern::basic_residue_
basic_residue_	include/molkern/forcefield/_residue.h	/^	class basic_residue_$/;"	c	namespace:molkern
basic_residue_name	include/molkern/forcefield/_residome_amber.h	/^		const fstring basic_residue_name[] =$/;"	m	namespace:molkern::amber
begin	include/molkern/complex/_region.h	/^		const_iterator begin(unsigned i=0) const { return items_[i].begin(); }$/;"	f	class:molkern::Node_
begin	include/molkern/complex/_region.h	/^		iterator begin(unsigned i=0) { return items_[i].begin(); }$/;"	f	class:molkern::Node_
begin	include/molkern/forcefield/_forcefield.h	/^		typename _VectorT::const_iterator begin(_PairT *) const { return atom_params_.begin(); }$/;"	f	class:molkern::__Forcefield
begin	include/prgkern/_iterator.h	/^		iterator begin()$/;"	f	class:prgkern::piecewise_vector
belowtype	include/molkern/forcefield/_residue_amber.h	/^			std::string belowtype;$/;"	m	struct:molkern::Params::__anon6
belowx	include/molkern/forcefield/_residue_amber.h	/^			int belowx;$/;"	m	struct:molkern::Params::__anon6
bitsizeof	include/prgkern/_transforms.h	/^	INLINE unsigned bitsizeof(unsigned x)$/;"	f	namespace:prgkern
bitsizeof	include/prgkern/_transforms.h	/^	inline unsigned bitsizeof(long long x)$/;"	f	namespace:prgkern
bll	include/prgkern/_index.h	26;"	d
bll	include/prgkern/_index.h	572;"	d
bll	include/prgkern/_math.h	28;"	d
bll	include/prgkern/_math.h	713;"	d
bll	include/prgkern/_v3dense.h	34;"	d
bll	include/prgkern/_v3dense.h	534;"	d
bond_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorB bond_params_;$/;"	m	class:molkern::__Forcefield
bond_type	include/molkern/complex/_archetype.h	/^		typedef _Bond         bond_type;$/;"	t	class:molkern::Archetype_
bonds	include/molkern/forcefield/_residue_amber.h	/^		std::vector<_Bond> bonds; \/\/ bonds$/;"	m	struct:molkern::Params
bonds_	include/molkern/complex/_archetype.h	/^		std::vector<_Bond>      bonds_;     \/\/ все связи молекулы$/;"	m	class:molkern::Archetype_
bottom	include/prgkern/_box.h	/^		_Vector &bottom() { return d_; }$/;"	f	class:prgkern::Box_
bottom	include/prgkern/_box.h	/^		const _Vector &bottom() const { return d_; }$/;"	f	class:prgkern::Box_
bottom	include/prgkern/_index.h	/^		_Index bottom() const { return b_; }$/;"	f	class:prgkern::index_cast_
boundbox_	include/molkern/forcefield/_residue_amber.h	/^		_BoundBox boundbox_;$/;"	m	struct:molkern::Params
box	include/molkern/__config.h	/^		_S box; \/\/ Глобальный ящик, который задается строкой [nx,ny,nz]$/;"	m	class:molkern::Configure
box	include/molkern/forcefield/_residue.h	/^		const box_t &box() const { return box_; }$/;"	f	class:molkern::basic_residue_
box_	include/molkern/forcefield/_residue.h	/^		box_t box_;$/;"	m	class:molkern::basic_residue_
box_scale	include/molkern/__config.h	/^		real_t box_scale; \/\/ масштаб локального ящика$/;"	m	struct:molkern::Descriptor_
box_size	include/molkern/complex/_region.h	/^		index_type box_size() const { return sz_; }$/;"	f	class:molkern::Region_
box_t	include/molkern/__moldefs.h	/^	typedef prgkern::Box_<3, real_t> box_t;$/;"	t	namespace:molkern
build	include/molkern/complex/_archetype.h	/^	::build(_I2T<MOLECULE_>, int pH)$/;"	f	class:molkern::Archetype_
build	include/molkern/complex/_archetype.h	/^	::build(_I2T<WATER_>, int)$/;"	f	class:molkern::Archetype_
build	include/molkern/complex/_complex.h	/^	::build(bool enable_clash, unsigned iterations)$/;"	f	class:molkern::Complex_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<ANGLE_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<BOND_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<CHAIN_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<CONNECT_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<FORMAT_BMM_>, int)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<FORMAT_HIN_>, int)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<FORMAT_MOL2_>, int)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<FORMAT_PDB_>, int pH)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<HYDROGEN_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<PAIR14_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<RESIDUE_CONTACT_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<RESIDUE_NAME_>, int pH)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<ROTAMER_>)$/;"	f	class:molkern::Archetype_
build_	include/molkern/complex/_archetype.h	/^	::build_(_I2T<TORSION_>)$/;"	f	class:molkern::Archetype_
build_1A_1H_	include/molkern/complex/_protonization.h	/^	INLINE void build_1A_1H_(vector_t *XH, const vector_t *XA,$/;"	f	namespace:molkern
build_1A_2H_	include/molkern/complex/_protonization.h	/^	INLINE void build_1A_2H_(vector_t *XH, const vector_t *XA, const vector_t &X0,$/;"	f	namespace:molkern
build_1A_3H_	include/molkern/complex/_protonization.h	/^	INLINE void build_1A_3H_(vector_t *XH, const vector_t *XA, const vector_t &X0,$/;"	f	namespace:molkern
build_2A_1A_	include/molkern/complex/_protonization.h	/^	INLINE void build_2A_1A_(vector_t *XA, const vector_t *XS)$/;"	f	namespace:molkern
build_2A_1H_	include/molkern/complex/_protonization.h	/^	INLINE void build_2A_1H_(vector_t *XH, const vector_t *XA, const vector_t &X0,$/;"	f	namespace:molkern
build_2A_2H_	include/molkern/complex/_protonization.h	/^	INLINE void build_2A_2H_(vector_t *XH, const vector_t *XA, const vector_t &X0,$/;"	f	namespace:molkern
build_3A_1H_	include/molkern/complex/_protonization.h	/^	INLINE void build_3A_1H_(vector_t *XH, const vector_t *XA, const vector_t &X0,$/;"	f	namespace:molkern
c1__	include/molkern/forcefield/_interactions.h	/^		static const real_t c1__;$/;"	m	struct:molkern::Interaction_
c1__	src/__moldefs.cpp	/^	const real_t Interaction_<C612>::c1__ = (real_t)( 0.1132524796725085633035822270098921L);$/;"	m	class:molkern::Interaction_	file:
c1x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
c2__	include/molkern/forcefield/_interactions.h	/^		static const real_t c2__;$/;"	m	struct:molkern::Interaction_
c2__	src/__moldefs.cpp	/^	const real_t Interaction_<C612>::c2__ = (real_t)(-0.1009131954055306831946948492286285L);$/;"	m	class:molkern::Interaction_	file:
c2x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
c3x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
c4x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
c5x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
c6x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int c1x, c2x, c3x, c4x, c5x, c6x; } _Residueconnect; \/\/ don't used$/;"	m	struct:molkern::Params::__anon8
ca_	include/prgkern/_rotator.h	/^		T ca_, sa_;$/;"	m	class:prgkern::Rotator
calc_type_	include/molkern/complex/_molecule.h	/^		unsigned calc_type_; \/\/ какие энергетические вклады учитываются$/;"	m	class:molkern::Molecule_
calculate	include/molkern/complex/_charge_dynamics.h	/^	INLINE void calculate(_I2T<CHARGE1_>, _Real *Q1, unsigned incq,$/;"	f	namespace:molkern
calculate	include/molkern/complex/_geom_tool.h	/^	INLINE Box_<3, real_t> calculate(_I2T<BOX_>, const Atom *atom, Iterator it, Iterator ite)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_geom_tool.h	/^	INLINE real_t calculate(_I2T<MAX_VDW_RADIUS_>, const Atom *atom,$/;"	f	namespace:molkern
calculate	include/molkern/complex/_geom_tool.h	/^	INLINE vector_t	calculate(_I2T<GEOM_CENTER_>, const Atom *atom, Iterator it, Iterator ite)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_geom_tool.h	/^	INLINE vector_t	calculate(_I2T<MASS_CENTER_>, const Atom *atom, Iterator it, Iterator ite)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<A_DET_>, const Molecule *molecule)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<CHARGE_>, const Molecule *molecule)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<CHARGE_>, const Molecule *molecule,$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<INERTIA_TENSOR_DET_>, const Molecule *molecule)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<INERTIA_TENSOR_DET_>, const Molecule *molecule,$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<MASS_>, const Molecule *molecule)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<MASS_>, const Molecule *molecule, Iterator it, Iterator ite)$/;"	f	namespace:molkern
calculate	include/molkern/complex/_phys_tool.h	/^	calculate(_I2T<SOLID_TdS_>, const Molecule *molecule,$/;"	f	namespace:molkern
calculate_fgt	include/prgkern/_minimize.h	/^		template <typename T> void calculate_fgt(bool find_minimum, T &xu, T &fu, T &gu, SHARE_PARAM_DEF(T))$/;"	f	class:prgkern::Line_minimizer_
calculate_fgt	include/prgkern/_minimize_round.h	/^		template <typename T> void calculate_fgt(T &xu, T &fu, T &gu, SHARE_PARAM_DEF(T))$/;"	f	class:prgkern::Round_minimizer_
calculate_sigma	include/molkern/forcefield/_interactions.h	/^	INLINE T calculate_sigma(T sigma, T sigma__)$/;"	f	namespace:molkern
ceil	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> ceil(vecreal_<4, float> a)$/;"	f	namespace:prgkern
celling	include/prgkern/_math.h	/^	INLINE int celling(int x, int radix=CYCLE_EXPANSION_SIZE)$/;"	f	namespace:prgkern
center	include/prgkern/_box.h	/^		_Vector center() const { return (d_ + u_) * (T)0.5; }$/;"	f	class:prgkern::Box_
center	include/prgkern/_index.h	/^		_Index center() const { return b_ + s_ * 0.5; }$/;"	f	class:prgkern::index_cast_
chain	include/molkern/forcefield/_atomdata.h	/^		char chain;$/;"	m	struct:molkern::Atomdata_
chain_count_	include/molkern/forcefield/_residue.h	/^		unsigned chain_count_;$/;"	m	class:molkern::basic_residue_
chain_type	include/molkern/complex/_archetype.h	/^		typedef _Chain        chain_type;$/;"	t	class:molkern::Archetype_
chain_type	include/molkern/complex/_complex.h	/^		typedef _Chain          chain_type;$/;"	t	class:molkern::Complex_
chains_	include/molkern/complex/_archetype.h	/^		std::vector<_Chain >    chains_;    \/\/ идентификаторы связных цепей$/;"	m	class:molkern::Archetype_
chains_vector_	include/molkern/complex/_archetype.h	/^		std::vector<unsigned> chains_vector_; \/\/ хранилище номеров ротамеров для цепей (тот же формат)$/;"	m	class:molkern::Archetype_
charge	include/molkern/complex/_complex.h	/^			real_t charge; \/\/\/< текущий заряд атома в единицах [a.u.q] * sqrt(ELECTRIC_FACTOR)$/;"	m	struct:molkern::Complex_::_Atom
charge	include/molkern/complex/_complex.h	/^			real_t charge; \/\/\/< текущий заряд атома в единицах [a.u.q] * sqrt(ELECTRIC_FACTOR)$/;"	m	struct:molkern::Complex_::_LJAtom
charge	include/molkern/complex/_region.h	/^		T1 charge; \/\/ текущий заряд атома в единицах [a.u.q] * sqrt(ELECTRIC_FACTOR)$/;"	m	struct:molkern::__LJAtom
charge	include/molkern/forcefield/_atomdata.h	/^		real_t charge;$/;"	m	struct:molkern::Atomdata_
charge	include/molkern/forcefield/_nuclear.h	/^		int charge;$/;"	m	struct:molkern::Nuclear
charge	include/molkern/forcefield/_residue.h	/^		real_t charge; \/\/ заряд атома$/;"	m	struct:molkern::__ResidueAtomdata
chg	include/molkern/forcefield/_residue_amber.h	/^			real_t chg; \/\/ amber(and in gromacs the same) charge$/;"	m	struct:molkern::Params::__anon1
childseq	include/molkern/forcefield/_residue_amber.h	/^			int childseq;$/;"	m	struct:molkern::Params::__anon9
childsequence_type	include/molkern/forcefield/_residue_amber.h	/^		typedef int childsequence_type; \/\/ don't used$/;"	t	struct:molkern::Params
choose	include/prgkern/_v3dense.h	174;"	d
clear	include/molkern/complex/_region.h	/^		void clear() { for (unsigned i=0,sz=nodes_.size(); i<sz; i++) nodes_[i].clear(); }$/;"	f	class:molkern::Region_
clear	include/molkern/complex/_region.h	/^		void clear()$/;"	f	class:molkern::Node_
clear	include/molkern/forcefield/_residue_amber.h	/^			void clear()$/;"	f	struct:molkern::Params::__anon4
clear	include/molkern/forcefield/_residue_amber.h	/^		void clear()$/;"	f	struct:molkern::Params
clear	include/prgkern/_dense.h	/^		void clear() {$/;"	f	class:prgkern::basic_dense_
clear	include/prgkern/_index.h	/^		void clear() { ::memset(&ndx_[0], 0, sizeof(ndx_)); }$/;"	f	class:prgkern::index_
clear	include/prgkern/_m3x3dense.h	/^		void clear() { scalar_assign_equal((_I2T<N> *)0, (T)0, (T)0); }$/;"	f	class:prgkern::mdense_
clear	include/prgkern/_time.h	/^		static void clear()$/;"	f	class:prgkern::function_timer_t
clear	include/prgkern/_v3dense.h	/^		void clear() { for_<0, N>::expand(bll::_1 = T(), v_);  }$/;"	f	class:prgkern::vdense_
code_error_	include/molkern/__moldefs.h	/^	enum code_error_$/;"	g	namespace:molkern
compiled_regex_	include/prgkern/_regex.h	/^		boost::regex compiled_regex_;$/;"	m	class:prgkern::RegEx
complex_	include/molkern/complex/_linkcell.h	/^		_LPComplex *complex_; \/\/ комплекс, который обслуживает Верлет таблица$/;"	m	class:molkern::_Link_cell
complex_	include/molkern/complex/_verlet.h	/^		_LPComplex *complex_; \/\/ комплекс, который обслуживает Верлет таблица$/;"	m	class:molkern::_Verlet_table
component_product	include/prgkern/_index.h	/^	INLINE T component_product(const index_<1, T> &v) { return v[0]; }$/;"	f	namespace:prgkern
component_product	include/prgkern/_index.h	/^	INLINE T component_product(const index_<2, T> &v) { return v[0] * v[1]; }$/;"	f	namespace:prgkern
component_product	include/prgkern/_index.h	/^	INLINE T component_product(const index_<3, T> &v) { return v[0] * v[1] * v[2]; }$/;"	f	namespace:prgkern
component_product	include/prgkern/_index.h	/^	INLINE T component_product(const index_<4, T> &v)$/;"	f	namespace:prgkern
compress_	include/molkern/complex/_verlet.h	/^	::compress_(bool print)$/;"	f	class:molkern::_Verlet_table
compress_	include/molkern/complex/_verlet.h	/^	::compress_(unsigned *share, const _Region *grid, unsigned igroup)$/;"	f	class:molkern::_Verlet_table
config	include/molkern/__config.h	/^		_S config; \/\/ файл параметров конфигурации расчета$/;"	m	class:molkern::Configure
connect_	include/molkern/forcefield/_residue_amber.h	/^		_Connect connect_[2];$/;"	m	struct:molkern::Params
connect_data	include/molkern/complex/_complex.h	/^			unsigned_t connect_data; \/\/\/< таблица коннектов атома$/;"	m	struct:molkern::Complex_::_Atom
connect_data	include/molkern/complex/_complex.h	/^			unsigned_t connect_data; \/\/\/< таблица коннектов атома$/;"	m	struct:molkern::Complex_::_LJAtom
connect_data	include/molkern/complex/_region.h	/^		T2 connect_data; \/\/ таблица коннектов атома$/;"	m	struct:molkern::__LJAtom
connect_data	include/molkern/forcefield/_atomdata.h	/^		unsigned_t connect_data; \/\/ упакованная таблица коннектов от 1-1 до 1-4$/;"	m	struct:molkern::Atomdata_
const_array_iterator	include/prgkern/_iterator.h	/^		const_array_iterator() : it_(), v_(0) {}$/;"	f	class:prgkern::const_array_iterator
const_array_iterator	include/prgkern/_iterator.h	/^		const_array_iterator(const S *v, const Iterator &it) : it_(it), v_(v) {}$/;"	f	class:prgkern::const_array_iterator
const_array_iterator	include/prgkern/_iterator.h	/^		const_array_iterator(const const_array_iterator &it) : it_(it.it_), v_(it.v_) {}$/;"	f	class:prgkern::const_array_iterator
const_array_iterator	include/prgkern/_iterator.h	/^	class const_array_iterator$/;"	c	namespace:prgkern
const_iterator	include/molkern/complex/_region.h	/^		typedef typename _Node::const_iterator  const_iterator;$/;"	t	class:molkern::Region_
const_iterator	include/molkern/complex/_region.h	/^		typedef typename std::vector<S>::const_iterator  const_iterator;$/;"	t	class:molkern::Node_
const_iterator	include/prgkern/_dense.h	/^		typedef typename _Base::const_iterator  const_iterator;$/;"	t	class:prgkern::basic_dense_
copy_internal_net_	include/prgkern/_stencil.h	/^		void copy_internal_net_(T *arr, unsigned inc, const C &ndxcast,$/;"	f	class:prgkern::Stencil_
cos_	include/prgkern/_blas1.h	/^	INLINE T cos_(unsigned n, const T *v1, const T *v2)$/;"	f	namespace:prgkern
cos_angle	include/prgkern/_blas1.h	/^	INLINE T cos_angle(unsigned n, const T *a, const T *b)$/;"	f	namespace:prgkern
cos_angle	include/prgkern/_v3dense.h	/^	INLINE T cos_angle(const vdense_<N, T> &v1, const vdense_<N, T> &v2)$/;"	f	namespace:prgkern
count	include/molkern/__config.h	/^		unsigned count(_I2T<MOLECULE_>) const { return molecules.size(); }$/;"	f	class:molkern::Configure
count	include/molkern/__config.h	/^		unsigned count(const char *s) const { return (unsigned)vm_.count(s); }$/;"	f	class:molkern::Configure
count	include/molkern/__config.h	/^		unsigned count; \/\/ количество загружаемых молекул$/;"	m	struct:molkern::Descriptor_
count	include/molkern/complex/_archetype.h	/^		unsigned count(_I2T<FREEDOM_>, unsigned freedom_type) const$/;"	f	class:molkern::Archetype_
count	include/molkern/complex/_complex.h	/^		unsigned count(_I2T<FREEDOM_>) const$/;"	f	class:molkern::Complex_
count	include/molkern/complex/_complex.h	/^		unsigned count(_I2T<FREE_>) const$/;"	f	class:molkern::Complex_
count	include/molkern/complex/_complex.h	/^		unsigned count(_I2T<MOLECULE_>, unsigned iarchetype) const$/;"	f	class:molkern::Complex_
count	include/molkern/complex/_linkcell.h	/^		unsigned count(_I2T<REBUILD_>) const { return 0; }$/;"	f	class:molkern::_Link_cell
count	include/molkern/complex/_molecule.h	/^		unsigned count(_I2T<FREEDOM_>) const { return archetype_->count(FREEDOM, freedom_type_); }$/;"	f	class:molkern::Molecule_
count	include/molkern/complex/_molecule.h	/^		unsigned count(_I2T<FREE_>) const$/;"	f	class:molkern::Molecule_
count	include/molkern/complex/_region.h	/^		unsigned count(_I2T<ATOM_>, unsigned i=0) const { return items_[i].size(); }$/;"	f	class:molkern::Node_
count	include/molkern/complex/_region.h	/^		unsigned count(_I2T<DIRECTION_>) const { return 13; }$/;"	f	class:molkern::Region_
count	include/molkern/complex/_region.h	/^		unsigned count(_I2T<NODE_>) const { return nodes_.size(); }$/;"	f	class:molkern::Region_
count	include/molkern/complex/_region.h	/^		unsigned count(_I2T<SET_>) const { return pairs_sets_.size(); }$/;"	f	class:molkern::Region_
count	include/molkern/complex/_region.h	/^		unsigned count(_I2T<SET_>, unsigned i) const { return pairs_sets_[i].size(); }$/;"	f	class:molkern::Region_
count	include/molkern/complex/_verlet.h	/^		unsigned count(_I2T<REBUILD_>) const { return rebuild_verlet_table_count_; }$/;"	f	class:molkern::_Verlet_table
count	include/molkern/complex/_verlet.h	/^	INLINE unsigned count(_I2T<NEIGHBOR_>, real_t radius, real_t density)$/;"	f	namespace:molkern
count	include/molkern/forcefield/_residome.h	/^		unsigned count(_I2T<RESIDUE_>) const { return residues_.size(); }$/;"	f	class:molkern::basic_residome_
count	include/molkern/forcefield/_residue.h	/^		unsigned count(_I2T<ATOM_>) const { return residue_atomdata_.size(); }$/;"	f	class:molkern::basic_residue_
count	include/molkern/forcefield/_residue.h	/^		unsigned count(_I2T<CHAIN_>) const { return chain_count_; }$/;"	f	class:molkern::basic_residue_
count	include/molkern/forcefield/_residue.h	/^		unsigned count(_I2T<ROTAMER_>) const { return rotamers_.size(); }$/;"	f	class:molkern::basic_residue_
count	include/molkern/forcefield/_residue_amber.h	/^		unsigned count(_I2T<ATOM_>) const { return atoms.size(); }$/;"	f	struct:molkern::Params
count	include/molkern/forcefield/_rotamer.h	/^		unsigned &count(_I2T<ATOM_>) { return ndx_count_; }$/;"	f	class:molkern::Chain_
count	include/molkern/forcefield/_rotamer.h	/^		unsigned &count(_I2T<ATOM_>) { return ndx_count_; }$/;"	f	class:molkern::Rotamer_
count	include/molkern/forcefield/_rotamer.h	/^		unsigned count(_I2T<ATOM_>) const { return ndx_count_; }$/;"	f	class:molkern::Chain_
count	include/molkern/forcefield/_rotamer.h	/^		unsigned count(_I2T<ATOM_>) const { return ndx_count_; }$/;"	f	class:molkern::Rotamer_
count	include/prgkern/_iterator.h	/^		unsigned count() const$/;"	f	class:prgkern::piecewise_vector
count	include/prgkern/_sse.h	/^		unsigned count() const { return non_empty_element_count[_mm_movemask_ps(b_)]; }$/;"	f	class:prgkern::vecbool_
count	include/prgkern/_sse.h	/^		unsigned count() const { return std::abs(v_[0] + v_[1] + v_[2] + v_[3]); }$/;"	f	class:prgkern::vecbool_
count	include/prgkern/_sse.h	/^		unsigned count() const { return std::abs(v_[0]); }$/;"	f	class:prgkern::vecbool_
count	include/prgkern/_time.h	/^		static unsigned count() { return accumulate_count[NT]; }$/;"	f	class:prgkern::function_timer_t
count_	include/molkern/complex/_parallel.h	/^		unsigned count_; \/\/ число порций данных (число вызовов внешней функции,$/;"	m	class:molkern::Parall_
count_	include/prgkern/_average.h	/^		unsigned count_;$/;"	m	class:prgkern::Average_
count_	include/prgkern/_iterator.h	/^			unsigned count_;$/;"	m	class:prgkern::piecewise_vector::iterator_
count_	include/prgkern/_pproc.h	/^		static int count_;$/;"	m	class:prgkern::Guard_
count_	include/prgkern/_pproc.h	/^	template <int N> int Guard_<N>::count_ = -1;$/;"	m	class:prgkern::Guard_
cr_matrix_	include/molkern/complex/_archetype.h	/^		matrix<ACCUMULATE_> cr_matrix_; \/\/ матрица, позволяющая найти все ротамеры для цепи$/;"	m	class:molkern::Archetype_
ctoa	include/prgkern/_string.h	/^	INLINE std::string ctoa(char v)   { return std::string(1, v); }$/;"	f	namespace:prgkern
cube	include/prgkern/_math.h	/^	template <typename T> INLINE T cube(T s) { return s * s * s; }$/;"	f	namespace:prgkern
cube	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> cube(vecreal_<4, float> a) { return _mm_mul_ps(_mm_mul_ps(a, a), a); }$/;"	f	namespace:prgkern
cube	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> cube(vecreal_<N, T> a) { return a * a * a; }$/;"	f	namespace:prgkern
cur_piece_	include/prgkern/_iterator.h	/^			_piece *cur_piece_;$/;"	m	class:prgkern::piecewise_vector::iterator_
curf	include/molkern/forcefield/_fparams.h	/^		int curf; \/\/ current subfunctions$/;"	m	struct:molkern::Params
current_model_time	include/molkern/__moldefs.h	/^	INLINE model_time_t current_model_time() { return global_model_time; }$/;"	f	namespace:molkern
current_time	include/prgkern/_time.h	/^	INLINE system_time_t current_time() { time_t tm; time(&tm); return system_time_t(tm, 0); }$/;"	f	namespace:prgkern
current_time	include/prgkern/_time.h	/^	INLINE system_time_t current_time()$/;"	f	namespace:prgkern
cutoff_radius	include/molkern/__config.h	/^		real_t cutoff_radius; \/\/ радиус обрезания потенциала$/;"	m	class:molkern::Configure
cycle_index_cast	include/prgkern/_index.h	/^		cycle_index_cast() {}$/;"	f	class:prgkern::cycle_index_cast
cycle_index_cast	include/prgkern/_index.h	/^		cycle_index_cast(const _Index &up) : _Base(up) {}$/;"	f	class:prgkern::cycle_index_cast
cycle_index_cast	include/prgkern/_index.h	/^		cycle_index_cast(const cycle_index_cast& c) : _Base(c) {}$/;"	f	class:prgkern::cycle_index_cast
cycle_index_cast	include/prgkern/_index.h	/^	template <unsigned N> class cycle_index_cast : public index_cast_<N>$/;"	c	namespace:prgkern
dU__dX	include/molkern/complex/_archetype.h	/^	::dU__dX(_I2T<ANGLE_>, _Atom *atoms, _Iterator start, _Iterator end) const$/;"	f	class:molkern::Archetype_
dU__dX	include/molkern/complex/_archetype.h	/^	::dU__dX(_I2T<BOND_>, _Atom *atoms, _Iterator start, _Iterator end) const$/;"	f	class:molkern::Archetype_
dU__dX	include/molkern/complex/_archetype.h	/^	::dU__dX(_I2T<PAIR14_>, _Atom *atoms, _Iterator start, _Iterator end) const$/;"	f	class:molkern::Archetype_
dU__dX	include/molkern/complex/_archetype.h	/^	::dU__dX(_I2T<TORSION_>, _Atom *atoms, _Iterator start, _Iterator end) const$/;"	f	class:molkern::Archetype_
dU__dX	include/molkern/complex/_complex.h	/^	::dU__dX()$/;"	f	class:molkern::Complex_
dU__dX	include/molkern/complex/_linkcell.h	/^	::dU__dX()$/;"	f	class:molkern::_Link_cell
dU__dX	include/molkern/complex/_molecule.h	/^	::dU__dX(_Atom *atoms) const$/;"	f	class:molkern::Molecule_
dU__dX	include/molkern/complex/_optimize.h	/^		static real_t dU__dX(unsigned n, const real_t *x, real_t *g, void *param)$/;"	f	class:molkern::Optimizer_
dU__dX	include/molkern/complex/_verlet.h	/^	::dU__dX()$/;"	f	class:molkern::_Verlet_table
dU__dX	include/molkern/forcefield/_1interactions.h	/^		static real_t dU__dX(int curf, const int *n, const real_t *v, const real_t *phi,$/;"	f	struct:molkern::Interaction1_
dU__dX	include/molkern/forcefield/_1interactions.h	/^		static real_t dU__dX(real_t ke, real_t q0, vector_t &A, vector_t &B)$/;"	f	struct:molkern::Interaction1_
dU__dX	include/molkern/forcefield/_1interactions.h	/^		static real_t dU__dX(real_t ke, real_t q0, vector_t &R)$/;"	f	struct:molkern::Interaction1_
dU__dX	include/molkern/forcefield/_bond.h	/^		real_t dU__dX(vector_t &R) const$/;"	f	struct:molkern::Bond_
dU__dX	include/molkern/forcefield/_interactions.h	/^		static real_t dU__dX(_I2T<COUL_>, real_t *du__dq, real_t sigma2, real_t charge,$/;"	f	struct:molkern::Interaction_
dU__dX	include/molkern/forcefield/_interactions.h	/^		static real_t dU__dX(_I2T<VDW_>, real_t *du__dq, real_t sigma2, real_t eps,$/;"	f	struct:molkern::Interaction_
dU__dX	include/molkern/forcefield/_interactions.h	/^		static vreal_t dU__dX(_I2T<COUL_>, vreal_t *du__dq, vreal_t sigma2, vreal_t charge,$/;"	f	struct:molkern::Interaction_
dU__dX	include/molkern/forcefield/_interactions.h	/^		static vreal_t dU__dX(_I2T<VDW_>, vreal_t *du__dq, vreal_t sigma2, vreal_t eps,$/;"	f	struct:molkern::Interaction_
dU__dX_	include/molkern/complex/_linkcell.h	/^	::dU__dX_(unsigned pos)$/;"	f	class:molkern::_Link_cell
dU__dX_	include/molkern/complex/_linkcell.h	/^	::dU__dX_(unsigned pos, unsigned pos__)$/;"	f	class:molkern::_Link_cell
dU__dX_	include/molkern/complex/_verlet.h	/^	::dU__dX_(vector_t *F__, unsigned igroup)$/;"	f	class:molkern::_Verlet_table
dU__dX_	include/molkern/complex/_verlet.h	/^	::dU__dX_(vector_t *F__, unsigned irow)$/;"	f	class:molkern::_Verlet_table
d_	include/prgkern/_box.h	/^		_Vector d_; \/\/\/< левый нижний край$/;"	m	class:prgkern::Box_
data_	include/prgkern/_v3dense.h	/^		T *data_() { return &v_[0]; }$/;"	f	class:prgkern::vdense_
data_	include/prgkern/_v3dense.h	/^		const T *data_() const { return &v_[0]; }$/;"	f	class:prgkern::vdense_
data_dir	include/molkern/__config.h	/^		_S data_dir; \/\/ директория, откуда забираются параметры силовых полей$/;"	m	class:molkern::Configure
dec_interval_	include/prgkern/_minimize.h	/^		int dec_interval_(bool find_minimum, T &beta, T &f0, T &g0, T &xa, T &fa, T &ga, T &xb, T &fb, T &gb,$/;"	f	class:prgkern::Line_minimizer_
degree	include/prgkern/_math.h	/^	template <unsigned N, typename T> INLINE T degree(T s)$/;"	f	namespace:prgkern
density	include/molkern/__config.h	/^		real_t density; \/\/ число частиц в 1 A**3$/;"	m	class:molkern::Configure
density_	include/molkern/complex/_complex.h	/^		real_t density_; \/\/ плотность раствора (число молекул в 1 A**3)$/;"	m	class:molkern::Complex_
density_	include/molkern/complex/_linkcell.h	/^		real_t density_; \/\/ плотность частиц$/;"	m	class:molkern::_Link_cell
density_	include/molkern/complex/_verlet.h	/^		real_t density_; \/\/ плотность частиц$/;"	m	class:molkern::_Verlet_table
desc_	include/molkern/__config.h	/^		boost::program_options::options_description desc_;$/;"	m	class:molkern::Configure
descriptor_type	include/molkern/complex/_thermostat.h	/^		typedef _Descriptor  descriptor_type;$/;"	t	class:molkern::Thermostat
determinant	include/prgkern/_m3x3dense.h	/^	INLINE T determinant(const mdense_<2, 2, T> &m)$/;"	f	namespace:prgkern
determinant	include/prgkern/_m3x3dense.h	/^	INLINE T determinant(const mdense_<3, 3, T> &m)$/;"	f	namespace:prgkern
dfft_sizes	include/prgkern/_transforms.h	/^	const unsigned dfft_sizes[] = {$/;"	m	namespace:prgkern
dfht	include/prgkern/_transforms.h	/^	template <typename _Real> INLINE void dfht(unsigned n, _Real *v)$/;"	f	namespace:prgkern
dfht2d	include/prgkern/_transforms.h	/^	INLINE void dfht2d(unsigned n1, unsigned n2, _Real *m)$/;"	f	namespace:prgkern
dfwht	include/prgkern/_transforms.h	/^	template <typename _Real> INLINE void dfwht(unsigned n, _Real *v)$/;"	f	namespace:prgkern
dfwht2d	include/prgkern/_transforms.h	/^	INLINE void dfwht2d(unsigned n1, unsigned n2, _Real *m)$/;"	f	namespace:prgkern
dihe_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorD dihe_params_;$/;"	m	class:molkern::__Forcefield
dim	include/molkern/complex/_region.h	/^			dim = 3, \/\/ размерность решетки$/;"	e	enum:molkern::Region_::__anon20
dim	include/prgkern/_m3x3dense.h	/^		enum { dim = N, dim1 = N, dim2 = N };$/;"	e	enum:prgkern::mdense_::__anon33
dim1	include/prgkern/_m3x3dense.h	/^		enum { dim = N, dim1 = N, dim2 = N };$/;"	e	enum:prgkern::mdense_::__anon33
dim2	include/prgkern/_m3x3dense.h	/^		enum { dim = N, dim1 = N, dim2 = N };$/;"	e	enum:prgkern::mdense_::__anon33
dim_	include/prgkern/_dense.h	/^		_Index dim_; \/\/ верхние границы массивов$/;"	m	class:prgkern::basic_dense_
dimension	include/molkern/complex/_archetype.h	/^		enum { dimension = 3 };$/;"	e	enum:molkern::Archetype_::__anon19
dimension	include/molkern/complex/_complex.h	/^		enum { dimension = 3 };$/;"	e	enum:molkern::Complex_::__anon16
dimension	include/molkern/complex/_molecule.h	/^		enum { dimension = 3 };$/;"	e	enum:molkern::Molecule_::__anon15
dimension	include/prgkern/_index.h	/^		_Index dimension() const { return s_; }$/;"	f	class:prgkern::index_cast_
dimension	include/prgkern/_mdense.h	/^		_Index dimension() const { return _Base::dim_; }$/;"	f	class:prgkern::mdense_
dimension	include/prgkern/_mesh.h	/^		_Index dimension() const { return sz_; }$/;"	f	class:prgkern::Mesh_
dimension	include/prgkern/_v3dense.h	/^		dimension_type dimension() const { return N; }$/;"	f	class:prgkern::vdense_
dimension_type	include/prgkern/_v3dense.h	/^		typedef unsigned dimension_type;$/;"	t	class:prgkern::vdense_
direct_product	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> direct_product(const vdense_<N, T> &X1, const vdense_<N, T> &X2)$/;"	f	namespace:prgkern
direct_product	include/prgkern/_m3x3dense.h	/^	INLINE void direct_product(mdense_<2, 2, T> &m, const vdense_<2, T> &X1,$/;"	f	namespace:prgkern
direct_product	include/prgkern/_m3x3dense.h	/^	INLINE void direct_product(mdense_<3, 3, T> &m, const vdense_<3, T> &X1,$/;"	f	namespace:prgkern
direct_product	include/prgkern/_m3x3dense.h	/^	INLINE void direct_product(mdense_<4, 4, T> &m, const vdense_<4, T> &X1,$/;"	f	namespace:prgkern
directory_iterator	include/prgkern/_os.h	/^		directory_iterator() : _base() {}$/;"	f	class:prgkern::directory_iterator
directory_iterator	include/prgkern/_os.h	/^		directory_iterator(const std::string &dirname)$/;"	f	class:prgkern::directory_iterator
directory_iterator	include/prgkern/_os.h	/^	class directory_iterator : public fs::directory_iterator$/;"	c	namespace:prgkern
dirname_	include/molkern/forcefield/_forcefield.h	/^		std::string dirname_;$/;"	m	class:molkern::__Forcefield
dirname_	include/molkern/forcefield/_residome.h	/^		std::string dirname_;$/;"	m	class:molkern::basic_residome_
dispose_	include/molkern/complex/_complex.h	/^	::dispose_(_I2T<MOLECULE_>, const _Box &box, unsigned iarchetype, vector_t *X,$/;"	f	class:molkern::Complex_
dispose_	include/molkern/complex/_complex.h	/^	::dispose_(_I2T<WATER_>, const _Box &box, unsigned iarchetype, real_t density)$/;"	f	class:molkern::Complex_
distance1	include/prgkern/_v3dense.h	/^	INLINE T distance1(const vdense_<N, T> &v1, const vdense_<N, T> &v2)$/;"	f	namespace:prgkern
distance2	include/prgkern/_v3dense.h	/^	INLINE T distance2(const vdense_<N, T> &v1, const vdense_<N, T> &v2)$/;"	f	namespace:prgkern
dt_	include/molkern/complex/_mdynamics.h	/^		unsigned dt_; \/\/ шаг интегрирования (число fs)$/;"	m	class:molkern::Integrator_
edge_type	include/molkern/complex/_archetype.h	/^		typedef _Edge         edge_type;$/;"	t	class:molkern::Archetype_
edges_	include/molkern/complex/_archetype.h	/^		std::vector<_Edge>      edges_;     \/\/ упорядоченные ребра графа ротамеров$/;"	m	class:molkern::Archetype_
elem_	include/prgkern/_iterator.h	/^			T *elem_;$/;"	m	class:prgkern::piecewise_vector::iterator_
elem_count_	include/molkern/complex/_verlet.h	/^			unsigned elem_count_;$/;"	m	struct:molkern::_Verlet_table::Group_
elmnt	include/molkern/forcefield/_residue_amber.h	/^			int elmnt;  \/\/ don't used$/;"	m	struct:molkern::Params::__anon1
end	include/molkern/complex/_region.h	/^		const_iterator end(unsigned i=0) const { return items_[i].end(); }$/;"	f	class:molkern::Node_
end	include/molkern/complex/_region.h	/^		iterator end(unsigned i=0) { return items_[i].end(); }$/;"	f	class:molkern::Node_
end	include/molkern/forcefield/_forcefield.h	/^		typename _VectorT::const_iterator end  (_PairT *) const { return atom_params_.end(); }$/;"	f	class:molkern::__Forcefield
end	include/prgkern/_iterator.h	/^		iterator end() { return iterator(); }$/;"	f	class:prgkern::piecewise_vector
enlarge	include/molkern/complex/_region.h	/^		void enlarge(const _Box &box)$/;"	f	class:molkern::Region_
enlarge	include/prgkern/_box.h	/^		Box_ &enlarge(T coef)$/;"	f	class:prgkern::Box_
enlarge	include/prgkern/_box.h	/^		Box_ &enlarge(T coef, const _Vector &X)$/;"	f	class:prgkern::Box_
enlarge	include/prgkern/_box.h	/^		Box_ &enlarge(const _Vector &X)$/;"	f	class:prgkern::Box_
ensamble	include/molkern/__config.h	/^		_S ensamble; \/\/ имя термодинамического ансамбля$/;"	m	struct:molkern::Descriptor_
ensamble	include/molkern/__config.h	/^		_S ensamble; \/\/ тип термодинамического ансамбля$/;"	m	class:molkern::Configure
ensemble_	include/molkern/complex/_thermostat.h	/^		_Ensemble ensemble_; \/\/ набор генераторов (mass, distr)$/;"	m	class:molkern::maxwell_distribution_ensemble_
ensemble_	include/molkern/complex/_thermostat.h	/^		void *ensemble_; \/\/ текущий термодинамический ансамбль$/;"	m	class:molkern::Thermostat
eps	include/molkern/complex/_complex.h	/^			real_t eps; \/\/\/< параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::Complex_::_Atom
eps	include/molkern/complex/_complex.h	/^			real_t eps; \/\/\/< параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::Complex_::_LJAtom
eps	include/molkern/complex/_region.h	/^		T1 eps; \/\/ параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::__LJAtom
eps	include/molkern/forcefield/_atomdata.h	/^		real_t eps;$/;"	m	struct:molkern::Atomdata_
eps	include/molkern/forcefield/_fparams.h	/^		real_t eps; \/\/ used to calculate c6, c12 VdW coefficients$/;"	m	struct:molkern::Params
eqty_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorE eqty_params_; \/\/ EQuivalent TYpes (for bonds, angls, tors)$/;"	m	class:molkern::__Forcefield
equal	include/prgkern/_math.h	/^	template <typename T> INLINE bool equal(T a, T b,$/;"	f	namespace:prgkern
equal	include/prgkern/_v3dense.h	/^	INLINE bool equal(const vdense_<3, T> &v1, const vdense_<3, T> &v2,$/;"	f	namespace:prgkern
equal	include/prgkern/_vdense.h	/^	INLINE bool equal(const vdense_<UNLIMITED_, T> &v1, const vdense_<UNLIMITED_, T> &v2,$/;"	f	namespace:prgkern
equal_	include/prgkern/_type.h	/^		equal_(_F f) : f_(f) {}$/;"	f	class:prgkern::equal_
equal_	include/prgkern/_type.h	/^	class equal_$/;"	c	namespace:prgkern
equi	include/molkern/forcefield/_residome_amber.h	/^			fstring equi[pH_RANGE];$/;"	m	struct:molkern::amber::_Equi
equi_angls_	include/molkern/forcefield/_forcefield.h	/^		mutable _VectorA equi_angls_;$/;"	m	class:molkern::__Forcefield
equi_bonds_	include/molkern/forcefield/_forcefield.h	/^		mutable _VectorB equi_bonds_;$/;"	m	class:molkern::__Forcefield
equi_dihes_	include/molkern/forcefield/_forcefield.h	/^		mutable _VectorD equi_dihes_;$/;"	m	class:molkern::__Forcefield
equi_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorE equi_params_; \/\/ EQuivalent types (for vdw)$/;"	m	class:molkern::__Forcefield
equis_	include/molkern/forcefield/_residome_amber.h	/^		const _Equi equis_[] =$/;"	m	namespace:molkern::amber
eqv	include/molkern/forcefield/_fparams.h	/^		fstring eqv[MAX_EQUIVALENT];$/;"	m	struct:molkern::Params
erf	include/prgkern/_sse.h	/^	INLINE vecreal_<1, T> erf(vecreal_<1, T> a)$/;"	f	namespace:prgkern
erf	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> erf(vecreal_<4, float> a)$/;"	f	namespace:prgkern
exclude_cm_	include/molkern/complex/_archetype.h	/^		bool exclude_cm_;               \/\/ исключать центр инерции при расчетах$/;"	m	class:molkern::Archetype_
execute_	include/prgkern/_transforms.h	/^		void execute_() { fft_execute_dft(fft_icdata_, fft_ocdata_); }$/;"	f	class:prgkern::Dfft
execute_	include/prgkern/_transforms.h	/^		void execute_() { fft_execute_dft(fft_icdata_, fft_ordata_); }$/;"	f	class:prgkern::Dfft
execute_	include/prgkern/_transforms.h	/^		void execute_() { fft_execute_dft(fft_irdata_, fft_ocdata_); }$/;"	f	class:prgkern::Dfft
exp	include/prgkern/_sse.h	/^	INLINE vecreal_<1, T> exp(vecreal_<1, T> a)$/;"	f	namespace:prgkern
exp	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> exp(vecreal_<4, float> a)$/;"	f	namespace:prgkern
expand	include/prgkern/_for.h	/^		static void expand(F f)$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F f, T1 *s)$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F f, T1 *s, T2 *p)$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F f, T1 *s, T2 *p, T3 *q)$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F) {}$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F, T1 *) {}$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F, T1*, T2*) {}$/;"	f	struct:prgkern::for_
expand	include/prgkern/_for.h	/^		static void expand(F, T1*, T2*, T3*) {}$/;"	f	struct:prgkern::for_
export_	include/prgkern/_transforms.h	/^		void export_(_Real *vo)$/;"	f	class:prgkern::Dfft
export_	include/prgkern/_transforms.h	/^		void export_(std::complex<_Real> *vo)$/;"	f	class:prgkern::Dfft
export_	include/prgkern/_transforms.h	/^		void export_(vdense_<2, _Real> *vo)$/;"	f	class:prgkern::Dfft
export_	include/prgkern/_transforms.h	/^		void export_(vdense_<3, _Real> *vo)$/;"	f	class:prgkern::Dfft
export_	include/prgkern/_transforms.h	/^		void export_(vdense_<4, _Real> *vo)$/;"	f	class:prgkern::Dfft
export_	include/prgkern/_transforms.h	/^		void export_(vdense_<M, _Real> *vo)$/;"	f	class:prgkern::Dfft
expr2value	include/prgkern/_pproc.h	/^	template <typename T> inline T expr2value(T expr) { return expr; }$/;"	f	namespace:prgkern
ext_contacts_	include/molkern/forcefield/_residue.h	/^		int ext_contacts_[2];$/;"	m	class:molkern::basic_residue_
extended	include/prgkern/_type.h	/^	template <> struct extended<char> { typedef short type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<double> { typedef double type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<float> { typedef float type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<int> { typedef int type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<short> { typedef int type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<unsigned char> { typedef unsigned short type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<unsigned int> { typedef unsigned int type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_type.h	/^	template <> struct extended<unsigned short> { typedef unsigned int type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_v3dense.h	/^	template <unsigned N, typename T> struct extended<vdense_<N, T> >$/;"	s	namespace:prgkern
extended	include/prgkern/_vdense.h	/^	template <unsigned N> struct extended<vdense_<N, double> > { typedef vdense_<N, double> type; };$/;"	s	namespace:prgkern
extended	include/prgkern/_vdense.h	/^	template <unsigned N> struct extended<vdense_<N, float> > { typedef vdense_<N, double> type; };$/;"	s	namespace:prgkern
extension	include/prgkern/_os.h	/^	INLINE std::string extension(const std::string &s)$/;"	f	namespace:prgkern
extract_k	include/prgkern/_transforms.h	/^		void extract_k(vdense_<1, _Real> &k, unsigned n) const$/;"	f	class:prgkern::Dfft
extract_k	include/prgkern/_transforms.h	/^		void extract_k(vdense_<2, _Real> &k, unsigned n) const$/;"	f	class:prgkern::Dfft
extract_k	include/prgkern/_transforms.h	/^		void extract_k(vdense_<3, _Real> &k, unsigned n) const$/;"	f	class:prgkern::Dfft
extract_object	include/molkern/forcefield/_atomdata.h	/^	inline int extract_object(_I2T<FORMAT_BMM_>, Atomdata_ &atomdata, std::ifstream *src)$/;"	f	namespace:molkern
extract_object	include/molkern/forcefield/_atomdata.h	/^	inline int extract_object(_I2T<FORMAT_HIN_>, Atomdata_ &atomdata, std::ifstream *src)$/;"	f	namespace:molkern
extract_object	include/molkern/forcefield/_atomdata.h	/^	inline int extract_object(_I2T<FORMAT_MOL2_>, Atomdata_ &atomdata, std::ifstream *src)$/;"	f	namespace:molkern
extract_object	include/molkern/forcefield/_atomdata.h	/^	inline int extract_object(_I2T<FORMAT_PDB_>, Atomdata_ &atomdata, std::ifstream *src)$/;"	f	namespace:molkern
extract_object	include/molkern/forcefield/_atomdata.h	/^	inline void extract_object(_I2T<FORMAT_PDB_>, Atomdata_ &atomdata, char *line)$/;"	f	namespace:molkern
extreme_cube	include/prgkern/_math.h	/^	INLINE int extreme_cube(T *xmin, T *xmax, T *fmin, T *fmax,$/;"	f	namespace:prgkern
extreme_sqr	include/prgkern/_math.h	/^	INLINE int extreme_sqr(T *x, T *f, T xa, T xb, T fa, T fb, T ga, T gb,$/;"	f	namespace:prgkern
f_	include/prgkern/_sse.h	/^		__m128 f_;$/;"	m	class:prgkern::vecreal_
f_	include/prgkern/_type.h	/^		_F f_;$/;"	m	class:prgkern::equal_
f_	include/prgkern/_type.h	/^		const _T *f_;$/;"	m	class:prgkern::less_than_
far	include/molkern/forcefield/_potential.h	/^		_Real far(_Real r) const$/;"	f	class:molkern::Potential
far1	include/molkern/forcefield/_potential.h	/^		_Real far1(_Real r) const$/;"	f	class:molkern::Potential
ffindex1	include/molkern/forcefield/_fparams.h	/^	typedef index_<1, fstring> ffindex1;$/;"	t	namespace:molkern
ffindex2	include/molkern/forcefield/_fparams.h	/^	typedef sym_index_<2, fstring> ffindex2;$/;"	t	namespace:molkern
ffindex3	include/molkern/forcefield/_fparams.h	/^	typedef sym_index_<3, fstring> ffindex3;$/;"	t	namespace:molkern
ffindex4	include/molkern/forcefield/_fparams.h	/^	typedef sym_index_<4, fstring> ffindex4;$/;"	t	namespace:molkern
fftw3_connect	include/prgkern/_transforms.h	/^	template <unsigned _N> struct fftw3_connect<_N, double>$/;"	s	namespace:prgkern
fftw3_connect	include/prgkern/_transforms.h	/^	template <unsigned _N> struct fftw3_connect<_N, float>$/;"	s	namespace:prgkern
fftw3_connect	include/prgkern/_transforms.h	/^	template <unsigned _N> struct fftw3_connect<_N, long double>$/;"	s	namespace:prgkern
fftype	include/molkern/forcefield/_atomdata.h	/^		fstring fftype;$/;"	m	struct:molkern::Atomdata_
fftype	include/molkern/forcefield/_residue.h	/^		fstring fftype; \/\/ тип силового поля$/;"	m	struct:molkern::__ResidueAtomdata
fftypes	include/molkern/forcefield/_atomdata.h	/^	const fstring fftypes[] =$/;"	m	namespace:molkern
fftypes_len	include/molkern/forcefield/_atomdata.h	/^	const unsigned fftypes_len = sizeof(fftypes) \/ sizeof(fstring);$/;"	m	namespace:molkern
file1_	include/molkern/complex/_mdynamics.h	/^		std::ofstream file1_; \/\/ базовый файл статистики$/;"	m	class:molkern::Integrator_
file2_	include/molkern/complex/_mdynamics.h	/^		std::ofstream file2_; \/\/ вспомогательный файл статистики$/;"	m	class:molkern::Integrator_
filename_	include/molkern/complex/_archetype.h	/^		std::string filename_;          \/\/ имя файла загрузки$/;"	m	class:molkern::Archetype_
filename_	include/molkern/complex/_mdynamics.h	/^		std::string filename_; \/\/ имя файла статистики$/;"	m	class:molkern::Integrator_
finalize	include/prgkern/_mesh.h	/^		void finalize(_Real *fn)$/;"	f	class:prgkern::Mesh_
find	include/molkern/complex/_archetype.h	/^	::find(_I2T<EXT_ID_>, int sid, int pos) const$/;"	f	class:molkern::Archetype_
find_data__	include/molkern/forcefield/_forcefield.h	/^		bool find_data__(_Param *param, const _Index &ndx,$/;"	f	class:molkern::__Forcefield
find_nuclear	include/molkern/forcefield/_nuclear.h	/^	INLINE unsigned find_nuclear(const std::string &name)$/;"	f	namespace:molkern
find_nuclear	include/molkern/forcefield/_nuclear.h	/^	inline unsigned find_nuclear(_I2T<MASS_>, real_t mass, real_t accuracy=0.5)$/;"	f	namespace:molkern
find_pos	include/prgkern/_transforms.h	/^		fft_index find_pos(unsigned n) const$/;"	f	class:prgkern::Dfft
find_pos	include/prgkern/_transforms.h	/^		unsigned find_pos(bool &flag, const fft_index &k) const$/;"	f	class:prgkern::Dfft
fix12s_	include/molkern/complex/_archetype.h	/^		std::set<unsigned>  fix12s_; \/\/ номера связей в bonds, которые не вращаются$/;"	m	class:molkern::Archetype_
fk__	include/prgkern/_minimize_lbfgs.h	/^		_Real fk__; \/\/ previous f()$/;"	m	class:prgkern::Updater
flag	include/molkern/forcefield/_residue_amber.h	/^			real_t flag;$/;"	m	struct:molkern::Params::__anon4
flag_	include/molkern/complex/_region.h	/^		bool flag_;$/;"	m	class:molkern::Region_
flags	include/molkern/forcefield/_residue_amber.h	/^			int flags;  \/\/ don't used$/;"	m	struct:molkern::Params::__anon1
flags	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { int atom1x, atom2x, flags; } _Bond;$/;"	m	struct:molkern::Params::__anon5
floor	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> floor(vecreal_<4, float> a)$/;"	f	namespace:prgkern
fn_	include/molkern/complex/_parallel.h	/^		_Fn fn_; \/\/ функция объекта, выполняемая в параллельном режиме$/;"	m	class:molkern::ParallWorker_
fn_	include/molkern/complex/_parallel.h	/^		_Fn fn_; \/\/ функция объекта, выполняемая в параллельном режиме$/;"	m	class:molkern::Parall_
fn_	include/prgkern/_stencil.h	/^		T fn_[10]; \/\/ precalculated f() values$/;"	m	class:prgkern::Stencil_
fn_	include/prgkern/_stencil.h	/^		T fn_[4]; \/\/ предвычисленные значения f()$/;"	m	class:prgkern::Stencil_
fn_	include/prgkern/_stencil.h	/^		mutable std::vector<T> fn_; \/\/\/< внутренная подсетка$/;"	m	class:prgkern::Stencil_
for_	include/prgkern/_for.h	/^	struct for_$/;"	s	namespace:prgkern
for_	include/prgkern/_for.h	/^	struct for_<N2, N2>$/;"	s	namespace:prgkern
forcefield_	include/molkern/complex/_archetype.h	/^		const _Forcefield *forcefield_; \/\/ база данных параметров атомных типов$/;"	m	class:molkern::Archetype_
forcefield_	include/molkern/complex/_complex.h	/^		const _Forcefield *forcefield_; \/\/ указатель на силовое поле$/;"	m	class:molkern::Complex_
forcefield_type	include/molkern/complex/_archetype.h	/^		typedef _Forcefield   forcefield_type;$/;"	t	class:molkern::Archetype_
format_	include/molkern/complex/_archetype.h	/^		unsigned format_;               \/\/ формат файла загрузки молекулы$/;"	m	class:molkern::Archetype_
forward_interpolation	include/prgkern/_math.h	/^	INLINE S forward_interpolation(S f0, S p0, _Real h)$/;"	f	namespace:prgkern
forward_interpolation	include/prgkern/_math.h	/^	INLINE S forward_interpolation(S f_1, S f0, S p_1, S p0, _Real h)$/;"	f	namespace:prgkern
forward_interpolation	include/prgkern/_math.h	/^	INLINE S forward_interpolation(S f_2, S f_1, S f0, S p_2, S p_1, S p0, _Real h)$/;"	f	namespace:prgkern
forward_interpolation	include/prgkern/_math.h	/^	INLINE void forward_interpolation(unsigned n, S *f,$/;"	f	namespace:prgkern
fourier3	include/molkern/forcefield/_potential.h	/^		_Real fourier3(_Real k) const$/;"	f	class:molkern::Potential
fourier_far3	include/molkern/forcefield/_potential.h	/^		_Real fourier_far3(_Real k) const$/;"	f	class:molkern::Potential
fourier_near3	include/molkern/forcefield/_potential.h	/^		_Real fourier_near3(_Real k) const$/;"	f	class:molkern::Potential
fourier_norm3	include/molkern/forcefield/_potential.h	/^		_Real fourier_norm3() const { return 1.\/ (M_2PI * sqrt(M_2PI)); }$/;"	f	class:molkern::Potential
free	include/molkern/complex/_archetype.h	/^	::free(_I2T<ANGLE_>, __Iterator &to, _Iterator it, _Iterator ite) const$/;"	f	class:molkern::Archetype_
free	include/molkern/complex/_archetype.h	/^	::free(_I2T<BOND_>, __Iterator &to, _Iterator it, _Iterator ite) const$/;"	f	class:molkern::Archetype_
free	include/molkern/complex/_archetype.h	/^	::free(_I2T<PAIR14_>, __Iterator &to, _Iterator it, _Iterator ite) const$/;"	f	class:molkern::Archetype_
free	include/molkern/complex/_archetype.h	/^	::free(_I2T<TORSION_>, __Iterator &to, _Iterator it, _Iterator ite) const$/;"	f	class:molkern::Archetype_
free_angles_	include/molkern/complex/_molecule.h	/^		unsigned_t *free_angles_;$/;"	m	class:molkern::Molecule_
free_angles_count_	include/molkern/complex/_molecule.h	/^		unsigned_t free_angles_count_;$/;"	m	class:molkern::Molecule_
free_atoms_	include/molkern/complex/_molecule.h	/^		unsigned_t *free_atoms_;$/;"	m	class:molkern::Molecule_
free_atoms_count_	include/molkern/complex/_molecule.h	/^		unsigned_t free_atoms_count_;$/;"	m	class:molkern::Molecule_
free_bonds_	include/molkern/complex/_molecule.h	/^		unsigned_t *free_bonds_;$/;"	m	class:molkern::Molecule_
free_bonds_count_	include/molkern/complex/_molecule.h	/^		unsigned_t free_bonds_count_;$/;"	m	class:molkern::Molecule_
free_pair14s_	include/molkern/complex/_molecule.h	/^		unsigned_t *free_pair14s_;$/;"	m	class:molkern::Molecule_
free_pair14s_count_	include/molkern/complex/_molecule.h	/^		unsigned_t free_pair14s_count_;$/;"	m	class:molkern::Molecule_
free_torsions_	include/molkern/complex/_molecule.h	/^		unsigned_t *free_torsions_;$/;"	m	class:molkern::Molecule_
free_torsions_count_	include/molkern/complex/_molecule.h	/^		unsigned_t free_torsions_count_;$/;"	m	class:molkern::Molecule_
freedom_count_	include/molkern/complex/_archetype.h	/^		unsigned freedom_count_(_I2T<YES_ATOM_ |  NO_ROTAMER_>) const { return 3 * atomdata_.size(); }$/;"	f	class:molkern::Archetype_
freedom_count_	include/molkern/complex/_archetype.h	/^		unsigned freedom_count_(_I2T<YES_ATOM_ | YES_ROTAMER_>) const$/;"	f	class:molkern::Archetype_
freedom_count_	include/molkern/complex/_archetype.h	/^		unsigned freedom_count_(_I2T<YES_CM_ |  NO_UNION_>) const { return 6 * count(CHAIN); }$/;"	f	class:molkern::Archetype_
freedom_count_	include/molkern/complex/_archetype.h	/^		unsigned freedom_count_(_I2T<YES_CM_ | YES_UNION_>) const { return 6; }$/;"	f	class:molkern::Archetype_
freedom_count_	include/molkern/complex/_archetype.h	/^		unsigned freedom_count_(_I2T<YES_ROTAMER_>) const { return count(ROTAMER) - count(ROOT_ROTAMER); }$/;"	f	class:molkern::Archetype_
freedom_type	include/molkern/__config.h	/^		unsigned freedom_type; \/\/ тип вставки (какие степени свободы разрешены)$/;"	m	struct:molkern::Descriptor_
freedom_type_	include/molkern/complex/_archetype.h	/^		unsigned freedom_type_;         \/\/ предельный уровень свободы$/;"	m	class:molkern::Archetype_
freedom_type_	include/molkern/complex/_molecule.h	/^		unsigned freedom_type_; \/\/ тип свободы молекулы$/;"	m	class:molkern::Molecule_
fs	include/prgkern/_os.h	124;"	d
fs	include/prgkern/_os.h	25;"	d
fstring	include/prgkern/_fstring.h	/^	typedef fstring_<int> fstring;$/;"	t	namespace:prgkern
fstring_	include/prgkern/_fstring.h	/^		fstring_() { ::memset(&v_, ' ', sizeof(A)); }$/;"	f	class:prgkern::fstring_
fstring_	include/prgkern/_fstring.h	/^		fstring_(const char *s) { init_(s); }$/;"	f	class:prgkern::fstring_
fstring_	include/prgkern/_fstring.h	/^		fstring_(const fstring_ &s) { VALUE(v_) = VALUE(s.v_); }$/;"	f	class:prgkern::fstring_
fstring_	include/prgkern/_fstring.h	/^		fstring_(const std::string &s) { init_(s.c_str()); }$/;"	f	class:prgkern::fstring_
fstring_	include/prgkern/_fstring.h	/^	class fstring_$/;"	c	namespace:prgkern
ftoa	include/prgkern/_string.h	/^	INLINE std::string ftoa(double v) { return make_string(v); }$/;"	f	namespace:prgkern
ftol	include/molkern/__config.h	/^		real_t ftol; \/\/ минимальное значение изменения энергии, обрывающее оптимизацию$/;"	m	class:molkern::Configure
ftol	include/molkern/__config.h	/^		real_t ftol;$/;"	m	struct:molkern::Descriptor_
full	include/molkern/forcefield/_potential.h	/^		_Real full(_Real r) const$/;"	f	class:molkern::Potential
full1	include/molkern/forcefield/_potential.h	/^		_Real full1(_Real r) const$/;"	f	class:molkern::Potential
full_name	include/molkern/forcefield/_nuclear.h	/^		const char *full_name;$/;"	m	struct:molkern::Nuclear
full_name	include/molkern/forcefield/_residome_amber.h	/^			const char *full_name;$/;"	m	struct:molkern::amber::_Short
function_timer_t	include/prgkern/_time.h	/^		function_timer_t(unsigned n=0) : start_time_(current_time()), n_(n) { accumulate_count[n_]++; }$/;"	f	class:prgkern::function_timer_t
function_timer_t	include/prgkern/_time.h	/^	template <int N, unsigned NT=8> class function_timer_t$/;"	c	namespace:prgkern
fx	include/molkern/complex/_region.h	/^		T1 fx, fy, fz; \/\/ текущая сила (coul + vdw), действующая на атом$/;"	m	struct:molkern::__LJAtom
fy	include/molkern/complex/_region.h	/^		T1 fx, fy, fz; \/\/ текущая сила (coul + vdw), действующая на атом$/;"	m	struct:molkern::__LJAtom
fz	include/molkern/complex/_region.h	/^		T1 fx, fy, fz; \/\/ текущая сила (coul + vdw), действующая на атом$/;"	m	struct:molkern::__LJAtom
g_	include/molkern/complex/_complex.h	/^		std::vector<real_t> x_, g_; \/\/ массивы обобщенных координат для оптимизатора$/;"	m	class:molkern::Complex_
gamma_	include/molkern/forcefield/_interactions.h	/^		static real_t gamma_; \/\/\/< коэффициент при полиноме V = alpha + gamma * r^12$/;"	m	struct:molkern::Interaction_
gamma_	src/__moldefs.cpp	/^	real_t Interaction_<C612>::gamma_;$/;"	m	class:molkern::Interaction_	file:
generate	include/molkern/complex/_thermostat.h	/^		_Real generate(_Real mass)$/;"	f	class:molkern::maxwell_distribution_ensemble_
generate	include/molkern/complex/_thermostat.h	/^		void generate(_Real mass, unsigned n, _Real *ranv)$/;"	f	class:molkern::maxwell_distribution_ensemble_
generate_cell_pairs_	include/molkern/complex/_region.h	/^	::generate_cell_pairs_()$/;"	f	class:molkern::Region_
get	include/molkern/complex/_archetype.h	/^		_Box get(_I2T<BOX_>) const$/;"	f	class:molkern::Archetype_
get	include/molkern/complex/_archetype.h	/^		int get(_I2T<EXT_ID_>, int internal_ndx) const$/;"	f	class:molkern::Archetype_
get	include/molkern/complex/_archetype.h	/^		unsigned get(_I2T<FREEDOM_TYPE_>) const { return freedom_type_; }$/;"	f	class:molkern::Archetype_
get	include/molkern/complex/_complex.h	/^		_Box get(_I2T<BOX_>) const { return region_->get(BOX); }$/;"	f	class:molkern::Complex_
get	include/molkern/complex/_complex.h	/^		_Region *get(_I2T<REGION_>) { return region_; }$/;"	f	class:molkern::Complex_
get	include/molkern/complex/_complex.h	/^		const _Region *get(_I2T<REGION_>) const { return region_; }$/;"	f	class:molkern::Complex_
get	include/molkern/complex/_molecule.h	/^		unsigned get(_I2T<FREEDOM_TYPE_>) const { return freedom_type_; }$/;"	f	class:molkern::Molecule_
get	include/molkern/complex/_region.h	/^		S *get(_I2T<ATOM_>, unsigned i=0) { return items_[i].size() ? &items_[i][0] : 0; }$/;"	f	class:molkern::Node_
get	include/molkern/complex/_region.h	/^		_Box get(_I2T<BOX_>) const { return _Box(vector_t(0.,0.,0.), T_); }$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		_Node *get(_I2T<NODE_>, unsigned i=0)$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		const S *get(_I2T<ATOM_>, unsigned i=0) const { return items_[i].size() ? &items_[i][0] : 0; }$/;"	f	class:molkern::Node_
get	include/molkern/complex/_region.h	/^		const _Node *get(_I2T<NODE_>, unsigned i=0) const$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		const unsigned *get(_I2T<PAIR_>, unsigned nset) const { return &pairs_sets_[nset][0]; }$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		real_t get(_I2T<EDGE_LENGTH_>) const { return h_; }$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		unsigned get(_I2T<DIRECTION_>, unsigned iset) const { return pairs_sets_direction_[iset]; }$/;"	f	class:molkern::Region_
get	include/molkern/complex/_region.h	/^		unsigned get(_I2T<EMPTY_DIRECTION_>) const { return 13; }$/;"	f	class:molkern::Region_
get	include/molkern/complex/_thermostat.h	/^	INLINE real_t get(_I2T<PRESSURE_>, _Molecule *molecule)$/;"	f	namespace:molkern
get	include/molkern/complex/_thermostat.h	/^	INLINE real_t get(_I2T<TEMPERATURE_>, _Molecule *molecule)$/;"	f	namespace:molkern
get	include/molkern/forcefield/_forcefield.h	/^		const _ParamT *get(_I2T<ATOM_>, int n) const$/;"	f	class:molkern::__Forcefield
get	include/molkern/forcefield/_forcefield.h	/^	::get(_I2T<EQTY_DISTANCE_>, const fstring &name,$/;"	f	class:molkern::__Forcefield
get	include/molkern/forcefield/_forcefield.h	/^	::get(_I2T<EQUI_>, const _IndexE &ndx) const$/;"	f	class:molkern::__Forcefield
get	include/molkern/forcefield/_forcefield.h	/^	::get(_I2T<MAX_VDW_RADIUS_>) const$/;"	f	class:molkern::__Forcefield
get	include/molkern/forcefield/_residue.h	/^		const _Rotamer *get(_I2T<ROTAMER_>, unsigned i) const { return &rotamers_[i]; }$/;"	f	class:molkern::basic_residue_
get	include/molkern/forcefield/_residue.h	/^		const __ResidueAtomdata *get(_I2T<ATOM_>, const char *name) const$/;"	f	class:molkern::basic_residue_
get	include/molkern/forcefield/_residue.h	/^		int get(_I2T<EXT_CONTACT_NEXT_>) const { return ext_contacts_[1]; }$/;"	f	class:molkern::basic_residue_
get	include/molkern/forcefield/_residue.h	/^		int get(_I2T<EXT_CONTACT_PREV_>) const { return ext_contacts_[0]; }$/;"	f	class:molkern::basic_residue_
get	include/molkern/forcefield/_rotamer.h	/^		const unsigned *get(_I2T<ATOM_>, unsigned i=0) const { return ndx_ + i; }$/;"	f	class:molkern::Chain_
get	include/molkern/forcefield/_rotamer.h	/^		const unsigned *get(_I2T<ATOM_>, unsigned i=0) const { return ndx_ + i; }$/;"	f	class:molkern::Rotamer_
get	include/molkern/forcefield/_rotamer.h	/^		unsigned get(_I2T<ROTAMER_ADD_ATOM_>, unsigned n) const { return sticks_[n][2]; }$/;"	f	class:molkern::Rotamer_
get	include/molkern/forcefield/_rotamer.h	/^		unsigned get(_I2T<ROTAMER_EXT_ATOM_>, unsigned n) const { return sticks_[n][0]; }$/;"	f	class:molkern::Rotamer_
get	include/molkern/forcefield/_rotamer.h	/^		unsigned get(_I2T<ROTAMER_INT_ATOM_>, unsigned n) const { return sticks_[n][1]; }$/;"	f	class:molkern::Rotamer_
get_angle	include/prgkern/_blas1.h	/^	INLINE T get_angle(unsigned n, const T *a, const T *b)$/;"	f	namespace:prgkern
get_angle	include/prgkern/_v3dense.h	/^	INLINE T get_angle(const vdense_<N, T> &a, const vdense_<N, T> &b)$/;"	f	namespace:prgkern
get_contacts	include/molkern/forcefield/_residue.h	/^		unsigned get_contacts(int *contacts) const$/;"	f	struct:molkern::__ResidueAtomdata
get_data	include/molkern/forcefield/_forcefield.h	/^		bool get_data(_ParamA *param, const _IndexA &ndx) const$/;"	f	class:molkern::__Forcefield
get_data	include/molkern/forcefield/_forcefield.h	/^		bool get_data(_ParamB *param, const _IndexB &ndx) const$/;"	f	class:molkern::__Forcefield
get_data	include/molkern/forcefield/_forcefield.h	/^		bool get_data(_ParamD *param, const _IndexD &ndx) const$/;"	f	class:molkern::__Forcefield
get_data	include/molkern/forcefield/_forcefield.h	/^		bool get_data(_ParamS *param, const _IndexS &ndx) const$/;"	f	class:molkern::__Forcefield
get_data	include/molkern/forcefield/_forcefield.h	/^		bool get_data(_ParamT *param, const _IndexT &ndx) const$/;"	f	class:molkern::__Forcefield
get_data	include/molkern/forcefield/_residome.h	/^		const _Residue *get_data(const std::string &name) const$/;"	f	class:molkern::basic_residome_
get_data	include/molkern/forcefield/_residue.h	/^		const __ResidueAtomdata *get_data(const char *name) const$/;"	f	class:molkern::basic_residue_
get_data	include/molkern/forcefield/_residue.h	/^		const __ResidueAtomdata *get_data(int n) const$/;"	f	class:molkern::basic_residue_
get_data__	include/molkern/forcefield/_forcefield.h	/^		bool get_data__(_Param *param, const _Index &ndx,$/;"	f	class:molkern::__Forcefield
get_data_ndx	include/molkern/forcefield/_forcefield.h	/^		int get_data_ndx(_I2T<ATOM_>, const _IndexT &ndx) const$/;"	f	class:molkern::__Forcefield
get_data_ndx	include/molkern/forcefield/_residue.h	/^		int get_data_ndx(const _Index &ndx) const$/;"	f	class:molkern::basic_residue_
get_data_ndx__	include/molkern/forcefield/_forcefield.h	/^		int get_data_ndx__(const _Index &ndx,$/;"	f	class:molkern::__Forcefield
get_data_ndx__	include/molkern/forcefield/_residome.h	/^		const _Residue *get_data_ndx__(const std::string &name) const$/;"	f	class:molkern::basic_residome_
get_equivalent	include/molkern/forcefield/_residome_amber.h	/^		std::string get_equivalent(_I2T<PDB_RESIDUE_NAME_>,$/;"	f	class:molkern::Residome_
get_equivalent	include/molkern/forcefield/_residome_amber.h	/^		std::string get_equivalent(_I2T<RESIDUE_>, const std::string &residue,$/;"	f	class:molkern::Residome_
get_equivalent_data	include/molkern/forcefield/_forcefield.h	/^	::get_equivalent_data(_ParamA *param, const _IndexA &ndx) const$/;"	f	class:molkern::__Forcefield
get_equivalent_data	include/molkern/forcefield/_forcefield.h	/^	::get_equivalent_data(_ParamB *param, const _IndexB &ndx) const$/;"	f	class:molkern::__Forcefield
get_equivalent_data	include/molkern/forcefield/_forcefield.h	/^	::get_equivalent_data(_ParamD *param, const _IndexD &ndx) const$/;"	f	class:molkern::__Forcefield
get_gonnet_pair	include/molkern/complex/_region.h	/^		const std::pair<unsigned, real_t> *get_gonnet_pair(unsigned direction) const$/;"	f	class:molkern::Node_
get_neigbours	include/molkern/complex/_region.h	/^		unsigned get_neigbours(_B2T< NO_PERIODIC_>, unsigned *neigs) const$/;"	f	class:molkern::Node_
get_neigbours	include/molkern/complex/_region.h	/^		unsigned get_neigbours(_B2T<YES_PERIODIC_>, unsigned *neigs) const$/;"	f	class:molkern::Node_
get_neighbor	include/molkern/complex/_region.h	/^		int get_neighbor(unsigned direction) const$/;"	f	class:molkern::Node_
get_scale	include/molkern/forcefield/_forcefield_amber.h	/^		real_t get_scale(_I2T<COUL14_>) const { return AMBER_SCALE_COUL14; }$/;"	f	class:molkern::Forcefield_
get_scale	include/molkern/forcefield/_forcefield_amber.h	/^		real_t get_scale(_I2T<VDW14_>) const { return AMBER_SCALE_VDW14; }$/;"	f	class:molkern::Forcefield_
get_short_name	include/molkern/forcefield/_residome_amber.h	/^		std::string get_short_name(_I2T<RESIDUE_>, const std::string &residue) const$/;"	f	class:molkern::Residome_
get_union	include/prgkern/_box.h	/^	INLINE void get_union(Box_<N, T> &box, const Box_<N, T> &b1, const Box_<N, T> &b2)$/;"	f	namespace:prgkern
getline	include/prgkern/_os.h	/^	INLINE void getline(std::istream &file, char* buffer,$/;"	f	namespace:prgkern
gk__	include/prgkern/_minimize_lbfgs.h	/^		_Vector gk__; \/\/ previous grad(k-1)$/;"	m	class:prgkern::Updater
global_compress_factor	src/__moldefs.cpp	/^	real_t global_compress_factor;$/;"	m	namespace:molkern	file:
global_model_time	src/__moldefs.cpp	/^	model_time_t global_model_time; \/\/ счетчик шагов динамики (текущее время динамики)$/;"	m	namespace:molkern	file:
global_pair	src/__moldefs.cpp	/^	long long unsigned global_pair=0;$/;"	m	namespace:molkern	file:
global_rskin_width	src/__moldefs.cpp	/^	real_t global_rskin_width;$/;"	m	namespace:molkern	file:
global_thread_count	src/__moldefs.cpp	/^	unsigned global_thread_count; \/\/ число запущенных процессов$/;"	m	namespace:molkern	file:
gonnet_coefs	include/molkern/complex/_region.h	/^		const vecreal_<4, real_t> gonnet_coefs[14] =$/;"	m	namespace:molkern
group_elems_	include/molkern/complex/_verlet.h	/^			unsigned group_elems_[MAX_GROUP_ELEM]; \/\/ объединяемые в группу ряды таблицы$/;"	m	struct:molkern::_Verlet_table::Group_
gtol	include/molkern/__config.h	/^		real_t gtol; \/\/ минимальное значение изменения силы, обрывающее оптимизацию$/;"	m	class:molkern::Configure
gtol	include/molkern/__config.h	/^		real_t gtol;$/;"	m	struct:molkern::Descriptor_
gv_	include/molkern/complex/_region.h	/^		Gonnet_vector gv_[14];$/;"	m	class:molkern::Node_
h_	include/molkern/complex/_region.h	/^		real_t h_, _1h_;  \/\/ прямой и обратный шаг ячейки = 1 \/ h$/;"	m	class:molkern::Region_
h_	include/prgkern/_mesh.h	/^		_Real h_, _1h_; \/\/ шаг и обратный шаг сетки$/;"	m	class:prgkern::Mesh_
h_	include/prgkern/_stencil.h	/^		T h_; \/\/\/< шаг (под)сетки для каждого направления$/;"	m	class:prgkern::Stencil_
has_basic_residue_	include/molkern/forcefield/_residome_amber.h	/^		bool has_basic_residue_(const std::string &name) const$/;"	f	class:molkern::Residome_
has_connects	include/molkern/forcefield/_residue.h	/^		bool has_connects() const { return has_connects_; }$/;"	f	class:molkern::basic_residue_
has_connects	include/molkern/forcefield/_residue_amber.h	/^		bool has_connects() const$/;"	f	struct:molkern::Params
has_connects_	include/molkern/forcefield/_residue.h	/^		bool has_connects_;$/;"	m	class:molkern::basic_residue_
has_contact	include/molkern/forcefield/_atomdata.h	/^	INLINE bool has_contact(unsigned na, unsigned nb, unsigned ta, unsigned tb)$/;"	f	namespace:molkern
has_external_connects	include/molkern/forcefield/_residue.h	/^		bool has_external_connects() const { return has_external_connects_; }$/;"	f	class:molkern::basic_residue_
has_external_connects_	include/molkern/forcefield/_residue.h	/^		bool has_external_connects_;$/;"	m	class:molkern::basic_residue_
has_residue	include/molkern/forcefield/_residome.h	/^		bool has_residue(const std::string &name) const$/;"	f	class:molkern::basic_residome_
has_to_be_updated_	include/molkern/complex/_verlet.h	/^	::has_to_be_updated_() const$/;"	f	class:molkern::_Verlet_table
hash	include/molkern/complex/_region.h	/^		T1 hash; \/\/ хэш координат атома вдоль некоторого направления$/;"	m	struct:molkern::__LJAtom
i_	include/prgkern/_sse.h	/^		__m128i i_;$/;"	m	class:prgkern::vecint_
iceil	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> iceil(vecreal_<4, float> a)$/;"	f	namespace:prgkern
idum_	include/prgkern/_random.h	/^		long idum_;$/;"	m	class:prgkern::randgen
ifloor	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ifloor(vecreal_<4, float> a)$/;"	f	namespace:prgkern
ilog2	include/prgkern/_transforms.h	/^	INLINE unsigned ilog2(unsigned n)$/;"	f	namespace:prgkern
imagingx	include/molkern/forcefield/_residue_amber.h	/^			int imagingx;$/;"	m	struct:molkern::Params::__anon9
import_	include/prgkern/_transforms.h	/^		void import_(const _Real *vi)$/;"	f	class:prgkern::Dfft
import_	include/prgkern/_transforms.h	/^		void import_(const std::complex<_Real> *vi)$/;"	f	class:prgkern::Dfft
import_	include/prgkern/_transforms.h	/^		void import_(const vdense_<2, std::complex<_Real> > *vi)$/;"	f	class:prgkern::Dfft
import_	include/prgkern/_transforms.h	/^		void import_(const vdense_<3, std::complex<_Real> > *vi)$/;"	f	class:prgkern::Dfft
import_	include/prgkern/_transforms.h	/^		void import_(const vdense_<4, std::complex<_Real> > *vi)$/;"	f	class:prgkern::Dfft
import_	include/prgkern/_transforms.h	/^		void import_(const vdense_<M, std::complex<_Real> > *vi)$/;"	f	class:prgkern::Dfft
impulse_swap	include/molkern/complex/_mdynamics.h	/^	INLINE void impulse_swap(real_t m1, real_t &v1, real_t m2, real_t &v2)$/;"	f	namespace:molkern
impulse_swap	include/molkern/complex/_mdynamics.h	/^	INLINE void impulse_swap(vdense_<N, real_t> R, real_t sigma, real_t dt,$/;"	f	namespace:molkern
inc_interval_	include/prgkern/_minimize.h	/^		int inc_interval_(bool find_minimum, T &beta, T &f0, T &g0, T &xa, T &fa, T &ga, T &xb, T &fb, T &gb,$/;"	f	class:prgkern::Line_minimizer_
inc_interval_	include/prgkern/_minimize_round.h	/^		int inc_interval_(T &beta, T &f0, T &g0, T &xa, T &fa, T &ga, T &xb, T &fb, T &gb,$/;"	f	class:prgkern::Round_minimizer_
indent	include/prgkern/_pproc.h	/^		std::string indent() const$/;"	f	class:prgkern::Guard_
index	include/molkern/complex/_region.h	/^		_Index index() const { return ndx_; }$/;"	f	class:molkern::Node_
index3	include/molkern/complex/_region.h	/^		_Index index3(unsigned pos) const$/;"	f	class:molkern::Region_
index_	include/prgkern/_index.h	/^		index_() { clear(); }$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0) { clear(); ndx_[0] = i0; }$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1, T i2)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1, T i2, T i3)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1, T i2, T i3, T i4)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1, T i2, T i3, T i4, T i5)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(T i0, T i1, T i2, T i3, T i4, T i5, T i6)$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^		index_(const index_ &ndx) { ::memcpy(this, &ndx, sizeof(ndx)); }$/;"	f	class:prgkern::index_
index_	include/prgkern/_index.h	/^	class index_$/;"	c	namespace:prgkern
index_cast_	include/prgkern/_index.h	/^		index_cast_() {}$/;"	f	class:prgkern::index_cast_
index_cast_	include/prgkern/_index.h	/^		index_cast_(const _Index &bottom, const _Index &up) : b_(bottom), s_(up - bottom) {}$/;"	f	class:prgkern::index_cast_
index_cast_	include/prgkern/_index.h	/^		index_cast_(const _Index &up) : b_(0), s_(up) {}$/;"	f	class:prgkern::index_cast_
index_cast_	include/prgkern/_index.h	/^		index_cast_(const index_cast_ &c) : b_(c.b_), s_(c.s_) {}$/;"	f	class:prgkern::index_cast_
index_cast_	include/prgkern/_index.h	/^	template <unsigned N> class index_cast_$/;"	c	namespace:prgkern
index_type	include/molkern/complex/_region.h	/^		typedef _Index                          index_type;$/;"	t	class:molkern::Region_
index_type	include/molkern/forcefield/_bond.h	/^		typedef index_<2>  index_type;$/;"	t	struct:molkern::Bond_
index_type	include/molkern/forcefield/_fparams.h	/^		typedef ffindex1 index_type;$/;"	t	struct:molkern::Params
index_type	include/molkern/forcefield/_fparams.h	/^		typedef ffindex2 index_type;$/;"	t	struct:molkern::Params
index_type	include/molkern/forcefield/_fparams.h	/^		typedef ffindex3 index_type;$/;"	t	struct:molkern::Params
index_type	include/molkern/forcefield/_fparams.h	/^		typedef ffindex4 index_type;$/;"	t	struct:molkern::Params
index_type	include/molkern/forcefield/_residue.h	/^		typedef _Index index_type;$/;"	t	class:molkern::basic_residue_
index_type	include/molkern/forcefield/_residue.h	/^		typedef fstring index_type;$/;"	t	struct:molkern::__ResidueAtomdata
index_type	include/molkern/forcefield/_residue_amber.h	/^		typedef std::string index_type; \/\/ residue name$/;"	t	class:molkern::Residue_
index_type	include/molkern/forcefield/_residue_amber.h	/^		typedef std::string index_type; \/\/ residue name$/;"	t	struct:molkern::Params
index_type	include/prgkern/_mesh.h	/^		typedef _Index  index_type;$/;"	t	class:prgkern::Mesh_
infinity	include/prgkern/_math.h	/^	template <typename T> struct infinity$/;"	s	namespace:prgkern
init	include/molkern/complex/_parallel.h	/^		void init(Object *object, unsigned thread_count=global_thread_count)$/;"	f	class:molkern::ParallWorker_
init	include/molkern/complex/_parallel.h	/^		void init(Object *object, unsigned thread_count=global_thread_count)$/;"	f	class:molkern::Parall_
init	include/molkern/complex/_region.h	/^		void init(_B2T<NO_PERIODIC_>, unsigned pos, const _Index &s)$/;"	f	class:molkern::Node_
init	include/molkern/complex/_region.h	/^		void init(_B2T<YES_PERIODIC_>, unsigned pos, const _Index &s)$/;"	f	class:molkern::Node_
init	include/molkern/forcefield/_residue_amber.h	/^	::init(const _Param &param)$/;"	f	class:molkern::Residue_
init	include/prgkern/_mesh.h	/^		unsigned init(_Real interaction_radius, index_<N, unsigned> sz, _Real h,$/;"	f	class:prgkern::Mesh_
init_	include/prgkern/_fstring.h	/^		void init_(const char *s)$/;"	f	class:prgkern::fstring_
insert	include/molkern/complex/_region.h	/^		bool insert(_B2T<NO_PERIODIC_>, const S &s, const vector_t &X)$/;"	f	class:molkern::Region_
insert	include/molkern/complex/_region.h	/^		bool insert(_B2T<YES_PERIODIC_>, const S &s, const vector_t &X)$/;"	f	class:molkern::Region_
insert	include/molkern/complex/_region.h	/^		bool insert(const S &s, const region_vector_t &X)$/;"	f	class:molkern::Region_
insert	include/molkern/complex/_region.h	/^		void insert(const S &s, const vector_t &X, unsigned i=0)$/;"	f	class:molkern::Node_
insert	include/molkern/complex/_region.h	/^		void insert(const S &s, unsigned i=0)$/;"	f	class:molkern::Node_
insert	include/molkern/complex/_region.h	/^		void insert(real_t hash) { push_back(_Pair(size(), hash)); }$/;"	f	struct:molkern::Gonnet_vector
insert	include/prgkern/_iterator.h	/^		void insert(T *arr, unsigned count)$/;"	f	class:prgkern::piecewise_vector
insert	include/prgkern/_mesh.h	/^		void insert(_Real *fn, const _Point3 &X, _Real s)$/;"	f	class:prgkern::Mesh_
insert	include/prgkern/_stencil.h	/^		void insert(S *arr, unsigned inc, const C &ndxcast, const _Index &ndx, S value) const$/;"	f	class:prgkern::Stencil_
insert	include/prgkern/_stencil.h	/^		void insert(T *arr, unsigned inc, const C &ndxcast,$/;"	f	class:prgkern::Stencil_
insert	include/prgkern/_stencil.h	/^	INLINE void insert(T *arr_to, unsigned inc_to, const C &ndxcast_to, const index_<3, int> &ndx_to,$/;"	f	namespace:prgkern
insert	include/prgkern/_stencil.h	/^	INLINE void insert(const Stencil_<3, N, T> &stencil, T *arr_to, unsigned inc_to, const C &ndxcast_to,$/;"	f	namespace:prgkern
insert_	include/molkern/complex/_region.h	/^	::insert_(const S &s, const region_vector_t &X__)$/;"	f	class:molkern::Region_
insert_data	include/molkern/complex/_complex.h	/^			unsigned_t insert_data; \/\/\/< тип вставки атома$/;"	m	struct:molkern::Complex_::_Atom
insert_data	include/molkern/complex/_complex.h	/^			unsigned_t insert_data; \/\/\/< тип вставки атома$/;"	m	struct:molkern::Complex_::_LJAtom
insert_data	include/molkern/complex/_region.h	/^		T2 insert_data; \/\/ тип вставки атома$/;"	m	struct:molkern::__LJAtom
insert_data	include/molkern/forcefield/_atomdata.h	/^		unsigned_t insert_data; \/\/ тип вставки$/;"	m	struct:molkern::Atomdata_
insert_stick	include/molkern/forcefield/_rotamer.h	/^		void insert_stick(unsigned i1, unsigned i2, unsigned i3)$/;"	f	class:molkern::Rotamer_
insert_to_internal_net_	include/prgkern/_stencil.h	/^		void insert_to_internal_net_(const _Vector3 &X, T value) const$/;"	f	class:prgkern::Stencil_
integral	include/prgkern/_math.h	/^	T integral(T c0, T a, T b) { return c0 * (b - a); }$/;"	f	namespace:prgkern
integral	include/prgkern/_math.h	/^	T integral(T c1, T c0, T a, T b)$/;"	f	namespace:prgkern
integral	include/prgkern/_math.h	/^	T integral(T c2, T c1, T c0, T a, T b)$/;"	f	namespace:prgkern
integral	include/prgkern/_math.h	/^	T integral(T c3, T c2, T c1, T c0, T a, T b)$/;"	f	namespace:prgkern
integration_time	include/molkern/__config.h	/^		unsigned integration_time; \/\/ шаг динамики (fs)$/;"	m	class:molkern::Configure
integration_time	include/molkern/__config.h	/^		unsigned integration_time; \/\/ шаг интегрирования$/;"	m	struct:molkern::Descriptor_
interaction_radius	include/molkern/forcefield/_interactions.h	/^		static real_t interaction_radius() { return rcutoff_; }$/;"	f	struct:molkern::Interaction_
invert	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<3, 3, T> invert(const mdense_<3, 3, T> &u)$/;"	f	namespace:prgkern
invert	include/prgkern/_mdense.h	/^	INLINE void invert(mdense_<UNLIMITED_, UNLIMITED_, T> &U)$/;"	f	namespace:prgkern
is_edge	include/molkern/complex/_region.h	/^		bool is_edge(unsigned pos1, unsigned pos2) const$/;"	f	class:molkern::Region_
is_hydrogen	include/molkern/forcefield/_atomdata.h	/^		bool is_hydrogen() const$/;"	f	struct:molkern::Atomdata_
is_included	include/prgkern/_box.h	/^		bool is_included(const _Vector &X) const$/;"	f	class:prgkern::Box_
is_pseudo	include/molkern/forcefield/_atomdata.h	/^		bool is_pseudo() const$/;"	f	struct:molkern::Atomdata_
is_random	include/molkern/__config.h	/^		bool is_random; \/\/ использование случайного позиционирования$/;"	m	struct:molkern::Descriptor_
is_solution	include/molkern/complex/_archetype.h	/^		bool is_solution() const { return is_solution_; }$/;"	f	class:molkern::Archetype_
is_solution_	include/molkern/complex/_archetype.h	/^		bool is_solution_;              \/\/ признак раствора$/;"	m	class:molkern::Archetype_
isize	include/prgkern/_transforms.h	/^		unsigned isize() const { return fft_size_; }$/;"	f	class:prgkern::Dfft
isspace	include/prgkern/_string.h	/^	INLINE bool isspace(const std::string &s) { return ba::trim_copy(s).empty(); }$/;"	f	namespace:prgkern
it_	include/prgkern/_iterator.h	/^		Iterator it_; \/\/ индексный итератор$/;"	m	class:prgkern::array_iterator
it_	include/prgkern/_iterator.h	/^		Iterator it_; \/\/ индексный итератор$/;"	m	class:prgkern::const_array_iterator
it_	include/prgkern/_iterator.h	/^		Iterator it_; \/\/ индексный итератор$/;"	m	class:prgkern::sub_iterator
items_	include/molkern/complex/_region.h	/^		std::vector<S> items_[8]; \/\/ массив элементов ячейки$/;"	m	class:molkern::Node_
iterations	include/molkern/__config.h	/^		int iterations; \/\/ число итераций оптимизации геометрии$/;"	m	class:molkern::Configure
iterator	include/molkern/complex/_region.h	/^		typedef typename _Node::iterator        iterator;$/;"	t	class:molkern::Region_
iterator	include/molkern/complex/_region.h	/^		typedef typename std::vector<S>::iterator        iterator;$/;"	t	class:molkern::Node_
iterator	include/prgkern/_dense.h	/^		typedef typename _Base::iterator        iterator;$/;"	t	class:prgkern::basic_dense_
iterator	include/prgkern/_iterator.h	/^		typedef iterator_  iterator;$/;"	t	class:prgkern::piecewise_vector
iterator_	include/prgkern/_iterator.h	/^			iterator_() : pieces_(0), count_(0), cur_piece_(0), elem_(0) {}$/;"	f	class:prgkern::piecewise_vector::iterator_
iterator_	include/prgkern/_iterator.h	/^			iterator_(_piece *p, unsigned count) : pieces_(p), count_(count), cur_piece_(p), elem_(0)$/;"	f	class:prgkern::piecewise_vector::iterator_
iterator_	include/prgkern/_iterator.h	/^			iterator_(const iterator_ &it) : pieces_(it.pieces_), count_(it.count_),$/;"	f	class:prgkern::piecewise_vector::iterator_
iterator_	include/prgkern/_iterator.h	/^		class iterator_$/;"	c	class:prgkern::piecewise_vector
itoa	include/prgkern/_string.h	/^	INLINE std::string itoa(int v)    { return make_string(v); }$/;"	f	namespace:prgkern
k_	include/prgkern/_minimize_lbfgs.h	/^		int k_; \/\/ iterations number (update counter)$/;"	m	class:prgkern::Updater
ke	include/molkern/forcefield/_fparams.h	/^		real_t ke;  \/\/ E''(q0_)$/;"	m	struct:molkern::Params
key_type	include/molkern/complex/_region.h	/^		typedef _Key                            key_type;$/;"	t	class:molkern::Region_
kinetic_energy	include/molkern/complex/_ensemble.h	/^	inline _E(real_t) kinetic_energy(_Molecule *molecule)$/;"	f	namespace:molkern
length	include/prgkern/_box.h	/^		T length(unsigned i) const { assert(_LT(i, N)); return u_[i] - d_[i]; }$/;"	f	class:prgkern::Box_
length	include/prgkern/_box.h	/^		_Vector length() const { return u_ - d_; }$/;"	f	class:prgkern::Box_
length	include/prgkern/_v3dense.h	/^		T length() const { return sqrt(length2()); }$/;"	f	class:prgkern::vdense_
length	include/prgkern/_vdense.h	/^		T length() const { return sqrt(length2()); }$/;"	f	class:prgkern::vdense_
length2	include/prgkern/_v3dense.h	/^		T length2() const$/;"	f	class:prgkern::vdense_
length2	include/prgkern/_vdense.h	/^		T length2() const { return prgkern::scalar_product(_N, &(*this)[0], &(*this)[0]); }$/;"	f	class:prgkern::vdense_
less_	include/prgkern/_type.h	/^	class less_$/;"	c	namespace:prgkern
less_than_	include/prgkern/_type.h	/^		less_than_(const _T *f) : f_(f) {}$/;"	f	class:prgkern::less_than_
less_than_	include/prgkern/_type.h	/^	class less_than_$/;"	c	namespace:prgkern
linear_interpolation	include/prgkern/_math.h	/^	INLINE _Real linear_interpolation(_Real x0, _Real y0, _Real z0,$/;"	f	namespace:prgkern
linear_interpolation	include/prgkern/_math.h	/^	INLINE _Real linear_interpolation(_Real x0, _Real y0,$/;"	f	namespace:prgkern
linear_interpolation	include/prgkern/_math.h	/^	INLINE void linear_interpolation(unsigned n, _Real *f, _Real x0, _Real y0, _Real z0,$/;"	f	namespace:prgkern
linear_interpolation	include/prgkern/_math.h	/^	INLINE void linear_interpolation(unsigned n, _Real *f, _Real x0, _Real y0,$/;"	f	namespace:prgkern
ljatom_type	include/molkern/complex/_complex.h	/^		typedef _LJAtom         ljatom_type;$/;"	t	class:molkern::Complex_
load	include/molkern/complex/_archetype.h	/^	::load(_I2T<FORMAT_BMM_>, std::ifstream &file, char)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_archetype.h	/^	::load(_I2T<FORMAT_HIN_>, std::ifstream &file, char)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_archetype.h	/^	::load(_I2T<FORMAT_MOL2_>, std::ifstream &file, char)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_archetype.h	/^	::load(_I2T<FORMAT_PDB_>, std::ifstream &file, char altpos)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_archetype.h	/^	::load(_I2T<WATER_>, const std::string &solution)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_archetype.h	/^	::load(const std::string &filename, char altpos)$/;"	f	class:molkern::Archetype_
load	include/molkern/complex/_complex.h	/^	::load(_I2T<MOLECULE_>, const std::string &filename, unsigned freedom_type, unsigned count,$/;"	f	class:molkern::Complex_
load	include/molkern/complex/_complex.h	/^	::load(_I2T<WATER_>, const std::string &solution, unsigned freedom_type)$/;"	f	class:molkern::Complex_
load	include/molkern/forcefield/_forcefield_amber.h	/^	inline bool Forcefield_<TEMPLATE_ARG>::load(const std::string &filename)$/;"	f	class:molkern::Forcefield_
load	include/molkern/forcefield/_residome_amber.h	/^	::load(const std::string &filename)$/;"	f	class:molkern::Residome_
load	include/molkern/forcefield/_residue_amber.h	/^	::load(std::ifstream &file)$/;"	f	class:molkern::Params
load	include/prgkern/_sse.h	/^		void load(const float *f) { f_ = _mm_loadu_ps(f); }$/;"	f	class:prgkern::vecreal_
load	include/prgkern/_sse.h	/^		void load(const int *i) { i_ = _mm_loadu_si128((__m128i*)i); }$/;"	f	class:prgkern::vecint_
load_dir	include/molkern/forcefield/_forcefield_amber.h	/^	::load_dir(const std::string &dirname)$/;"	f	class:molkern::Forcefield_
load_dir	include/molkern/forcefield/_residome_amber.h	/^	::load_dir(const std::string &dirname, const std::string &fileregex)$/;"	f	class:molkern::Residome_
locate_zero_derivation_	include/prgkern/_minimize.h	/^		void locate_zero_derivation_(bool find_minimum, T &beta, T &f0, T &g0, T &xa, T &fa, T &ga, T &xb, T &fb, T &gb,$/;"	f	class:prgkern::Line_minimizer_
locate_zero_derivation_	include/prgkern/_minimize_round.h	/^		void locate_zero_derivation_(T &beta, T &f0, T &g0, T &xa, T &fa, T &ga, T &xb, T &fb, T &gb,$/;"	f	class:prgkern::Round_minimizer_
ltrim	include/prgkern/_string.h	/^	INLINE std::string ltrim(const std::string &s) { return ba::trim_left_copy(s); }$/;"	f	namespace:prgkern
ltrim	include/prgkern/_string.h	/^	INLINE void ltrim(std::string &s) { ba::trim_left(s); }$/;"	f	namespace:prgkern
m	include/molkern/__config.h	/^		int m; \/\/ число запоминаемых последних результатов в опртимизации$/;"	m	class:molkern::Configure
m	include/molkern/__config.h	/^		int m;$/;"	m	struct:molkern::Descriptor_
m_	include/prgkern/_minimize_lbfgs.h	/^		unsigned m_; \/\/ the subiterations limit$/;"	m	class:prgkern::Updater
main	src/bmmkern.cpp	/^int main(int argc, char *argv[])$/;"	f
make	include/molkern/complex/_complex.h	/^			void make(const _Atom &atom)$/;"	f	struct:molkern::Complex_::_LJAtom
make	include/molkern/complex/_complex.h	/^			void make(const _Atomdata &atomdata, unsigned_t atom_id)$/;"	f	struct:molkern::Complex_::_Atom
make_	include/prgkern/_random.h	/^		T make_()$/;"	f	class:prgkern::randgen
make_direction_code	include/molkern/complex/_region.h	/^		static unsigned make_direction_code(const vector_t &d)$/;"	f	struct:molkern::Gonnet_vector
make_direction_shift	include/molkern/complex/_region.h	/^		static real_t make_direction_shift(const vector_t &d)$/;"	f	struct:molkern::Gonnet_vector
make_dirname	include/prgkern/_os.h	/^	INLINE std::string make_dirname(const std::string &name)$/;"	f	namespace:prgkern
make_equivalent_data_	include/molkern/forcefield/_forcefield_amber.h	/^		void make_equivalent_data_(_Base::_ParamE*, unsigned start_pos=0)$/;"	f	class:molkern::Forcefield_
make_free	include/molkern/complex/_molecule.h	/^	::make_free(_Iterator it, _Iterator ite)$/;"	f	class:molkern::Molecule_
make_gonnet_ordering	include/molkern/complex/_region.h	/^		void make_gonnet_ordering()$/;"	f	class:molkern::Node_
make_hash	include/molkern/complex/_region.h	/^		static real_t make_hash(unsigned direction, vecreal_<4, real_t> x)$/;"	f	struct:molkern::Gonnet_vector
make_index	include/molkern/complex/_region.h	/^	INLINE index_<3, unsigned> make_index(unsigned pos, index_<3, unsigned> s)$/;"	f	namespace:molkern
make_insert_image	include/molkern/complex/_region.h	/^		region_vector_t make_insert_image(const vector_t &X) const$/;"	f	class:molkern::Region_
make_insert_image_	include/molkern/complex/_region.h	/^		vector_t make_insert_image_(const region_vector_t &x)$/;"	f	class:molkern::Region_
make_insert_index	include/molkern/complex/_region.h	/^		unsigned make_insert_index(const region_key_t &key) const$/;"	f	class:molkern::Region_
make_insert_index	include/molkern/complex/_region.h	/^		unsigned make_insert_index(const region_vector_t &X) const$/;"	f	class:molkern::Region_
make_insert_index3	include/molkern/complex/_region.h	/^		region_key_t make_insert_index3(const region_vector_t &X) const$/;"	f	class:molkern::Region_
make_iterator	include/molkern/complex/_archetype.h	/^		const_array_iterator<_Atomdata, _Iterator> make_iterator(_Iterator it) const$/;"	f	class:molkern::Archetype_
make_iterator	include/molkern/complex/_complex.h	/^		array_iterator<_Atom, _Iterator> make_iterator(_Iterator it)$/;"	f	class:molkern::Complex_
make_iterator	include/molkern/complex/_complex.h	/^		const_array_iterator<_Atom, _Iterator> make_iterator(_Iterator it) const$/;"	f	class:molkern::Complex_
make_multi_index_	include/prgkern/_index.h	/^		_Index1 make_multi_index_(const _Index1&, unsigned n) const$/;"	f	class:prgkern::index_cast_
make_multi_index_	include/prgkern/_index.h	/^		_Index2 make_multi_index_(const _Index2&, unsigned n) const$/;"	f	class:prgkern::index_cast_
make_multi_index_	include/prgkern/_index.h	/^		_Index3 make_multi_index_(const _Index3&, unsigned n) const$/;"	f	class:prgkern::index_cast_
make_nearest_image_vector	include/molkern/complex/_region.h	/^		void make_nearest_image_vector(T &dx, T &dy, T &dz) const$/;"	f	class:molkern::Region_
make_object	include/molkern/forcefield/_atomdata.h	/^	INLINE void make_object(_I2T<FORMAT_BMM_>, Atomdata_ &atomdata,$/;"	f	namespace:molkern
make_object	include/molkern/forcefield/_atomdata.h	/^	INLINE void make_object(_I2T<FORMAT_MOL2_>, Atomdata_ &atomdata,$/;"	f	namespace:molkern
make_object	include/molkern/forcefield/_atomdata.h	/^	inline void make_object(_I2T<FORMAT_HIN_>, Atomdata_ &atomdata,$/;"	f	namespace:molkern
make_object	include/molkern/forcefield/_atomdata.h	/^	inline void make_object(_I2T<FORMAT_PDB_>, Atomdata_ &atomdata,$/;"	f	namespace:molkern
make_ordering	include/molkern/complex/_region.h	/^		void make_ordering() { std::sort(begin(), end(), less_<_Pair, real_t, &_Pair::second>());	}$/;"	f	struct:molkern::Gonnet_vector
make_piecewise_vector	include/molkern/complex/_region.h	/^		void make_piecewise_vector(piecewise_vector<T> *atoms, const _Key &key, unsigned pos) const$/;"	f	class:molkern::Region_
make_pos	include/molkern/complex/_region.h	/^	INLINE unsigned make_pos(index_<3, int> n, index_<3, unsigned> s)$/;"	f	namespace:molkern
make_pos	include/molkern/complex/_region.h	/^	INLINE unsigned make_pos(index_<3, unsigned> n, index_<3, unsigned> s)$/;"	f	namespace:molkern
make_rotate0_matrix	include/prgkern/_rotator.h	/^	inline void make_rotate0_matrix(mdense_<3, 3, T> *m, const vdense_<3, T> &angle)$/;"	f	namespace:prgkern
make_single_index_	include/prgkern/_index.h	/^		unsigned make_single_index_(const _Index1 &ndx) const$/;"	f	class:prgkern::index_cast_
make_single_index_	include/prgkern/_index.h	/^		unsigned make_single_index_(const _Index2 &ndx) const$/;"	f	class:prgkern::index_cast_
make_single_index_	include/prgkern/_index.h	/^		unsigned make_single_index_(const _Index3 &ndx) const$/;"	f	class:prgkern::index_cast_
make_string	include/molkern/__moldefs.h	/^	INLINE std::string make_string(model_time_t)$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atom.h	/^	inline const char *make_string(_I2T<FORMAT_BMM_>, char *s,$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atom.h	/^	inline const char *make_string(_I2T<FORMAT_HIN_>, char *s,$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atom.h	/^	inline const char *make_string(_I2T<FORMAT_MOL2_>, char *s,$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atom.h	/^	inline const char *make_string(_I2T<FORMAT_PDB_>, char *s,$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atom.h	/^	inline std::string make_string(const _Atom &atom, const Atomdata_ &atomdata)$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atomdata.h	/^	inline std::string make_string(_I2T<FORMAT_BMM_>, const Atomdata_ &)$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atomdata.h	/^	inline std::string make_string(_I2T<FORMAT_HIN_>, const Atomdata_ &atomdata)$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atomdata.h	/^	inline std::string make_string(_I2T<FORMAT_PDB_>, const Atomdata_ &atomdata)$/;"	f	namespace:molkern
make_string	include/molkern/forcefield/_atomdata.h	/^	inline std::string make_string(const Atomdata_ &atomdata)$/;"	f	namespace:molkern
make_string	include/prgkern/_box.h	/^	INLINE std::string make_string(const Box_<N, T> &box)$/;"	f	namespace:prgkern
make_string	include/prgkern/_fstring.h	/^	INLINE std::string make_string(const char *format, const fstring &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_fstring.h	/^	INLINE std::string make_string(const fstring_<A> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_index.h	/^	INLINE std::string make_string(const index_<N, T> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_m3x3dense.h	/^	INLINE std::string make_string(const mdense_<N, N, T> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecbool_<1, int> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecbool_<4, int> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecint_<1, int> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecint_<4, int> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecreal_<1, float> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_sse.h	/^	INLINE std::string make_string(const vecreal_<4, float> &f)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(bool s) { return s ? _S("true"): _S("false"); }$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T1 v1, T2 v2)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T1 v1, T2 v2, T3 v3)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T1 v1, T2 v2, T3 v3, T4 v4)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *format, const std::string &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const char *s) { return std::string(s); }$/;"	f	namespace:prgkern
make_string	include/prgkern/_string.h	/^	INLINE std::string make_string(const std::string &s) { return s; }$/;"	f	namespace:prgkern
make_string	include/prgkern/_time.h	/^	INLINE std::string make_string(system_time_t tm)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<2, T> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<2, int> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<3, T> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<3, int> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<4, T> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_v3dense.h	/^	INLINE std::string make_string(const vdense_<4, int> &v)$/;"	f	namespace:prgkern
make_string	include/prgkern/_vdense.h	/^	INLINE std::string make_string(const vdense_<UNLIMITED_, T> &v)$/;"	f	namespace:prgkern
make_subgraphs	include/prgkern/_graph.h	/^	unsigned make_subgraphs(unsigned n, int *dest, _BondIterator first, _BondIterator last)$/;"	f	namespace:prgkern
make_term	include/molkern/forcefield/_residome_amber.h	/^		std::string make_term(char symbol, const std::string &name) const$/;"	f	class:molkern::Residome_
make_union	include/prgkern/_box.h	/^		Box_ &make_union(const Box_ &b)$/;"	f	class:prgkern::Box_
make_union	include/prgkern/_box.h	/^		Box_ &make_union(const _Vector &X)$/;"	f	class:prgkern::Box_
mass	include/molkern/complex/_thermostat.h	/^		_Real mass() const { return mass_; }$/;"	f	class:molkern::maxwell_distribution_
mass	include/molkern/forcefield/_atomdata.h	/^		real_t mass;$/;"	m	struct:molkern::Atomdata_
mass	include/molkern/forcefield/_fparams.h	/^		real_t mass; \/\/ effective mass of atom$/;"	m	struct:molkern::Params
mass	include/molkern/forcefield/_nuclear.h	/^		real_t mass;$/;"	m	struct:molkern::Nuclear
mass_	include/molkern/complex/_thermostat.h	/^		_Real mass_;$/;"	m	class:molkern::maxwell_distribution_
match	include/prgkern/_regex.h	/^		bool match(const std::string &s)$/;"	f	class:prgkern::RegEx
max	include/prgkern/_blas1.h	/^	INLINE float max(unsigned n, const float *x)$/;"	f	namespace:prgkern
max	include/prgkern/_math.h	/^		T min, max;$/;"	m	struct:prgkern::Range_
max	include/prgkern/_math.h	/^	template <typename T> INLINE T max(T t1, T t2, T t3)$/;"	f	namespace:prgkern
max	include/prgkern/_math.h	/^	template <typename T> INLINE T max(T t1, T t2, T t3, T t4)$/;"	f	namespace:prgkern
max	include/prgkern/_math.h	/^	template <typename T> INLINE T max(T t1, T t2, T t3, T t4, T t5)$/;"	f	namespace:prgkern
max	include/prgkern/_math.h	41;"	d
max	include/prgkern/_prgconfig.h	53;"	d
max	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> max(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_max_ps(a, b); }$/;"	f	namespace:prgkern
max	include/prgkern/_v3dense.h	/^	INLINE vdense_<N, T> max(const vdense_<N, T> &v1, const vdense_<N, T> &v2)$/;"	f	namespace:prgkern
max_A	include/molkern/forcefield/_residue.h	/^		static const unsigned max_A = 3; \/\/ предел числа связей с НЕ-водородами$/;"	m	struct:molkern::__ResidueAtomdata
max_H	include/molkern/forcefield/_residue.h	/^		static const unsigned max_H = 3; \/\/ предел числа связей с водородами$/;"	m	struct:molkern::__ResidueAtomdata
max_bond	include/molkern/forcefield/_atomdata.h	/^		static const int max_bond = MAX_ATOM_BOND;$/;"	m	struct:molkern::Atomdata_
max_difference	include/prgkern/_blas1.h	/^	INLINE T max_difference(unsigned n, const T *v1, const T *v2)$/;"	f	namespace:prgkern
max_proection	include/prgkern/_v3dense.h	/^	INLINE T max_proection(const vdense_<N, T> &v)$/;"	f	namespace:prgkern
maxabs	include/prgkern/_blas1.h	/^	INLINE T maxabs(unsigned n, const T *x)$/;"	f	namespace:prgkern
maxf	include/molkern/forcefield/_fparams.h	/^		static const int maxf = 4; \/\/ max count of subfuctions$/;"	m	struct:molkern::Params
maxfev	include/molkern/__config.h	/^		int maxfev; \/\/ максимально разрешенное число оценок энергии, обрывающее оптимизацию$/;"	m	class:molkern::Configure
maxfev	include/molkern/__config.h	/^		int maxfev;$/;"	m	struct:molkern::Descriptor_
maxhalt	include/molkern/__config.h	/^		int maxhalt; \/\/ параметр подтверждающий конец оптимизации$/;"	m	class:molkern::Configure
maxhalt	include/molkern/__config.h	/^		int maxhalt;$/;"	m	struct:molkern::Descriptor_
maximize	include/prgkern/_v3dense.h	/^	INLINE vdense_<N, T> maximize(const vdense_<N, T> &a1, const vdense_<N, T> &a2)$/;"	f	namespace:prgkern
maximize	include/prgkern/_v3dense.h	/^	INLINE void maximize(vdense_<N, T> &r, const vdense_<N, T> &a1, const vdense_<N, T> &a2)$/;"	f	namespace:prgkern
maxiter	include/molkern/__config.h	/^		int maxiter;$/;"	m	struct:molkern::Descriptor_
maxmin	include/prgkern/_math.h	/^	template <typename T> INLINE T maxmin(T t1, T t2, T t3)$/;"	f	namespace:prgkern
maxmin	include/prgkern/_math.h	/^	template <typename T> INLINE T maxmin(T t1, T t2, T t3, T t4)$/;"	f	namespace:prgkern
maxtype	include/prgkern/_type.h	/^	template <> struct maxtype<double, double> { typedef double type; };$/;"	s	namespace:prgkern
maxtype	include/prgkern/_type.h	/^	template <> struct maxtype<double, float> { typedef double type; };$/;"	s	namespace:prgkern
maxtype	include/prgkern/_type.h	/^	template <> struct maxtype<float, double> { typedef double type; };$/;"	s	namespace:prgkern
maxtype	include/prgkern/_type.h	/^	template <> struct maxtype<float, float> { typedef float type; };$/;"	s	namespace:prgkern
maxwell_distribution	include/molkern/complex/_thermostat.h	/^	typedef maxwell_distribution_<real_t>  maxwell_distribution;$/;"	t	namespace:molkern
maxwell_distribution_	include/molkern/complex/_thermostat.h	/^		explicit maxwell_distribution_(_Real mass, _Real temperature)$/;"	f	class:molkern::maxwell_distribution_
maxwell_distribution_	include/molkern/complex/_thermostat.h	/^	class maxwell_distribution_$/;"	c	namespace:molkern
maxwell_distribution_ensemble	include/molkern/complex/_thermostat.h	/^	typedef maxwell_distribution_ensemble_<>  maxwell_distribution_ensemble;$/;"	t	namespace:molkern
maxwell_distribution_ensemble_	include/molkern/complex/_thermostat.h	/^		maxwell_distribution_ensemble_(_Real temperature=300.) : temperature_(temperature) {}$/;"	f	class:molkern::maxwell_distribution_ensemble_
maxwell_distribution_ensemble_	include/molkern/complex/_thermostat.h	/^	class maxwell_distribution_ensemble_$/;"	c	namespace:molkern
mdense	include/prgkern/_minimize_lbfgs.h	/^		typedef mdense_<UNLIMITED_, UNLIMITED_, _Real>  mdense;$/;"	t	class:prgkern::Updater
mdense_	include/prgkern/_m3x3dense.h	/^		mdense_() { scalar_assign_equal((_I2T<N> *)0, (T)0, (T)0); }$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^		mdense_(const mdense_& v) { matrix_assign_equal((_I2T<N> *)0, v); }$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^		template <typename S> mdense_(S s) { scalar_assign_equal((_I2T<N> *)0, (T)s, (T)0); }$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^		template <typename S> mdense_(S s00, S s01, S s02, S s03, S s10, S s11, S s12, S s13,$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^		template <typename S> mdense_(S s00, S s01, S s02, S s10, S s11, S s12, S s20, S s21, S s22)$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^		template <typename S> mdense_(S s00, S s01, S s10, S s11)$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_m3x3dense.h	/^	class mdense_<N, N, T>$/;"	c	namespace:prgkern
mdense_	include/prgkern/_mdense.h	/^		mdense_(unsigned n1=0, unsigned n2=0) { resize(n1, n2); }$/;"	f	class:prgkern::mdense_
mdense_	include/prgkern/_mdense.h	/^	class mdense_<UNLIMITED_, UNLIMITED_, T> : protected basic_dense_<2, T>$/;"	c	namespace:prgkern
memcpy	include/prgkern/_v3dense.h	/^	INLINE void memcpy(T *to, const vdense_<N, T> &from)$/;"	f	namespace:prgkern
memcpy	include/prgkern/_v3dense.h	/^	INLINE void memcpy(vdense_<N, T> &to, const T *from)$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE _Integer memory_offset(const index_<1, _Integer> &ndx,$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE _Integer memory_offset(const index_<2, _Integer> &ndx,$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE _Integer memory_offset(const index_<3, _Integer> &ndx,$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE _Integer memory_offset(const index_<4, _Integer> &ndx,$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE index_<1, _Integer> memory_offset(unsigned n, const index_<1, _Integer> &sz)$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE index_<2, _Integer> memory_offset(unsigned n, const index_<2, _Integer> &sz)$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE index_<3, _Integer> memory_offset(unsigned n, const index_<3, _Integer> &sz)$/;"	f	namespace:prgkern
memory_offset	include/prgkern/_index.h	/^	INLINE index_<4, _Integer> memory_offset(unsigned n, const index_<4, _Integer> &sz)$/;"	f	namespace:prgkern
mesh_fftw_step	include/molkern/__config.h	/^		real_t mesh_fftw_step;$/;"	m	class:molkern::Configure
mesh_pots_step	include/molkern/__config.h	/^		real_t mesh_pots_step;$/;"	m	class:molkern::Configure
mesh_stat_step	include/molkern/__config.h	/^		real_t mesh_stat_step;$/;"	m	class:molkern::Configure
min	include/prgkern/_blas1.h	/^	INLINE float min(unsigned n, const float *x)$/;"	f	namespace:prgkern
min	include/prgkern/_math.h	/^		T min, max;$/;"	m	struct:prgkern::Range_
min	include/prgkern/_math.h	/^	template <typename T> INLINE T min(T t1, T t2, T t3)$/;"	f	namespace:prgkern
min	include/prgkern/_math.h	/^	template <typename T> INLINE T min(T t1, T t2, T t3, T t4)$/;"	f	namespace:prgkern
min	include/prgkern/_math.h	/^	template <typename T> INLINE T min(T t1, T t2, T t3, T t4, T t5)$/;"	f	namespace:prgkern
min	include/prgkern/_math.h	42;"	d
min	include/prgkern/_prgconfig.h	52;"	d
min	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> min(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_min_ps(a, b); }$/;"	f	namespace:prgkern
min	include/prgkern/_v3dense.h	/^	INLINE vdense_<N, T> min(const vdense_<N, T> &v1, const vdense_<N, T> &v2)$/;"	f	namespace:prgkern
minimize	include/prgkern/_v3dense.h	/^	INLINE vdense_<N, T> minimize(const vdense_<N, T> &a1, const vdense_<N, T> &a2)$/;"	f	namespace:prgkern
minimize	include/prgkern/_v3dense.h	/^	INLINE void minimize(vdense_<N, T> &r, const vdense_<N, T> &a1, const vdense_<N, T> &a2)$/;"	f	namespace:prgkern
minmax	include/prgkern/_math.h	/^	template <typename T> INLINE T minmax(T t1, T t2, T t3)$/;"	f	namespace:prgkern
minmax	include/prgkern/_math.h	/^	template <typename T> INLINE T minmax(T t1, T t2, T t3, T t4)$/;"	f	namespace:prgkern
mod	include/prgkern/_index.h	/^	INLINE index_<1,T> mod(const index_<1, T> &n, const index_<1, T> &k)$/;"	f	namespace:prgkern
mod	include/prgkern/_index.h	/^	INLINE index_<2,T> mod(const index_<2, T> &n, const index_<2, T> &k)$/;"	f	namespace:prgkern
mod	include/prgkern/_index.h	/^	INLINE index_<3,T> mod(const index_<3, T> &n, const index_<3, T> &k)$/;"	f	namespace:prgkern
mod	include/prgkern/_index.h	/^	INLINE index_<4,T> mod(const index_<4, T> &n, const index_<4, T> &k)$/;"	f	namespace:prgkern
mod	include/prgkern/_math.h	/^	INLINE double mod(double x, double m)$/;"	f	namespace:prgkern
mod	include/prgkern/_math.h	/^	INLINE float mod(float x, float m)$/;"	f	namespace:prgkern
mod	include/prgkern/_math.h	/^	INLINE long double mod(long double x, long double m)$/;"	f	namespace:prgkern
mod	include/prgkern/_math.h	/^	template <typename T> INLINE T mod(T x, T m)$/;"	f	namespace:prgkern
mode_	include/prgkern/_sse.h	/^		unsigned mode_;$/;"	m	struct:prgkern::round_mode_saver_
model_time_t	include/molkern/__moldefs.h	/^		model_time_t(unsigned t=0) : tm_(t) {}$/;"	f	struct:molkern::model_time_t
model_time_t	include/molkern/__moldefs.h	/^	struct model_time_t$/;"	s	namespace:molkern
molecules	include/molkern/__config.h	/^		std::vector<_S> molecules;$/;"	m	class:molkern::Configure
molecules_	include/molkern/complex/_complex.h	/^		std::vector<_Molecule*> molecules_;  \/\/ указатели на молекулы комплекса$/;"	m	class:molkern::Complex_
molkern	include/molkern/__config.h	/^namespace molkern$/;"	n
molkern	include/molkern/__moldefs.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_archetype.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_charge_dynamics.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_complex.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_ensemble.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_geom_tool.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_linkcell.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_mdynamics.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_molecule.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_optimize.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_parallel.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_phys_tool.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_protonization.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_region.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_thermostat.h	/^namespace molkern$/;"	n
molkern	include/molkern/complex/_verlet.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_1interactions.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_angle.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_atom.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_atomdata.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_bond.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_forcefield.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_forcefield_amber.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_fparams.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_interactions.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_nuclear.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_potential.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_residome.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_residome_amber.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_residue.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_residue_amber.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_rotamer.h	/^namespace molkern$/;"	n
molkern	include/molkern/forcefield/_torsion.h	/^namespace molkern$/;"	n
molkern	src/__moldefs.cpp	/^namespace molkern$/;"	n	file:
molname_	include/molkern/complex/_archetype.h	/^		std::string molname_;           \/\/ имя молекулы (модели)$/;"	m	class:molkern::Archetype_
move	include/molkern/complex/_geom_tool.h	/^	INLINE void move(Atom *atom, const __Atom *atom__, const vector_t &X,$/;"	f	namespace:molkern
move	include/molkern/complex/_geom_tool.h	/^	INLINE void move(Atom *atom, const vector_t &X, Iterator it, Iterator ite)$/;"	f	namespace:molkern
move	include/prgkern/_box.h	/^		Box_ &move(const _Vector &X)$/;"	f	class:prgkern::Box_
move_to	include/molkern/complex/_geom_tool.h	/^	INLINE void move_to(Atom *atom, const vector_t &X, Iterator it, Iterator ite)$/;"	f	namespace:molkern
moveto	include/prgkern/_box.h	/^		Box_ &moveto(const _Vector &X)$/;"	f	class:prgkern::Box_
msg_	include/prgkern/_pproc.h	/^		std::string msg_;$/;"	m	class:prgkern::Guard_
mult2	include/prgkern/_math.h	/^	INLINE unsigned mult2(unsigned s) { return s << 1; }$/;"	f	namespace:prgkern
mult2	include/prgkern/_math.h	/^	template <typename T> INLINE T mult2(T s) { return s + s; }$/;"	f	namespace:prgkern
multi_index_type	include/prgkern/_index.h	/^		typedef _Index  multi_index_type;$/;"	t	class:prgkern::cycle_index_cast
multi_index_type	include/prgkern/_index.h	/^		typedef _Index  multi_index_type;$/;"	t	class:prgkern::index_cast_
multiple	include/prgkern/_math.h	/^	template <typename T> INLINE T multiple    (bool b, T a) { return  b ? a : (T)0; }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> multiple(vecbool_<1, int> a, vecbool_<1, int> b) { return a && b; }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> multiple(vecbool_<4, int> a, vecbool_<4, int> b) { return a && b; }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> multiple(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_and_ps(a, b)); }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> multiple    (vecbool_<1, int> a, vecint_<1, int> b) { return vecint_<1, int>( a) & b; }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> multiple    (vecbool_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(   _mm_and_si128(a, b)); }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> multiple    (vecbool_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>( a) & b; }$/;"	f	namespace:prgkern
multiple	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> multiple    (vecbool_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_math.h	/^	template <typename T> INLINE T multiple_not(bool b, T a) { return !b ? a : (T)0; }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> multiple_not(vecbool_<1, int> a, vecbool_<1, int> b) { return (!a) && b; }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> multiple_not(vecbool_<4, int> a, vecbool_<4, int> b) { return (!a) && b; }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> multiple_not(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_andnot_ps(a, b)); }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> multiple_not(vecbool_<1, int> a, vecint_<1, int> b) { return vecint_<1, int>(!a) & b; }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> multiple_not(vecbool_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(!a) & b; }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> multiple_not(vecbool_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(_mm_andnot_si128(a, b)); }$/;"	f	namespace:prgkern
multiple_not	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> multiple_not(vecbool_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(mdense_<2, 2, T> &R, const mdense_<2, 2, T> &A,$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(mdense_<3, 3, T> &R, const mdense_<3, 3, T> &A,$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(mdense_<4, 4, T> &R, const mdense_<4, 4, T> &A, const mdense_<4, 4, T> &B)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<2, T> &R, const mdense_<2, 2, T> &M, const vdense_<2, T> &V)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<2, T> &R, const vdense_<2, T> &V, const mdense_<2, 2, T> &M)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<3, T> &R, const mdense_<3, 3, T> &M, const vdense_<3, T> &V)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<3, T> &R, const vdense_<3, T> &V, const mdense_<3, 3, T> &M)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<4, T> &R, const mdense_<4, 4, T> &M, const vdense_<4, T> &V)$/;"	f	namespace:prgkern
multiplies	include/prgkern/_m3x3dense.h	/^	INLINE void multiplies(vdense_<4, T> &R, const vdense_<4, T> &V, const mdense_<4, 4, T> &M)$/;"	f	namespace:prgkern
n	include/molkern/forcefield/_fparams.h	/^		int n; \/\/ full count of eqv$/;"	m	struct:molkern::Params
n	include/molkern/forcefield/_fparams.h	/^		int n[maxf]; \/\/ index subfunction$/;"	m	struct:molkern::Params
n_	include/prgkern/_minimize_lbfgs.h	/^		unsigned n_; \/\/ the number of freedom degrees$/;"	m	class:prgkern::Updater
n_	include/prgkern/_minimize_lbfgs.h	/^		unsigned n_;$/;"	m	class:prgkern::Updater
n_	include/prgkern/_time.h	/^		unsigned n_;$/;"	m	class:prgkern::function_timer_t
n_1_minimize_	include/prgkern/_minimize_round.h	/^		T n_1_minimize_(T &bx, T &f0, T &g0, T (*fn)(unsigned, const T *, T *, void *param), void *param,$/;"	f	class:prgkern::Minimizer_
na	include/molkern/forcefield/_residue.h	/^		unsigned na; \/\/ число связей с НЕ-водородами$/;"	m	struct:molkern::__ResidueAtomdata
name	include/molkern/__config.h	/^		std::string name; \/\/ имя воды$/;"	m	struct:molkern::Descriptor_
name	include/molkern/__config.h	/^		std::string name; \/\/ имя файла выводв для комплекса молекул$/;"	m	struct:molkern::Descriptor_
name	include/molkern/__config.h	/^		std::string name; \/\/ имя файла молекулы$/;"	m	struct:molkern::Descriptor_
name	include/molkern/complex/_archetype.h	/^		const std::string name() const$/;"	f	class:molkern::Archetype_
name	include/molkern/complex/_archetype.h	/^		const std::string name(_I2T<FILE_>    ) const { return filename_; }$/;"	f	class:molkern::Archetype_
name	include/molkern/complex/_archetype.h	/^		const std::string name(_I2T<MOLECULE_>) const { return molname_; }$/;"	f	class:molkern::Archetype_
name	include/molkern/forcefield/_atomdata.h	/^		fstring name;$/;"	m	struct:molkern::Atomdata_
name	include/molkern/forcefield/_fparams.h	/^		fstring name; \/\/ atom name (to efficient search)$/;"	m	struct:molkern::Params
name	include/molkern/forcefield/_nuclear.h	/^		fstring name;$/;"	m	struct:molkern::Nuclear
name	include/molkern/forcefield/_residome_amber.h	/^		std::string name(_I2T<CTERM_>, const std::string &name) const$/;"	f	class:molkern::Residome_
name	include/molkern/forcefield/_residome_amber.h	/^		std::string name(_I2T<NTERM_>, const std::string &name) const$/;"	f	class:molkern::Residome_
name	include/molkern/forcefield/_residue.h	/^		const char *name;$/;"	m	struct:molkern::AminoAcidName
name	include/molkern/forcefield/_residue.h	/^		fstring name; \/\/ топологическое имя$/;"	m	struct:molkern::__ResidueAtomdata
name	include/molkern/forcefield/_residue.h	/^		std::string name;$/;"	m	class:molkern::basic_residue_
name	include/molkern/forcefield/_residue_amber.h	/^			std::string name;$/;"	m	struct:molkern::Params::__anon1
name	include/molkern/forcefield/_residue_amber.h	/^			std::string name;$/;"	m	struct:molkern::Params::__anon9
name	include/molkern/forcefield/_residue_amber.h	/^		_Name name;$/;"	m	struct:molkern::Params
name	include/prgkern/_minimize_lbfgs.h	/^		static std::string name() { return _S("LMBFGS_"); }$/;"	f	class:prgkern::Updater
name	include/prgkern/_minimize_lbfgs.h	/^		static std::string name() { return _S("STEEP_"); }$/;"	f	class:prgkern::Updater
nb	include/molkern/forcefield/_fparams.h	/^		int nb; \/\/ number of paths in dihedral$/;"	m	struct:molkern::Params
nbond	include/molkern/forcefield/_atomdata.h	/^		unsigned nbond; \/\/ used for HIN format only$/;"	m	struct:molkern::Atomdata_
ndx	include/molkern/forcefield/_angle.h	/^		index_<3> ndx; \/\/ индексы атомов$/;"	m	struct:molkern::Angle_
ndx	include/molkern/forcefield/_bond.h	/^		index_<2> ndx; \/\/ индексы атомов$/;"	m	struct:molkern::Bond_
ndx	include/molkern/forcefield/_torsion.h	/^		index_<4> ndx; \/\/ индексы атомов$/;"	m	struct:molkern::Torsion_
ndx_	include/molkern/complex/_region.h	/^		_Index ndx_; \/\/ 3D индекс ячейки$/;"	m	class:molkern::Node_
ndx_	include/molkern/forcefield/_rotamer.h	/^		unsigned *ndx_; \/\/ индексы атомов ротамера (инициализируется в Archetype_)$/;"	m	class:molkern::Rotamer_
ndx_	include/molkern/forcefield/_rotamer.h	/^		unsigned *ndx_; \/\/ начало массива идентификаторов атомов цепи$/;"	m	class:molkern::Chain_
ndx_	include/prgkern/_index.h	/^		T ndx_[N];$/;"	m	class:prgkern::index_
ndx_	include/prgkern/_stencil.h	/^		unsigned ndx_; \/\/\/< размерность внутренней сетки (по всем направлениям едина)$/;"	m	class:prgkern::Stencil_
ndx_count_	include/molkern/forcefield/_rotamer.h	/^		unsigned ndx_count_; \/\/ количество атомов в цепи$/;"	m	class:molkern::Chain_
ndx_count_	include/molkern/forcefield/_rotamer.h	/^		unsigned ndx_count_;$/;"	m	class:molkern::Rotamer_
near	include/molkern/forcefield/_potential.h	/^		_Real near(_Real r) const$/;"	f	class:molkern::Potential
near1	include/molkern/forcefield/_potential.h	/^		_Real near1(_Real r) const$/;"	f	class:molkern::Potential
near_range_integrator	include/molkern/__moldefs.h	/^	class near_range_integrator$/;"	c	namespace:molkern
neigbor_cells_	include/molkern/complex/_region.h	/^		int neigbor_cells_[27]; \/\/ список номеров соседних ячеек (+ самовключение)$/;"	m	class:molkern::Node_
neighbours	include/molkern/complex/_region.h	/^			neighbours = 27 \/\/ число всех соседний ячеек (+ самовключение)$/;"	e	enum:molkern::Region_::__anon20
nh	include/molkern/forcefield/_residue.h	/^		unsigned nh; \/\/ число связей с водородами$/;"	m	struct:molkern::__ResidueAtomdata
nhid	include/molkern/forcefield/_residue.h	/^		int nhid[max_A]; \/\/ идентификаторы водородов, связных с заданным$/;"	m	struct:molkern::__ResidueAtomdata
nid	include/molkern/forcefield/_atomdata.h	/^		int nid[max_bond]; \/\/\/ абсолютный идентификатор соседа$/;"	m	struct:molkern::Atomdata_
nid	include/molkern/forcefield/_residue.h	/^		int nid[max_A]; \/\/ идентификаторы атомов, связных с заданным$/;"	m	struct:molkern::__ResidueAtomdata
nill	include/prgkern/_index.h	/^	const int nill = -1;$/;"	m	namespace:prgkern
node_type	include/molkern/complex/_region.h	/^		typedef _Node                           node_type;$/;"	t	class:molkern::Region_
nodes_	include/molkern/complex/_region.h	/^		std::vector<_Node> nodes_;$/;"	m	class:molkern::Region_
non_empty_element_count	include/prgkern/_sse.h	/^	const unsigned non_empty_element_count[16] =$/;"	m	namespace:prgkern
norm	include/prgkern/_random.h	/^		_Real norm() { return 1. \/ (M_SQRT_2PI * _Base::sigma()); }$/;"	f	class:prgkern::normal_distribution_
norma	include/prgkern/_blas1.h	/^	template <typename T> INLINE T norma(unsigned n, const T *v)$/;"	f	namespace:prgkern
normal_distribution_	include/prgkern/_random.h	/^		normal_distribution_(_Real sigma, _Real mean=0.)$/;"	f	class:prgkern::normal_distribution_
normal_distribution_	include/prgkern/_random.h	/^	class normal_distribution_ : public boost::normal_distribution<_Real>$/;"	c	namespace:prgkern
normalize	include/prgkern/_blas1.h	/^	INLINE T normalize(unsigned n, T *x)$/;"	f	namespace:prgkern
normalize	include/prgkern/_blas1.h	/^	INLINE T normalize(unsigned n, T *x, T new_length=1.)$/;"	f	namespace:prgkern
normalize	include/prgkern/_v3dense.h	/^		T normalize(T new_length=(T)1.)$/;"	f	class:prgkern::vdense_
normalize	include/prgkern/_vdense.h	/^		T normalize(T new_length=(T)1.)$/;"	f	class:prgkern::vdense_
nr_integrator_	include/molkern/complex/_complex.h	/^		near_range_integrator<Complex_> *nr_integrator_;$/;"	m	class:molkern::Complex_
nsec_	include/prgkern/_time.h	/^		long nsec_;$/;"	m	struct:prgkern::system_time_t
nth_	include/molkern/complex/_parallel.h	/^			unsigned nth_; \/\/ номер нити, чтобы нить знала откуда брать данные$/;"	m	struct:molkern::ParallWorker_::thread_data_
nth_	include/molkern/complex/_parallel.h	/^			unsigned nth_; \/\/ номер нити, чтобы нить знала откуда брать данные$/;"	m	struct:molkern::Parall_::thread_data_
nuclear	include/molkern/forcefield/_atomdata.h	/^		unsigned nuclear;$/;"	m	struct:molkern::Atomdata_
nuclears	include/molkern/forcefield/_nuclear.h	/^	nuclears[] = {$/;"	m	namespace:molkern	typeref:struct:molkern::Nuclear
nvalency	include/molkern/forcefield/_atomdata.h	/^		char nvalency[max_bond];$/;"	m	struct:molkern::Atomdata_
object_	include/molkern/complex/_parallel.h	/^		Object *object_; \/\/ комплекс для которого выполняется работа$/;"	m	class:molkern::ParallWorker_
object_	include/molkern/complex/_parallel.h	/^		Object *object_; \/\/ комплекс для которого выполняется работа$/;"	m	class:molkern::Parall_
operator !	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator!(vecbool_<1, int> a) { return vecbool_<1, int>(SCALAR_ARG2(a, ==, 0)); }$/;"	f	namespace:prgkern
operator !	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator!(vecbool_<4, int> a) { return vecbool_<4, int>(SCALAR_ARG2(a, ==, 0)); }$/;"	f	namespace:prgkern
operator !	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator!(vecbool_<4, int> a) { return vecbool_<4, int>(_mm_cmpeq_ps(a, _mm_setzero_ps())); }$/;"	f	namespace:prgkern
operator !=	include/prgkern/_fstring.h	/^	INLINE bool operator!=(fstring s1, fstring s2) { return *(int*)&s1 != *(int*)&s2; }$/;"	f	namespace:prgkern
operator !=	include/prgkern/_index.h	/^		bool operator!=(const index_ &ndx) const { return !(*this==ndx); }$/;"	f	class:prgkern::index_
operator !=	include/prgkern/_iterator.h	/^			bool operator!=(const iterator_ &it) const { return elem_ != it.elem_; }$/;"	f	class:prgkern::piecewise_vector::iterator_
operator !=	include/prgkern/_iterator.h	/^		bool operator!=(const array_iterator &it) const { return it_ != it.it_; }$/;"	f	class:prgkern::array_iterator
operator !=	include/prgkern/_iterator.h	/^		bool operator!=(const const_array_iterator &it) const { return it_ != it.it_; }$/;"	f	class:prgkern::const_array_iterator
operator !=	include/prgkern/_iterator.h	/^		bool operator!=(const range_iterator_ &t) const { return pos_ != t.pos_; }$/;"	f	class:prgkern::range_iterator_
operator !=	include/prgkern/_iterator.h	/^		bool operator!=(const sub_iterator &it) const { return it_ != it.it_; }$/;"	f	class:prgkern::sub_iterator
operator !=	include/prgkern/_os.h	/^		bool operator!=(const directory_iterator &it) const$/;"	f	class:prgkern::directory_iterator
operator &	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator&(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_and_ps(a, b)); }$/;"	f	namespace:prgkern
operator &	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator&(vecint_<1, int> a, vecint_<1, int> b) { return vecint_<1, int>(VECTOR_ARG(a, &, b)); }$/;"	f	namespace:prgkern
operator &	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator&(vecbool_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(_mm_and_si128(a, b)); }$/;"	f	namespace:prgkern
operator &	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator&(vecint_<4, int> a, vecbool_<4, int> b) { return vecint_<4, int>(_mm_and_si128(a, b)); }$/;"	f	namespace:prgkern
operator &	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator&(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int> (_mm_and_si128(a, b)); }$/;"	f	namespace:prgkern
operator &	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator&(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(VECTOR_ARG(a, &, b)); }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE bool operator&&(bool a, vecbool_<1, int> b) { return a && (bool)b; }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE bool operator&&(bool a, vecbool_<4, int> b) { return a && (bool)b; }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE bool operator&&(vecbool_<1, int> a, bool b) { return (bool)a && b; }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE bool operator&&(vecbool_<4, int> a, bool b) { return (bool)a && b; }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator&&(vecbool_<1, int> a, vecbool_<1, int> b) { return vecbool_<1, int>(VECTOR_ARG(a, &, b)); }$/;"	f	namespace:prgkern
operator &&	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator&&(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(VECTOR_ARG(a, &, b)); }$/;"	f	namespace:prgkern
operator &=	include/prgkern/_sse.h	/^		vecint_ &operator&=(vecbool_<4, int> b) { i_ = _mm_and_si128(i_, (__m128i)b); return *this;  }$/;"	f	class:prgkern::vecint_
operator &=	include/prgkern/_sse.h	/^		vecint_ &operator&=(vecint_ i) { i_ = _mm_and_si128(i_, i.i_); return *this;  }$/;"	f	class:prgkern::vecint_
operator &=	include/prgkern/_sse.h	/^		vecreal_ &operator&=(vecbool_<4, int> b) { f_ = _mm_and_ps(f_, (__m128)b); return *this; }$/;"	f	class:prgkern::vecreal_
operator ()	include/molkern/complex/_optimize.h	/^		real_t operator()(LPComplex *complex, const Param &param)$/;"	f	class:molkern::Optimizer_
operator ()	include/molkern/complex/_parallel.h	/^			void operator()() \/\/ оператор, необходимый для boost::thread$/;"	f	struct:molkern::ParallWorker_::thread_data_
operator ()	include/molkern/complex/_parallel.h	/^			void operator()() \/\/ оператор, необходимый для boost::thread$/;"	f	struct:molkern::Parall_::thread_data_
operator ()	include/prgkern/_average.h	/^		S operator()() const$/;"	f	class:prgkern::Average_
operator ()	include/prgkern/_m3x3dense.h	/^		T &operator()(unsigned i, unsigned j) { return (*this)[i][j]; }$/;"	f	class:prgkern::mdense_
operator ()	include/prgkern/_m3x3dense.h	/^		T operator()(unsigned i, unsigned j) const { return (*this)[i][j]; }$/;"	f	class:prgkern::mdense_
operator ()	include/prgkern/_mdense.h	/^		T& operator()(unsigned i, unsigned j) { return (*this)[_Index(i,j)]; }$/;"	f	class:prgkern::mdense_
operator ()	include/prgkern/_mdense.h	/^		const T& operator()(unsigned i, unsigned j) const { return (*this)[_Index(i,j)]; }$/;"	f	class:prgkern::mdense_
operator ()	include/prgkern/_minimize.h	/^		T operator()(bool find_minimum, T &beta, T &f0, T &g0, SHARE_PARAM_DEF(T))$/;"	f	class:prgkern::Line_minimizer_
operator ()	include/prgkern/_minimize_lbfgs.h	/^		T operator()(T (*fn)(unsigned, const T *, T *, void *param), void *param,$/;"	f	class:prgkern::Minimizer_
operator ()	include/prgkern/_minimize_round.h	/^		T operator()(T (*fn)(unsigned, const T *, T *, void *param), void *param,$/;"	f	class:prgkern::Minimizer_
operator ()	include/prgkern/_minimize_round.h	/^		void operator()(T &beta, T &f0, T &g0, SHARE_PARAM_DEF(T))$/;"	f	class:prgkern::Round_minimizer_
operator ()	include/prgkern/_random.h	/^		T operator()(T max=1., T min=0.) { return min + make_<T>() * (max-min); }$/;"	f	class:prgkern::randgen
operator ()	include/prgkern/_rotator.h	/^		vdense_<3, T> operator()(const vdense_<3, T> &X) const$/;"	f	class:prgkern::Rotator
operator ()	include/prgkern/_rotator.h	/^		vdense_<3, T> operator()(vdense_<3, T> X) const { return M_ * (X - X0_) + X0_; }$/;"	f	class:prgkern::Rotator
operator ()	include/prgkern/_rotator.h	/^		void operator()(vdense_<3, T> &R, const vdense_<3, T> &X) const { R = X - X_; }$/;"	f	class:prgkern::Rotator
operator ()	include/prgkern/_transforms.h	/^		void operator()(_Real *vo, const std::complex<_Real> *vi)$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(const _Real *vi, std::complex<_Real> *vo) { operator()(vo, vi); }$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(const std::complex<_Real> *vi, _Real *vo) { operator()(vo, vi); }$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(const vdense_<_M, std::complex<_Real> > *vi, vdense_<_M, _Real> *vo)$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(std::complex<_Real> *vo, const _Real *vi)$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(std::complex<_Real> *vo, const std::complex<_Real> *vi)$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_transforms.h	/^		void operator()(vdense_<_M, _Real> *vo, const vdense_<_M, std::complex<_Real> > *vi)$/;"	f	class:prgkern::Dfft
operator ()	include/prgkern/_type.h	/^		bool operator() (_I i, _I j) const { return f_[i] < f_[j]; }$/;"	f	class:prgkern::less_than_
operator ()	include/prgkern/_type.h	/^		bool operator()(const _T &s1, const _T &s2) const$/;"	f	class:prgkern::less_
operator ()	include/prgkern/_type.h	/^		bool operator()(const _T &t) const { return t.*_mp == f_; }$/;"	f	class:prgkern::equal_
operator ()	include/prgkern/_v3dense.h	/^		T &operator()(size_t i) { _A(i); return v_[i]; }$/;"	f	class:prgkern::vdense_
operator ()	include/prgkern/_v3dense.h	/^		T operator()(size_t i) const { _A(i); return v_[i]; }$/;"	f	class:prgkern::vdense_
operator *	include/prgkern/_index.h	/^	INLINE index_<1,T> operator*(const index_<1, T> &ndx, S s)$/;"	f	namespace:prgkern
operator *	include/prgkern/_index.h	/^	INLINE index_<2,T> operator*(const index_<2, T> &ndx, S s)$/;"	f	namespace:prgkern
operator *	include/prgkern/_index.h	/^	INLINE index_<3,T> operator*(const index_<3, T> &ndx, S s)$/;"	f	namespace:prgkern
operator *	include/prgkern/_index.h	/^	INLINE index_<4,T> operator*(const index_<4, T> &ndx, S s)$/;"	f	namespace:prgkern
operator *	include/prgkern/_iterator.h	/^			T &operator*() const { return *elem_; }$/;"	f	class:prgkern::piecewise_vector::iterator_
operator *	include/prgkern/_iterator.h	/^		Member &operator*() { return it_->*MemberPtr; }$/;"	f	class:prgkern::sub_iterator
operator *	include/prgkern/_iterator.h	/^		S &operator*() { return v_[*it_]; }$/;"	f	class:prgkern::array_iterator
operator *	include/prgkern/_iterator.h	/^		T &operator*() { return pos_; }$/;"	f	class:prgkern::range_iterator_
operator *	include/prgkern/_iterator.h	/^		T operator*() const { return pos_; }$/;"	f	class:prgkern::range_iterator_
operator *	include/prgkern/_iterator.h	/^		const Member &operator*() const { return it_->*MemberPtr; }$/;"	f	class:prgkern::sub_iterator
operator *	include/prgkern/_iterator.h	/^		const S &operator*() const { return v_[*it_]; }$/;"	f	class:prgkern::array_iterator
operator *	include/prgkern/_iterator.h	/^		const S &operator*() const { return v_[*it_]; }$/;"	f	class:prgkern::const_array_iterator
operator *	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> operator*(T a1, const mdense_<N, N, T> &a2)$/;"	f	namespace:prgkern
operator *	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> operator*(const mdense_<N, N, T> &A, const mdense_<N, N, T> &B)$/;"	f	namespace:prgkern
operator *	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> operator*(const mdense_<N, N, T> &a1, T a2)$/;"	f	namespace:prgkern
operator *	include/prgkern/_m3x3dense.h	/^	INLINE vdense_<N, T> operator*(const mdense_<N, N, T> &M, const vdense_<N, T> &V)$/;"	f	namespace:prgkern
operator *	include/prgkern/_m3x3dense.h	/^	INLINE vdense_<N, T> operator*(const vdense_<N, T> &V, const mdense_<N, N, T> &M)$/;"	f	namespace:prgkern
operator *	include/prgkern/_os.h	/^		std::string operator*() { return (*this)->leaf(); }$/;"	f	class:prgkern::directory_iterator
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<1, double> operator*(double b, vecint_<1, int> a) { vecreal_<1, double> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<1, double> operator*(vecint_<1, int> a, double b) { vecreal_<1, double> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<1, float> operator*(float b, vecint_<1, int> a) { vecreal_<1, float> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<1, float> operator*(vecint_<1, int> a, float b) { vecreal_<1, float> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, double> operator*(double b, vecint_<4, int> a) { vecreal_<4, double> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, double> operator*(vecint_<4, int> a, double b) { vecreal_<4, double> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(float a, vecreal_<4, float> b) { return _mm_mul_ps(_mm_set1_ps(a), b); }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(float b, vecint_<4, int> a) { vecreal_<4, float> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(vecint_<4, int> a, float b) { vecreal_<4, float> a_(a); return a_ *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(vecint_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(vecreal_<4, float> a, float b) { return _mm_mul_ps(a, _mm_set1_ps(b)); }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(vecreal_<4, float> a, vecint_<4, int> b)$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator*(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_mul_ps(a, b); }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator*(S a, vecreal_<N, T> b) { return b *= a; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator*(vecint_<N, int> a, vecreal_<N, T> b) { return b *= a; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator*(vecreal_<N, T> a, T b) { return a *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator*(vecreal_<N, T> a, vecint_<N, int> b) { return a *= b; }$/;"	f	namespace:prgkern
operator *	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator*(vecreal_<N, T> a, vecreal_<N, T> b) { return a *= b; }$/;"	f	namespace:prgkern
operator *=	include/prgkern/_mdense.h	/^		template <_T S> mdense_ &operator*=(S s)$/;"	f	class:prgkern::mdense_
operator *=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator*=(S f) { SCALAR_OPERATOR(v_, *=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator*=(vecint_<1, S> f) { VECTOR_OPERATOR(v_, *=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator*=(vecint_<4, S> f) { VECTOR_OPERATOR(v_, *=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator*=(vecreal_<1, S> f) { VECTOR_OPERATOR(v_, *=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator*=(vecreal_<4, S> f) { VECTOR_OPERATOR(v_, *=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		vecreal_ &operator*=(float f) { f_ = _mm_mul_ps(f_, _mm_set1_ps(f)); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_sse.h	/^		vecreal_ &operator*=(vecreal_ f) { f_ = _mm_mul_ps(f_, f.f_); return *this; }$/;"	f	class:prgkern::vecreal_
operator *=	include/prgkern/_vdense.h	/^		template <typename S> vdense_ &operator*=(S s)$/;"	f	class:prgkern::vdense_
operator +	include/prgkern/_iterator.h	/^			iterator_ operator+(unsigned n) { return iterator_(*this) += n; }$/;"	f	class:prgkern::piecewise_vector::iterator_
operator +	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> operator+(const mdense_<N, N, T> &a1, const mdense_<N, N, T> &a2)$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator+(int a, vecint_<1, int> b) { vecint_<1, int> a_(a); return a_ += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator+(vecint_<1, int> a, int b) { return a += vecint_<1, int>(b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator+(vecint_<1, int> a, vecint_<1, int> b) { return a += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(int a, vecint_<4, int> b) { return _mm_add_epi32(_mm_set1_epi32(a), b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(int a, vecint_<4, int> b) { vecint_<4, int> a_(a); return a_ += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(vecint_<4, int> a, int b) { return _mm_add_epi32(a, _mm_set1_epi32(b)); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(vecint_<4, int> a, int b) { return a += vecint_<4, int>(b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(vecint_<4, int> a, vecint_<4, int> b) { return _mm_add_epi32(a, b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator+(vecint_<4, int> a, vecint_<4, int> b) { return a += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator+(float a, vecreal_<4, float> b) { return _mm_add_ps(_mm_set1_ps(a), b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator+(vecint_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator+(vecreal_<4, float> a, float b) { return _mm_add_ps(a, _mm_set1_ps(b)); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator+(vecreal_<4, float> a, vecint_<4, int> b)$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator+(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_add_ps(a, b); }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator+(S a, vecreal_<N, T> b) { return b += a; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator+(vecint_<N, int> a, vecreal_<N, T> b) { return b += a; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator+(vecreal_<N, T> a, T b) { return a += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator+(vecreal_<N, T> a, vecint_<N, int> b) { return a += b; }$/;"	f	namespace:prgkern
operator +	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator+(vecreal_<N, T> a, vecreal_<N, T> b) { return a += b; }$/;"	f	namespace:prgkern
operator ++	include/prgkern/_iterator.h	/^			iterator_ &operator++()$/;"	f	class:prgkern::piecewise_vector::iterator_
operator ++	include/prgkern/_iterator.h	/^		array_iterator &operator++() { ++it_; return *this; }$/;"	f	class:prgkern::array_iterator
operator ++	include/prgkern/_iterator.h	/^		const_array_iterator &operator++() { ++it_; return *this; }$/;"	f	class:prgkern::const_array_iterator
operator ++	include/prgkern/_iterator.h	/^		range_iterator_ &operator++() { ++pos_; return *this; }$/;"	f	class:prgkern::range_iterator_
operator ++	include/prgkern/_iterator.h	/^		sub_iterator &operator++() { ++it_; return *this; }$/;"	f	class:prgkern::sub_iterator
operator ++	include/prgkern/_os.h	/^		directory_iterator &operator++()$/;"	f	class:prgkern::directory_iterator
operator ++	include/prgkern/_sse.h	/^		vecint_ &operator++() { i_ = _mm_add_epi32(i_, _mm_set1_epi32(1)); return *this; }$/;"	f	class:prgkern::vecint_
operator +=	include/molkern/__moldefs.h	/^		model_time_t &operator+=(unsigned dt) { tm_ += dt; return *this; }$/;"	f	struct:molkern::model_time_t
operator +=	include/prgkern/_iterator.h	/^			iterator_ &operator+=(unsigned n)$/;"	f	class:prgkern::piecewise_vector::iterator_
operator +=	include/prgkern/_iterator.h	/^		range_iterator_ &operator+=(int n) { pos_ += n; return *this; }$/;"	f	class:prgkern::range_iterator_
operator +=	include/prgkern/_mdense.h	/^		template <_T S> mdense_ &operator+=(S s)$/;"	f	class:prgkern::mdense_
operator +=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator+=(S f) { SCALAR_OPERATOR(v_, +=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator+=(vecint_<1, S> f) { VECTOR_OPERATOR(v_, +=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator+=(vecint_<4, S> f) { VECTOR_OPERATOR(v_, +=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator+=(vecreal_<1, S> f) { VECTOR_OPERATOR(v_, +=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator+=(vecreal_<4, S> f) { VECTOR_OPERATOR(v_, +=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		vecint_ &operator+=(vecint_ i) { VECTOR_OPERATOR(v_, +=, i); return *this; }$/;"	f	class:prgkern::vecint_
operator +=	include/prgkern/_sse.h	/^		vecint_ &operator+=(vecint_ i) { i_ = _mm_add_epi32(i_, i.i_); return *this; }$/;"	f	class:prgkern::vecint_
operator +=	include/prgkern/_sse.h	/^		vecreal_ &operator+=(float f) { f_ = _mm_add_ps(f_, _mm_set1_ps(f)); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_sse.h	/^		vecreal_ &operator+=(vecreal_ f) { f_ = _mm_add_ps(f_, f.f_); return *this; }$/;"	f	class:prgkern::vecreal_
operator +=	include/prgkern/_vdense.h	/^		template <typename S> vdense_ &operator+=(S s)$/;"	f	class:prgkern::vdense_
operator +=	include/prgkern/_vdense.h	/^		vdense_ &operator+=(const vdense_ &s)$/;"	f	class:prgkern::vdense_
operator -	include/molkern/__moldefs.h	/^	INLINE model_time_t operator-(model_time_t t1, model_time_t t2)$/;"	f	namespace:molkern
operator -	include/prgkern/_index.h	/^	INLINE index_<1,T> operator-(const index_<1, T> &ndx)$/;"	f	namespace:prgkern
operator -	include/prgkern/_index.h	/^	INLINE index_<2,T> operator-(const index_<2, T> &ndx)$/;"	f	namespace:prgkern
operator -	include/prgkern/_index.h	/^	INLINE index_<3,T> operator-(const index_<3, T> &ndx)$/;"	f	namespace:prgkern
operator -	include/prgkern/_index.h	/^	INLINE index_<4,T> operator-(const index_<4, T> &ndx)$/;"	f	namespace:prgkern
operator -	include/prgkern/_m3x3dense.h	/^	INLINE mdense_<N, N, T> operator-(const mdense_<N, N, T> &a1, const mdense_<N, N, T> &a2)$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator-(int a, vecint_<1, int> b) { vecint_<1, int> a_(a); return a_ -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator-(vecint_<1, int> a, int b) { return a -= vecint_<1, int>(b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator-(vecint_<1, int> a, vecint_<1, int> b) { return a -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(int a, vecint_<4, int> b) { return _mm_sub_epi32(_mm_set1_epi32(a), b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(int a, vecint_<4, int> b) { vecint_<4, int> a_(a); return a_ -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(vecint_<4, int> a, int b) { return _mm_sub_epi32(a, _mm_set1_epi32(b)); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(vecint_<4, int> a, int b) { return a -= vecint_<4, int>(b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(vecint_<4, int> a, vecint_<4, int> b) { return _mm_sub_epi32(a, b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator-(vecint_<4, int> a, vecint_<4, int> b) { return a -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator-(float a, vecreal_<4, float> b) { return _mm_sub_ps(_mm_set1_ps(a), b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator-(vecint_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator-(vecreal_<4, float> a, float b) { return _mm_sub_ps(a, _mm_set1_ps(b)); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator-(vecreal_<4, float> a, vecint_<4, int> b)$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator-(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_sub_ps(a, b); }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator-(S a, vecreal_<N, T> b) { vecreal_<N, T> a_(a); return a_ -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator-(vecint_<N, int> a, vecreal_<N, T> b) { vecreal_<N, T> a_(a); return a_ - b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator-(vecreal_<N, T> a, T b) { return a -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator-(vecreal_<N, T> a, vecint_<N, int> b) { return a -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator-(vecreal_<N, T> a, vecreal_<N, T> b) { return a -= b; }$/;"	f	namespace:prgkern
operator -	include/prgkern/_time.h	/^	INLINE system_time_t operator-(system_time_t t1, system_time_t t2)$/;"	f	namespace:prgkern
operator -	include/prgkern/_v3dense.h	/^	INLINE vdense_<N, T> operator-(const vdense_<N, T> &v)$/;"	f	namespace:prgkern
operator --	include/prgkern/_sse.h	/^		vecint_ &operator--() { i_ = _mm_sub_epi32(i_, _mm_set1_epi32(1)); return *this; }$/;"	f	class:prgkern::vecint_
operator -=	include/prgkern/_mdense.h	/^		template <_T S> mdense_ &operator-=(S s)$/;"	f	class:prgkern::mdense_
operator -=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator-=(S f) { SCALAR_OPERATOR(v_, -=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator-=(vecint_<1, S> f) { VECTOR_OPERATOR(v_, -=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator-=(vecint_<4, S> f) { VECTOR_OPERATOR(v_, -=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator-=(vecreal_<1, S> f) { VECTOR_OPERATOR(v_, -=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator-=(vecreal_<4, S> f) { VECTOR_OPERATOR(v_, -=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		vecint_ &operator-=(vecint_ i) { VECTOR_OPERATOR(v_, -=, i); return *this; }$/;"	f	class:prgkern::vecint_
operator -=	include/prgkern/_sse.h	/^		vecint_ &operator-=(vecint_ i) { i_ = _mm_sub_epi32(i_, i.i_); return *this; }$/;"	f	class:prgkern::vecint_
operator -=	include/prgkern/_sse.h	/^		vecreal_ &operator-=(float f) { f_ = _mm_sub_ps(f_, _mm_set1_ps(f)); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_sse.h	/^		vecreal_ &operator-=(vecreal_ f) { f_ = _mm_sub_ps(f_, f.f_); return *this; }$/;"	f	class:prgkern::vecreal_
operator -=	include/prgkern/_vdense.h	/^		template <typename S> vdense_ &operator-=(S s)$/;"	f	class:prgkern::vdense_
operator -=	include/prgkern/_vdense.h	/^		vdense_ &operator-=(const vdense_ &s)$/;"	f	class:prgkern::vdense_
operator ->	include/molkern/complex/_complex.h	/^			const _Atomdata *operator->() const { return atomdata; }$/;"	f	struct:molkern::Complex_::_Atom
operator ->	include/molkern/complex/_molecule.h	/^		const _Archetype *operator->() const { return archetype_; }$/;"	f	class:molkern::Molecule_
operator ->	include/prgkern/_iterator.h	/^		Member *operator->() { return &it_->*MemberPtr; }$/;"	f	class:prgkern::sub_iterator
operator ->	include/prgkern/_iterator.h	/^		S *operator->() { return &v_[*it_]; }$/;"	f	class:prgkern::array_iterator
operator ->	include/prgkern/_iterator.h	/^		const Member *operator->() const { return &it_->*MemberPtr; }$/;"	f	class:prgkern::sub_iterator
operator ->	include/prgkern/_iterator.h	/^		const S *operator->() const { return &v_[*it_]; }$/;"	f	class:prgkern::array_iterator
operator ->	include/prgkern/_iterator.h	/^		const S *operator->() const { return &v_[*it_]; }$/;"	f	class:prgkern::const_array_iterator
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator\/(float a, vecreal_<4, float> b) { return _mm_div_ps(_mm_set1_ps(a), b); }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator\/(vecint_<4, int> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator\/(vecreal_<4, float> a, float b) { return _mm_div_ps(a, _mm_set1_ps(b)); }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator\/(vecreal_<4, float> a, vecint_<4, int> b)$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> operator\/(vecreal_<4, float> a, vecreal_<4, float> b) { return _mm_div_ps(a, b); }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator\/(S a, vecreal_<N, T> b) { vecreal_<N, T> a_(a); return a_ \/= b; }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator\/(vecint_<N, int> a, vecreal_<N, T> b) { vecreal_<N, T> a_(a); return a_ \/ b; }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator\/(vecreal_<N, T> a, T b) { return a \/= b; }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator\/(vecreal_<N, T> a, vecint_<N, int> b) { return a \/= b; }$/;"	f	namespace:prgkern
operator /	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> operator\/(vecreal_<N, T> a, vecreal_<N, T> b) { return a \/= b; }$/;"	f	namespace:prgkern
operator /=	include/prgkern/_mdense.h	/^		template <_T S> mdense_ &operator\/=(S s)$/;"	f	class:prgkern::mdense_
operator /=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator\/=(S f) { SCALAR_OPERATOR(v_, \/=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator\/=(vecint_<1, S> f) { VECTOR_OPERATOR(v_, \/=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator\/=(vecint_<4, S> f) { VECTOR_OPERATOR(v_, \/=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator\/=(vecreal_<1, S> f) { VECTOR_OPERATOR(v_, \/=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator\/=(vecreal_<4, S> f) { VECTOR_OPERATOR(v_, \/=, f); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		vecreal_ &operator\/=(float f) { f_ = _mm_div_ps(f_, _mm_set1_ps(f)); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_sse.h	/^		vecreal_ &operator\/=(vecreal_ f) { f_ = _mm_div_ps(f_, f.f_); return *this; }$/;"	f	class:prgkern::vecreal_
operator /=	include/prgkern/_vdense.h	/^		template <typename S> vdense_ &operator\/=(S s)$/;"	f	class:prgkern::vdense_
operator <	include/molkern/forcefield/_fparams.h	/^	template <int X, int Y> inline bool operator<($/;"	f	namespace:molkern
operator <	include/molkern/forcefield/_residue.h	/^	INLINE bool operator<(const basic_residue_<RESIDOME_TYPE> &a1,$/;"	f	namespace:molkern
operator <	include/molkern/forcefield/_residue_amber.h	/^	INLINE bool operator<(const Params<RESIDUE_, RESIDOME_AMBER_> &a1,$/;"	f	namespace:molkern
operator <	include/prgkern/_fstring.h	/^	INLINE bool operator<(fstring s1, fstring s2) { return *(int*)&s1 < *(int*)&s2; }$/;"	f	namespace:prgkern
operator <	include/prgkern/_index.h	/^	INLINE bool operator<(const index_<1, T> &ndx1, const index_<1, T> &ndx2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_index.h	/^	INLINE bool operator<(const index_<2, T> &ndx1, const index_<2, T> &ndx2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_index.h	/^	INLINE bool operator<(const index_<3, T> &ndx1, const index_<3, T> &ndx2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_index.h	/^	INLINE bool operator<(const index_<4, T> &ndx1, const index_<4, T> &ndx2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator< (int a, vecint_<1, int> b) { return vecbool_<1, int>(SCALAR_ARG1(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator< (vecint_<1, int> a, int b) { return vecbool_<1, int>(SCALAR_ARG2(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator< (vecint_<1, int> a, vecint_<1, int> b) { return vecbool_<1, int>(VECTOR_ARG(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (float a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (int a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmplt_epi32(_mm_set1_epi32(a), b); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (int a, vecint_<4, int> b) { return vecbool_<4, int>(SCALAR_ARG1(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecint_<4, int> a, int b) { return (vecbool_<4, int>)_mm_cmplt_epi32(a, _mm_set1_epi32(b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecint_<4, int> a, int b) { return vecbool_<4, int>(SCALAR_ARG2(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecint_<4, int> a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmplt_epi32(a, b); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecint_<4, int> a, vecint_<4, int> b) { return vecbool_<4, int>(VECTOR_ARG(a, <, b)); }$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecreal_<4, float> a, float b)$/;"	f	namespace:prgkern
operator <	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator< (vecreal_<4, float> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator <	include/prgkern/_v3dense.h	/^	INLINE bool operator<(const vdense_<2, T> &v1, const vdense_<2, T> &v2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_v3dense.h	/^	INLINE bool operator<(const vdense_<3, T> &v1, const vdense_<3, T> &v2)$/;"	f	namespace:prgkern
operator <	include/prgkern/_v3dense.h	/^	INLINE bool operator<(const vdense_<4, T> &v1, const vdense_<4, T> &v2)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_box.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const Box_<N, T> &box)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_fstring.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const fstring_<A> &v)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_index.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const index_<N, T> &v)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_m3x3dense.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const mdense_<N, N, T> &v)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator<<(vecint_<1, int> a, vecint_<1, int> n)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator<<(vecint_<4, int> a, vecint_<4, int> n)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_v3dense.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const vdense_<N, T> &v)$/;"	f	namespace:prgkern
operator <<	include/prgkern/_vdense.h	/^	INLINE std::ostream &operator<<(std::ostream &os, const vdense_<UNLIMITED_, T> &v)$/;"	f	namespace:prgkern
operator <=	include/prgkern/_v3dense.h	/^	INLINE bool operator<=(const vdense_<2, T> &v1, const vdense_<2, T> &v2)$/;"	f	namespace:prgkern
operator <=	include/prgkern/_v3dense.h	/^	INLINE bool operator<=(const vdense_<3, T> &v1, const vdense_<3, T> &v2)$/;"	f	namespace:prgkern
operator <=	include/prgkern/_v3dense.h	/^	INLINE bool operator<=(const vdense_<4, T> &v1, const vdense_<4, T> &v2)$/;"	f	namespace:prgkern
operator =	include/prgkern/_fstring.h	/^		fstring_ &operator=(const char *s) { init_(s); return *this; }$/;"	f	class:prgkern::fstring_
operator =	include/prgkern/_fstring.h	/^		fstring_ &operator=(const fstring_ &s) { VALUE(v_) = VALUE(s.v_); return *this; }$/;"	f	class:prgkern::fstring_
operator =	include/prgkern/_fstring.h	/^		fstring_ &operator=(const std::string &s) { init_(s.c_str()); return *this; }$/;"	f	class:prgkern::fstring_
operator =	include/prgkern/_index.h	/^		cycle_index_cast &operator=(const cycle_index_cast &c)$/;"	f	class:prgkern::cycle_index_cast
operator =	include/prgkern/_index.h	/^		index_ &operator=(const index_ &ndx)$/;"	f	class:prgkern::index_
operator =	include/prgkern/_index.h	/^		index_cast_ &operator=(const index_cast_ &c)$/;"	f	class:prgkern::index_cast_
operator =	include/prgkern/_iterator.h	/^		array_iterator &operator=(const array_iterator &it)$/;"	f	class:prgkern::array_iterator
operator =	include/prgkern/_iterator.h	/^		const_array_iterator &operator=(const const_array_iterator &it)$/;"	f	class:prgkern::const_array_iterator
operator =	include/prgkern/_iterator.h	/^		range_iterator_ &operator=(const range_iterator_ &t) { pos_ = t.pos_; return *this; }$/;"	f	class:prgkern::range_iterator_
operator =	include/prgkern/_iterator.h	/^		sub_iterator &operator=(const sub_iterator &it) { it_ = it.it_; return *this; }$/;"	f	class:prgkern::sub_iterator
operator =	include/prgkern/_mdense.h	/^		template <_T S> mdense_ &operator=(S s)$/;"	f	class:prgkern::mdense_
operator =	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator=(S v) { SCALAR_OPERATOR(v_, =, v); return *this; }$/;"	f	class:prgkern::vecreal_
operator =	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator=(vecreal_<1, S> v) { VECTOR_OPERATOR(v_, =, v); return *this; }$/;"	f	class:prgkern::vecreal_
operator =	include/prgkern/_sse.h	/^		template <typename S> vecreal_ &operator=(vecreal_<4, S> v) { VECTOR_OPERATOR(v_, =, v); return *this; }$/;"	f	class:prgkern::vecreal_
operator =	include/prgkern/_sse.h	/^		vecbool_ &operator=(bool b) { *this = vecbool_(b); return *this; }$/;"	f	class:prgkern::vecbool_
operator =	include/prgkern/_sse.h	/^		vecbool_ &operator=(int b) { *this = vecbool_(b); return *this; }$/;"	f	class:prgkern::vecbool_
operator =	include/prgkern/_sse.h	/^		vecbool_ &operator=(unsigned b) { *this = vecbool_(b); return *this; }$/;"	f	class:prgkern::vecbool_
operator =	include/prgkern/_sse.h	/^		vecbool_ &operator=(vecbool_ b) { VECTOR_OPERATOR(v_, =, b); return *this; }$/;"	f	class:prgkern::vecbool_
operator =	include/prgkern/_sse.h	/^		vecbool_ &operator=(vecbool_ b) { b_ = b.b_; return *this; }$/;"	f	class:prgkern::vecbool_
operator =	include/prgkern/_sse.h	/^		vecint_ &operator=(const vecint_ &i) { VECTOR_OPERATOR(v_, =, i); return *this; }$/;"	f	class:prgkern::vecint_
operator =	include/prgkern/_sse.h	/^		vecint_ &operator=(int i) { SCALAR_OPERATOR(v_, =, i); return *this; }$/;"	f	class:prgkern::vecint_
operator =	include/prgkern/_sse.h	/^		vecint_ &operator=(int i) { i_ = _mm_set1_epi32(i); return *this; }$/;"	f	class:prgkern::vecint_
operator =	include/prgkern/_sse.h	/^		vecint_ &operator=(vecint_ i) { i_ = i.i_; return *this; }$/;"	f	class:prgkern::vecint_
operator =	include/prgkern/_sse.h	/^		vecreal_ &operator=(const vecreal_ &f) { f_ = f.f_; return *this; }$/;"	f	class:prgkern::vecreal_
operator =	include/prgkern/_sse.h	/^		vecreal_ &operator=(float f) { f_ = _mm_set1_ps(f); return *this; }$/;"	f	class:prgkern::vecreal_
operator =	include/prgkern/_v3dense.h	/^		template <typename S> vdense_ &operator=(const vdense_<N, S> &v)$/;"	f	class:prgkern::vdense_
operator =	include/prgkern/_v3dense.h	/^		vdense_ &operator=(T s)$/;"	f	class:prgkern::vdense_
operator =	include/prgkern/_vdense.h	/^		template <typename S> vdense_ &operator=(S s)$/;"	f	class:prgkern::vdense_
operator =	include/prgkern/_vdense.h	/^		vdense_ &operator=(const vdense_ &s)$/;"	f	class:prgkern::vdense_
operator ==	include/molkern/forcefield/_fparams.h	/^	template <int X, int Y> inline bool operator==($/;"	f	namespace:molkern
operator ==	include/molkern/forcefield/_residue.h	/^	INLINE bool operator==(const basic_residue_<RESIDOME_TYPE> &a1,$/;"	f	namespace:molkern
operator ==	include/molkern/forcefield/_residue_amber.h	/^	INLINE bool operator==(const Params<RESIDUE_, RESIDOME_AMBER_> &a1,$/;"	f	namespace:molkern
operator ==	include/prgkern/_fstring.h	/^	INLINE bool operator==(fstring s1, fstring s2) { return *(int*)&s1 == *(int*)&s2; }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_index.h	/^		bool operator==(const index_ &ndx) const$/;"	f	class:prgkern::index_
operator ==	include/prgkern/_os.h	/^		bool operator==(const directory_iterator &it) const$/;"	f	class:prgkern::directory_iterator
operator ==	include/prgkern/_sse.h	/^	INLINE bool operator==(bool a, vecbool_<1, int> b) { return a == (bool)b; }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE bool operator==(bool a, vecbool_<4, int> b) { return a == (bool)b; }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE bool operator==(vecbool_<1, int> a, bool b) { return (bool)a == b; }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE bool operator==(vecbool_<4, int> a, bool b) { return (bool)a == b; }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator==(int a, vecint_<1, int> b) { return vecbool_<1, int>(SCALAR_ARG1(a,==, b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator==(vecint_<1, int> a, int b) { return vecbool_<1, int>(SCALAR_ARG2(a,==, b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator==(vecint_<1, int> a, vecint_<1, int> b) { return vecbool_<1, int>(VECTOR_ARG(a,==, b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(int a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmpeq_epi32(_mm_set1_epi32(a), b); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(int a, vecint_<4, int> b) { return vecbool_<4, int>(SCALAR_ARG1(a,==, b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(vecint_<4, int> a, int b) { return (vecbool_<4, int>)_mm_cmpeq_epi32(a, _mm_set1_epi32(b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(vecint_<4, int> a, int b) { return vecbool_<4, int>(SCALAR_ARG2(a,==, b)); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(vecint_<4, int> a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmpeq_epi32(a, b); }$/;"	f	namespace:prgkern
operator ==	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator==(vecint_<4, int> a, vecint_<4, int> b) { return vecbool_<4, int>(VECTOR_ARG(a,==, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_fstring.h	/^	INLINE bool operator>(fstring s1, fstring s2) { return *(int*)&s1 > *(int*)&s2; }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator> (int a, vecint_<1, int> b) { return vecbool_<1, int>(SCALAR_ARG1(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator> (vecint_<1, int> a, int b) { return vecbool_<1, int>(SCALAR_ARG2(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator> (vecint_<1, int> a, vecint_<1, int> b) { return vecbool_<1, int>(VECTOR_ARG(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (float a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (int a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmpgt_epi32(_mm_set1_epi32(a), b); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (int a, vecint_<4, int> b) { return vecbool_<4, int>(SCALAR_ARG1(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecint_<4, int> a, int b) { return (vecbool_<4, int>)_mm_cmpgt_epi32(a, _mm_set1_epi32(b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecint_<4, int> a, int b) { return vecbool_<4, int>(SCALAR_ARG2(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecint_<4, int> a, vecint_<4, int> b) { return (vecbool_<4, int>)_mm_cmpgt_epi32(a, b); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecint_<4, int> a, vecint_<4, int> b) { return vecbool_<4, int>(VECTOR_ARG(a, >, b)); }$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecreal_<4, float> a, float b)$/;"	f	namespace:prgkern
operator >	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator> (vecreal_<4, float> a, vecreal_<4, float> b)$/;"	f	namespace:prgkern
operator T	include/prgkern/_math.h	/^	{ operator T() { return std::numeric_limits<T>::max(); } };$/;"	f	struct:prgkern::infinity
operator []	include/prgkern/_dense.h	/^		T& operator[](unsigned i) { return (*(_Base*)this)[i]; }$/;"	f	class:prgkern::basic_dense_
operator []	include/prgkern/_dense.h	/^		const T& operator[](unsigned i) const { return (*(_Base*)this)[i]; }$/;"	f	class:prgkern::basic_dense_
operator []	include/prgkern/_fstring.h	/^		char &operator[](unsigned i) { assert(_LT(i, (unsigned)sizeof(A))); return v_[i]; }$/;"	f	class:prgkern::fstring_
operator []	include/prgkern/_fstring.h	/^		char operator[](unsigned i) const { assert(_LT(i, (unsigned)sizeof(A))); return v_[i]; }$/;"	f	class:prgkern::fstring_
operator []	include/prgkern/_index.h	/^		T &operator[](unsigned i) { _A(i); return ndx_[i]; }$/;"	f	class:prgkern::index_
operator []	include/prgkern/_index.h	/^		T operator[](unsigned i) const { _A(i); return ndx_[i]; }$/;"	f	class:prgkern::index_
operator []	include/prgkern/_index.h	/^		_Index operator[](unsigned n) const$/;"	f	class:prgkern::index_cast_
operator []	include/prgkern/_index.h	/^		unsigned operator[](const _Index1 &ndx) const$/;"	f	class:prgkern::cycle_index_cast
operator []	include/prgkern/_index.h	/^		unsigned operator[](const _Index2 &ndx) const$/;"	f	class:prgkern::cycle_index_cast
operator []	include/prgkern/_index.h	/^		unsigned operator[](const _Index3 &ndx) const$/;"	f	class:prgkern::cycle_index_cast
operator []	include/prgkern/_index.h	/^		unsigned operator[](const index_<N, int> &ndx) const$/;"	f	class:prgkern::index_cast_
operator []	include/prgkern/_m3x3dense.h	/^		const row_type &operator[](unsigned n) const { _A(n); return v_[n]; }$/;"	f	class:prgkern::mdense_
operator []	include/prgkern/_m3x3dense.h	/^		row_type &operator[](unsigned n) { _A(n); return v_[n]; }$/;"	f	class:prgkern::mdense_
operator []	include/prgkern/_mdense.h	/^		T& operator[](const _Index &ndx)$/;"	f	class:prgkern::mdense_
operator []	include/prgkern/_mdense.h	/^		const T& operator[](const _Index &ndx) const$/;"	f	class:prgkern::mdense_
operator []	include/prgkern/_sse.h	/^		float &operator[](unsigned i) { return *((float*)&f_ + i); }$/;"	f	class:prgkern::vecreal_
operator []	include/prgkern/_sse.h	/^		float operator[](unsigned i) const { return *((float*)&f_ + i); }$/;"	f	class:prgkern::vecreal_
operator []	include/prgkern/_sse.h	/^		int &operator[](unsigned i) { return *((int*)&b_ + i); }$/;"	f	class:prgkern::vecbool_
operator []	include/prgkern/_sse.h	/^		int &operator[](unsigned i) { return *((int*)&i_ + i); }$/;"	f	class:prgkern::vecint_
operator []	include/prgkern/_sse.h	/^		int operator[](unsigned i) const { return *((int*)&b_ + i); }$/;"	f	class:prgkern::vecbool_
operator []	include/prgkern/_sse.h	/^		int operator[](unsigned i) const { return *((int*)&i_ + i); }$/;"	f	class:prgkern::vecint_
operator []	include/prgkern/_sse.h	/^		value_type &operator[](unsigned i) { return v_[i]; }$/;"	f	class:prgkern::vecbool_
operator []	include/prgkern/_sse.h	/^		value_type &operator[](unsigned i) { return v_[i]; }$/;"	f	class:prgkern::vecint_
operator []	include/prgkern/_sse.h	/^		value_type &operator[](unsigned i) { return v_[i]; }$/;"	f	class:prgkern::vecreal_
operator []	include/prgkern/_sse.h	/^		value_type operator[](unsigned i) const { return v_[i]; }$/;"	f	class:prgkern::vecbool_
operator []	include/prgkern/_sse.h	/^		value_type operator[](unsigned i) const { return v_[i]; }$/;"	f	class:prgkern::vecint_
operator []	include/prgkern/_sse.h	/^		value_type operator[](unsigned i) const { return v_[i]; }$/;"	f	class:prgkern::vecreal_
operator []	include/prgkern/_stencil.h	/^		T operator[](const _Index &ndx) const$/;"	f	class:prgkern::Stencil_
operator []	include/prgkern/_v3dense.h	/^		T &operator[](size_t i) { _A(i); return v_[i]; }$/;"	f	class:prgkern::vdense_
operator []	include/prgkern/_v3dense.h	/^		const T &operator[](size_t i) const { _A(i); return v_[i]; }$/;"	f	class:prgkern::vdense_
operator []	include/prgkern/_vdense.h	/^		T& operator[](unsigned i) { return _Base::operator[](i); }$/;"	f	class:prgkern::vdense_
operator []	include/prgkern/_vdense.h	/^		const T& operator[](unsigned i) const { return _Base::operator[](i); }$/;"	f	class:prgkern::vdense_
operator ^	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator^(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_xor_ps(a, b)); }$/;"	f	namespace:prgkern
operator ^	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator^(vecint_<1, int> a, vecint_<1, int> b) { return vecint_<1, int>(VECTOR_ARG(a, ^, b)); }$/;"	f	namespace:prgkern
operator ^	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator^(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int> (_mm_xor_si128(a, b)); }$/;"	f	namespace:prgkern
operator ^	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator^(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(VECTOR_ARG(a, ^, b)); }$/;"	f	namespace:prgkern
operator __m128	include/prgkern/_sse.h	/^		operator __m128() { return b_; }$/;"	f	class:prgkern::vecbool_
operator __m128	include/prgkern/_sse.h	/^		operator __m128() { return f_; }$/;"	f	class:prgkern::vecreal_
operator __m128i	include/prgkern/_sse.h	/^		operator __m128i() { return (__m128i)b_; }$/;"	f	class:prgkern::vecbool_
operator __m128i	include/prgkern/_sse.h	/^		operator __m128i() { return i_; }$/;"	f	class:prgkern::vecint_
operator bool	include/prgkern/_sse.h	/^		operator bool() { return (bool)(v_[0] || v_[1] || v_[2] || v_[3]); }$/;"	f	class:prgkern::vecbool_
operator bool	include/prgkern/_sse.h	/^		operator bool() { return (bool)(v_[0]); }$/;"	f	class:prgkern::vecbool_
operator bool	include/prgkern/_sse.h	/^		operator bool() { return _mm_movemask_ps(b_) != 0; }$/;"	f	class:prgkern::vecbool_
operator double	include/prgkern/_time.h	/^		operator double() const { return sec_ + nsec_ * 1.e-9; }$/;"	f	struct:prgkern::system_time_t
operator float	include/prgkern/_time.h	/^		operator float() const { return float(sec_ + nsec_ * 1.e-9); }$/;"	f	struct:prgkern::system_time_t
operator unsigned	include/molkern/__moldefs.h	/^		operator unsigned() { return tm_; }$/;"	f	struct:molkern::model_time_t
operator vecint_<4, int>	include/molkern/complex/_region.h	/^			operator vecint_<4, int>() { return *this; }$/;"	f	struct:molkern::Region_::region_key_t
operator vecreal_<4, real_t>	include/molkern/complex/_region.h	/^			operator vecreal_<4, real_t>() { return *this; }$/;"	f	struct:molkern::Region_::region_vector_t
operator |	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator|(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(_mm_or_ps (a, b)); }$/;"	f	namespace:prgkern
operator |	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> operator|(vecint_<1, int> a, vecint_<1, int> b) { return vecint_<1, int>(VECTOR_ARG(a, |, b)); }$/;"	f	namespace:prgkern
operator |	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator|(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int> (_mm_or_si128 (a, b)); }$/;"	f	namespace:prgkern
operator |	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> operator|(vecint_<4, int> a, vecint_<4, int> b) { return vecint_<4, int>(VECTOR_ARG(a, |, b)); }$/;"	f	namespace:prgkern
operator ||	include/prgkern/_sse.h	/^	INLINE vecbool_<1, int> operator||(vecbool_<1, int> a, vecbool_<1, int> b) { return vecbool_<1, int>(VECTOR_ARG(a, |, b)); }$/;"	f	namespace:prgkern
operator ||	include/prgkern/_sse.h	/^	INLINE vecbool_<4, int> operator||(vecbool_<4, int> a, vecbool_<4, int> b) { return vecbool_<4, int>(VECTOR_ARG(a, |, b)); }$/;"	f	namespace:prgkern
optimizer	include/molkern/__config.h	/^		_S optimizer; \/\/ имя оптимизатора$/;"	m	class:molkern::Configure
optimizer	include/molkern/__config.h	/^		_S optimizer;$/;"	m	struct:molkern::Descriptor_
ortogonal	include/prgkern/_v3dense.h	/^	INLINE vdense_<3, T> ortogonal(const vdense_<3, T> &v)$/;"	f	namespace:prgkern
ortogonal	include/prgkern/_v3dense.h	/^	INLINE void ortogonal(vdense_<3, T> &ort, const vdense_<3, T> &v,$/;"	f	namespace:prgkern
ortonormalize	include/prgkern/_blas1.h	/^	INLINE void ortonormalize(unsigned m, unsigned n, T **v)$/;"	f	namespace:prgkern
osize	include/prgkern/_transforms.h	/^		unsigned osize() const { return fft_csize_; }$/;"	f	class:prgkern::Dfft
osize	include/prgkern/_transforms.h	/^		unsigned osize() const { return fft_size_; }$/;"	f	class:prgkern::Dfft
outfile_descriptor	include/molkern/__config.h	/^		_S outfile_descriptor;$/;"	m	class:molkern::Configure
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(ANGLE_) &p, std::ifstream *src)$/;"	m	namespace:molkern
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(ATOM_) &p, std::ifstream *src)$/;"	m	namespace:molkern
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(BOND_) &p, std::ifstream *src)$/;"	m	namespace:molkern
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(EQUI_) &p, std::ifstream *src)$/;"	m	namespace:molkern
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(NUCLEAR_) &p, std::ifstream *src)$/;"	m	namespace:molkern
p	include/molkern/forcefield/_fparams.h	/^	inline int extract_object(NDX_PARAM_PAIR(TORSION_) &p, std::ifstream *src)$/;"	m	namespace:molkern
pH	include/molkern/__config.h	/^		int pH; \/\/ pH среды$/;"	m	class:molkern::Configure
pH_	include/molkern/complex/_complex.h	/^		int pH_; \/\/ pH раствора$/;"	m	class:molkern::Complex_
pH_MAX	include/molkern/forcefield/_residome_amber.h	/^			static const int pH_MAX = 9;$/;"	m	struct:molkern::amber::_Equi
pH_MIN	include/molkern/forcefield/_residome_amber.h	/^			static const int pH_MIN = 3;$/;"	m	struct:molkern::amber::_Equi
pH_RANGE	include/molkern/forcefield/_residome_amber.h	/^			static const int pH_RANGE = pH_MAX - pH_MIN + 1;$/;"	m	struct:molkern::amber::_Equi
pad_	include/prgkern/_mesh.h	/^		unsigned pad_; \/\/ z-паддинг внешней сетки$/;"	m	class:prgkern::Mesh_
pair14s_	include/molkern/complex/_archetype.h	/^		std::vector<_Pair14>    pair14s_;   \/\/ все 1-4 пары молекулы$/;"	m	class:molkern::Archetype_
pairs_sets_	include/molkern/complex/_region.h	/^		std::vector<std::vector<unsigned> > pairs_sets_;$/;"	m	class:molkern::Region_
pairs_sets_direction_	include/molkern/complex/_region.h	/^		std::vector<unsigned> pairs_sets_direction_;$/;"	m	class:molkern::Region_
parall_	include/molkern/complex/_linkcell.h	/^		_Parall parall_; \/\/ обеспечивает счет в параллельном режиме$/;"	m	class:molkern::_Link_cell
parall_	include/molkern/complex/_verlet.h	/^		_Parall parall_; \/\/ обеспечивает счет в параллельном режиме$/;"	m	class:molkern::_Verlet_table
parall_build1_	include/molkern/complex/_verlet.h	/^		void parall_build1_(void *wparam, void *rparam, void *params)$/;"	f	class:molkern::_Verlet_table
parall_build2_	include/molkern/complex/_verlet.h	/^		void parall_build2_(void *wparam, void *rparam, void *params)$/;"	f	class:molkern::_Verlet_table
parall_compress	include/molkern/complex/_verlet.h	/^	::parall_compress(void *wparam, void *rparam, void *params)$/;"	f	class:molkern::_Verlet_table
parall_dU__dX1_	include/molkern/complex/_linkcell.h	/^		void parall_dU__dX1_(void *wparam, void *rparam, void *params=0)$/;"	f	class:molkern::_Link_cell
parall_dU__dX2_	include/molkern/complex/_linkcell.h	/^		void parall_dU__dX2_(void *wparam, void *rparam, void *params=0)$/;"	f	class:molkern::_Link_cell
parall_dU__dX_	include/molkern/complex/_verlet.h	/^		void parall_dU__dX_(void *wparam, void *rparam, void *params)$/;"	f	class:molkern::_Verlet_table
parall_gonnet_ordering	include/molkern/complex/_linkcell.h	/^		void parall_gonnet_ordering(void *wparam, void *rparam, void *params=0)$/;"	f	class:molkern::_Link_cell
parall_gonnet_ordering	include/molkern/complex/_verlet.h	/^		void parall_gonnet_ordering(void *wparam, void *rparam, void *params=0)$/;"	f	class:molkern::_Verlet_table
param	include/molkern/forcefield/_angle.h	/^		param_type param;$/;"	m	struct:molkern::Angle_
param	include/molkern/forcefield/_bond.h	/^		param_type param; \/\/ параметры связи$/;"	m	struct:molkern::Bond_
param	include/molkern/forcefield/_torsion.h	/^		param_type param;$/;"	m	struct:molkern::Torsion_
param_	include/molkern/complex/_thermostat.h	/^		_Descriptor param_; \/\/ все параметры термостата$/;"	m	class:molkern::Thermostat
param_type	include/molkern/forcefield/_angle.h	/^		typedef Params<ANGLE_, FORCEFIELD_TYPE> param_type;$/;"	t	struct:molkern::Angle_
param_type	include/molkern/forcefield/_bond.h	/^		typedef Params<BOND_, FORCEFIELD_TYPE>  param_type;$/;"	t	struct:molkern::Bond_
param_type	include/molkern/forcefield/_torsion.h	/^		typedef Params<TORSION_, FORCEFIELD_TYPE> param_type;$/;"	t	struct:molkern::Torsion_
params_	include/molkern/complex/_parallel.h	/^		void *params_; \/\/ параметры функции объекта$/;"	m	class:molkern::ParallWorker_
params_	include/molkern/complex/_parallel.h	/^		void *params_;$/;"	m	class:molkern::Parall_
parlen_	include/molkern/complex/_parallel.h	/^		unsigned parlen_; \/\/ длина одной порции данных для счета (в байтах)$/;"	m	class:molkern::Parall_
parse_	include/molkern/__config.h	/^		void parse_(const std::string &filename)$/;"	f	class:molkern::Configure
parse_	include/molkern/__config.h	/^		void parse_(int argc, char *argv[])$/;"	f	class:molkern::Configure
parse_box_string	include/molkern/complex/_region.h	/^	inline index_<3, unsigned> parse_box_string(const std::string &s)$/;"	f	namespace:molkern
parval_	include/molkern/complex/_parallel.h	/^		void *parval_; \/\/ адрес начала памяти для чтения данных$/;"	m	class:molkern::Parall_
pchg	include/molkern/forcefield/_residue_amber.h	/^			real_t pchg;$/;"	m	struct:molkern::Params::__anon3
pdb_name	include/molkern/forcefield/_atomdata.h	/^		fstring pdb_name;$/;"	m	struct:molkern::Atomdata_
pelmnt	include/molkern/forcefield/_residue_amber.h	/^			int pelmnt;$/;"	m	struct:molkern::Params::__anon3
phi	include/molkern/forcefield/_fparams.h	/^		real_t phi[maxf]; \/\/ angle phase$/;"	m	struct:molkern::Params
pieces_	include/prgkern/_iterator.h	/^			_piece *pieces_;$/;"	m	class:prgkern::piecewise_vector::iterator_
piecewise_vector	include/prgkern/_iterator.h	/^		piecewise_vector() {}$/;"	f	class:prgkern::piecewise_vector
piecewise_vector	include/prgkern/_iterator.h	/^		piecewise_vector(T *arr, unsigned count) { insert(arr, count); }$/;"	f	class:prgkern::piecewise_vector
piecewise_vector	include/prgkern/_iterator.h	/^	class piecewise_vector$/;"	c	namespace:prgkern
pname	include/molkern/forcefield/_residue_amber.h	/^			fstring pname;$/;"	m	struct:molkern::Params::__anon3
point_type	include/prgkern/_box.h	/^		typedef _Vector  point_type;$/;"	t	class:prgkern::Box_
polar	include/molkern/forcefield/_fparams.h	/^		real_t polar; \/\/ atomic polarizability$/;"	m	struct:molkern::Params
polynome	include/prgkern/_math.h	/^	T polynome(T c0, T x) { return c0; }$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c1, T c0, T x) { return c1 * x + polynome(c0, x); }$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c10, T c9, T c8, T c7, T c6, T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c2, T c1, T c0, T x) { return polynome(c2, c1, x) * x + polynome(c0, x); }$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c6, T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c7, T c6, T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c8, T c7, T c6, T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
polynome	include/prgkern/_math.h	/^	T polynome(T c9, T c8, T c7, T c6, T c5, T c4, T c3, T c2, T c1, T c0, T x)$/;"	f	namespace:prgkern
pos_	include/prgkern/_average.h	/^		unsigned pos_;$/;"	m	class:prgkern::Average_
pos_	include/prgkern/_iterator.h	/^		T pos_;$/;"	m	class:prgkern::range_iterator_
positions	include/molkern/forcefield/_residue_amber.h	/^		std::vector<_Position> positions; \/\/ x,y,z$/;"	m	struct:molkern::Params
post_barrier_	include/molkern/complex/_parallel.h	/^		boost::barrier *post_barrier_; \/\/ барьер синхронизации после выполнения работы$/;"	m	class:molkern::ParallWorker_
post_barrier_	include/molkern/complex/_parallel.h	/^		boost::barrier *post_barrier_; \/\/ барьер синхронизации после выполнения работы$/;"	m	class:molkern::Parall_
pre__barrier_	include/molkern/complex/_parallel.h	/^		boost::barrier *pre__barrier_; \/\/ барьер синхронизации перед стартом работы$/;"	m	class:molkern::ParallWorker_
pre__barrier_	include/molkern/complex/_parallel.h	/^		boost::barrier *pre__barrier_; \/\/ барьер синхронизации перед стартом работы$/;"	m	class:molkern::Parall_
pressure	include/molkern/__config.h	/^		real_t pressure; \/\/ давление$/;"	m	struct:molkern::Descriptor_
pressure	include/molkern/__config.h	/^		real_t pressure; \/\/ целевое давление$/;"	m	class:molkern::Configure
pressure_	include/molkern/complex/_ensemble.h	/^		Average_<real_t> pressure_;$/;"	m	class:molkern::Ensemble_
prev_average_time_	include/molkern/complex/_verlet.h	/^		real_t prev_average_time_; \/\/ предыдущее среднее время на шаг (сек)$/;"	m	class:molkern::_Verlet_table
prev_model_time_	include/molkern/complex/_verlet.h	/^		model_time_t prev_model_time_; \/\/ предыдущее модельное время (число fs)$/;"	m	class:molkern::_Verlet_table
prev_system_time_	include/molkern/complex/_verlet.h	/^		system_time_t prev_system_time_; \/\/ предыдущее астрономическое время (число секунд)$/;"	m	class:molkern::_Verlet_table
prg_exception	include/prgkern/_string.h	/^	class prg_exception : public std::exception {};$/;"	c	namespace:prgkern
prgkern	include/prgkern/_assert.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_average.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_blas1.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_box.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_dense.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_for.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_fstring.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_graph.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_index.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_iterator.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_m3x3dense.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_math.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_mdense.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_mesh.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_minimize.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_minimize_lbfgs.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_minimize_round.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_os.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_pproc.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_random.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_regex.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_rotator.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_sse.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_stencil.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_string.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_time.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_transforms.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_type.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_v3dense.h	/^namespace prgkern$/;"	n
prgkern	include/prgkern/_vdense.h	/^namespace prgkern$/;"	n
print	include/molkern/forcefield/_forcefield.h	/^	::print() const$/;"	f	class:molkern::__Forcefield
print	include/molkern/forcefield/_residome.h	/^	::print() const$/;"	f	class:molkern::basic_residome_
print	include/molkern/forcefield/_rotamer.h	/^		void print() const$/;"	f	class:molkern::Rotamer_
print_user_information	include/molkern/__moldefs.h	/^	inline void print_user_information()$/;"	f	namespace:molkern
prn_water_	include/molkern/complex/_mdynamics.h	/^		bool prn_water_; \/\/ печатать ли воду в файл статистики$/;"	m	class:molkern::Integrator_
process_time	include/molkern/__config.h	/^		unsigned process_time; \/\/ время динамики (fs), преобразовано из ввода (ps)$/;"	m	class:molkern::Configure
process_time__	include/molkern/__config.h	/^		real_t process_time__; \/\/ переменная для преобразования вводимого времени$/;"	m	class:molkern::Configure
proper	include/molkern/forcefield/_fparams.h	/^		int proper; \/\/ proper (1) & unproper(0) dihedral$/;"	m	struct:molkern::Params
ptoa	include/prgkern/_string.h	/^	INLINE std::string ptoa(void *v)  { return make_string(v); }$/;"	f	namespace:prgkern
ptype	include/molkern/forcefield/_residue_amber.h	/^			fstring ptype;$/;"	m	struct:molkern::Params::__anon3
ptypex	include/molkern/forcefield/_residue_amber.h	/^			int ptypex;$/;"	m	struct:molkern::Params::__anon3
push	include/prgkern/_average.h	/^		void push(const S &s)$/;"	f	class:prgkern::Average_
q0	include/molkern/forcefield/_fparams.h	/^		real_t q0;  \/\/ equlibrium distance$/;"	m	struct:molkern::Params
radius	include/molkern/forcefield/_atomdata.h	/^		union { real_t radius; real_t sigma; };$/;"	m	union:molkern::Atomdata_::__anon12
radius	include/molkern/forcefield/_fparams.h	/^		union { real_t radius; real_t sigma; }; \/\/ effective radius of atom$/;"	m	union:molkern::Params::__anon11
radius2_	include/prgkern/_stencil.h	/^		T radius2_; \/\/\/< квадрат радиуса взаимодействия$/;"	m	class:prgkern::Stencil_
ran0	include/prgkern/_random.h	/^	INLINE _Real ran0(_Real max=1., _Real min=0.)$/;"	f	namespace:prgkern
ran0	include/prgkern/_random.h	/^	INLINE unsigned ran0(unsigned max) { return (unsigned)(max * ran0<double>()); }$/;"	f	namespace:prgkern
ran0	include/prgkern/_v3dense.h	/^	INLINE vdense_<N,T> ran0(const vdense_<N,T> &max,$/;"	f	namespace:prgkern
rand48	include/prgkern/_random.h	/^	typedef boost::rand48 rand48;$/;"	t	namespace:prgkern
randgen	include/prgkern/_random.h	/^		randgen(long seed=1) : idum_(seed_ctrl_(seed)) {}$/;"	f	class:prgkern::randgen
randgen	include/prgkern/_random.h	/^	class randgen$/;"	c	namespace:prgkern
range_iterator	include/prgkern/_iterator.h	/^	typedef range_iterator_<int>  range_iterator;$/;"	t	namespace:prgkern
range_iterator_	include/prgkern/_iterator.h	/^		range_iterator_(const range_iterator_ &t) : pos_(t.pos_) {}$/;"	f	class:prgkern::range_iterator_
range_iterator_	include/prgkern/_iterator.h	/^	class range_iterator_$/;"	c	namespace:prgkern
range_iterator_	include/prgkern/_iterator.h	/^    range_iterator_(T pos=0) : pos_(pos) {}$/;"	f	class:prgkern::range_iterator_
rcp	include/prgkern/_math.h	/^	template <typename T> INLINE T rcp(T a) { return T(1.f) \/ a; }$/;"	f	namespace:prgkern
rcp	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rcp(vecreal_<4, float> a)$/;"	f	namespace:prgkern
rcut_	include/molkern/complex/_linkcell.h	/^		real_t rcut_; \/\/ радиус взаимодействия$/;"	m	class:molkern::_Link_cell
rcutoff_	include/molkern/forcefield/_interactions.h	/^		static real_t rcutoff_; \/\/ радиус взаимодействия$/;"	m	struct:molkern::Interaction_
rcutoff_	src/__moldefs.cpp	/^	real_t Interaction_<C612>::rcutoff_;$/;"	m	class:molkern::Interaction_	file:
read	include/molkern/complex/_archetype.h	/^		read(_I2T<POSITION_>, const real_t *x, unsigned freedom_type, _Atom *atoms) const$/;"	f	class:molkern::Archetype_
read	include/molkern/complex/_complex.h	/^		unsigned read(_I2T<POSITION_>, const real_t *x, _Atom *atoms)$/;"	f	class:molkern::Complex_
read	include/molkern/complex/_molecule.h	/^		template <typename _Atom> unsigned read(_I2T<POSITION_>, const real_t *x, _Atom *atoms) const$/;"	f	class:molkern::Molecule_
read_data	include/molkern/complex/_linkcell.h	/^	::read_data(__LJAtom<T1, T2> *ljatom1, __LJAtom<T1, T2> *ljatom2, unsigned pos) const$/;"	f	class:molkern::_Link_cell
read_data	include/molkern/complex/_linkcell.h	/^	::read_data(__LJAtom<T1, T2> *ljatom1, __LJAtom<T1, T2> *ljatom2,$/;"	f	class:molkern::_Link_cell
read_data	include/molkern/complex/_region.h	/^	INLINE void read_data(__LJAtom<T1, T2> &ljatom, const S *atom)$/;"	f	namespace:molkern
read_data	include/molkern/complex/_region.h	/^	INLINE void read_data(unsigned m, __LJAtom<vecreal_<N, real_t>, vecint_ <N, int> > &ljatom,$/;"	f	namespace:molkern
read_data	include/molkern/complex/_verlet.h	/^	::read_data(__LJAtom<T1, T2> *ljatom1, __LJAtom<T1, T2> *ljatom2,$/;"	f	class:molkern::_Verlet_table
read_data	include/molkern/complex/_verlet.h	/^	::read_data(__LJAtom<T1, T2> *ljatoms, const std::vector<unsigned> &row)$/;"	f	class:molkern::_Verlet_table
read_empty	include/molkern/complex/_region.h	/^	INLINE void read_empty(__LJAtom<T1, T2> &ljatom, const S *atom) {}$/;"	f	namespace:molkern
read_empty	include/molkern/complex/_region.h	/^	INLINE void read_empty(__LJAtom<vecreal_<4, real_t>, vecint_ <4, int> > &ljatom, const S *atom)$/;"	f	namespace:molkern
read_md_position	include/molkern/complex/_complex.h	/^		void read_md_position(const vector_t *x, const vector_t *v)$/;"	f	class:molkern::Complex_
read_position_	include/molkern/complex/_archetype.h	/^		read_position_(_I2T<YES_ATOM_>, const real_t *x, _Atom *atoms, bool &use_atomdata) const$/;"	f	class:molkern::Archetype_
read_position_	include/molkern/complex/_archetype.h	/^		read_position_(_I2T<YES_CM_ | NO_UNION_>, const real_t *x, _Atom *atoms, bool &use_atomdata) const$/;"	f	class:molkern::Archetype_
read_position_	include/molkern/complex/_archetype.h	/^		read_position_(_I2T<YES_CM_ | YES_UNION_>, const real_t *x, _Atom *atoms, bool &use_atomdata) const$/;"	f	class:molkern::Archetype_
read_position_	include/molkern/complex/_archetype.h	/^		read_position_(_I2T<YES_ROTAMER_>, const real_t *x, _Atom *atoms, bool &use_atomdata) const$/;"	f	class:molkern::Archetype_
real_t	include/molkern/__moldefs.h	/^	typedef float real_t;$/;"	t	namespace:molkern
real_type	include/molkern/complex/_complex.h	/^		typedef real_t          real_type;$/;"	t	class:molkern::Complex_
real_type	include/molkern/complex/_molecule.h	/^		typedef real_t  real_type;$/;"	t	class:molkern::Molecule_
rebuild_verlet_table_count_	include/molkern/complex/_verlet.h	/^		unsigned rebuild_verlet_table_count_; \/\/ число перестроек Верлет таблицы$/;"	m	class:molkern::_Verlet_table
region_	include/molkern/complex/_complex.h	/^		_Region *region_; \/\/ область взаимодействия$/;"	m	class:molkern::Complex_
region_	include/molkern/complex/_linkcell.h	/^		_Region *region_; \/\/ область взаимодействия$/;"	m	class:molkern::_Link_cell
region_	include/molkern/complex/_verlet.h	/^		std::auto_ptr<_Region> region_; \/\/ область взаимодействия с гридом по rskin$/;"	m	class:molkern::_Verlet_table
region_key_t	include/molkern/complex/_region.h	/^			region_key_t(const vecint_<4, int> &v) : vecint_<4, int>(v) {}$/;"	f	struct:molkern::Region_::region_key_t
region_key_t	include/molkern/complex/_region.h	/^			region_key_t(int x0=0, int x1=0, int x2=0, int x3=0)$/;"	f	struct:molkern::Region_::region_key_t
region_key_t	include/molkern/complex/_region.h	/^		struct region_key_t : public vecint_ <4, int>$/;"	s	class:molkern::Region_
region_key_type	include/molkern/complex/_region.h	/^		typedef region_key_t                    region_key_type;$/;"	t	class:molkern::Region_
region_type	include/molkern/complex/_complex.h	/^		typedef _Region         region_type;$/;"	t	class:molkern::Complex_
region_vector_t	include/molkern/complex/_region.h	/^			region_vector_t(const vecreal_<4, real_t> &v) : vecreal_<4, real_t>(v) {}$/;"	f	struct:molkern::Region_::region_vector_t
region_vector_t	include/molkern/complex/_region.h	/^			region_vector_t(const vector_t &x) : vecreal_<4, real_t>(x[0], x[1], x[2], (real_t)0.f) {}$/;"	f	struct:molkern::Region_::region_vector_t
region_vector_t	include/molkern/complex/_region.h	/^			region_vector_t(real_t x0=0.f, real_t x1=0.f, real_t x2=0.f, real_t x3=0.f)$/;"	f	struct:molkern::Region_::region_vector_t
region_vector_t	include/molkern/complex/_region.h	/^		struct region_vector_t : public vecreal_<4, real_t>$/;"	s	class:molkern::Region_
region_vector_type	include/molkern/complex/_region.h	/^		typedef region_vector_t                 region_vector_type;$/;"	t	class:molkern::Region_
remove	include/molkern/complex/_thermostat.h	/^	INLINE void remove(_I2T<IMPULSE_>, _Molecule *molecule)$/;"	f	namespace:molkern
res_seq	include/molkern/forcefield/_atomdata.h	/^		int res_seq;$/;"	m	struct:molkern::Atomdata_
reserve	include/molkern/complex/_region.h	/^		void reserve(unsigned n)$/;"	f	class:molkern::Node_
resi	include/molkern/forcefield/_residome_amber.h	/^			fstring resi;$/;"	m	struct:molkern::amber::_Equi
residata_	include/molkern/forcefield/_residome_amber.h	/^		_VectorR residata_;$/;"	m	class:molkern::Residome_
residome_	include/molkern/complex/_archetype.h	/^		const _Residome *residome_;     \/\/ база данных топологии$/;"	m	class:molkern::Archetype_
residome_	include/molkern/complex/_complex.h	/^		const _Residome *residome_; \/\/ указатель на топологию$/;"	m	class:molkern::Complex_
residome_type	include/molkern/complex/_archetype.h	/^		typedef _Residome     residome_type;$/;"	t	class:molkern::Archetype_
residue	include/molkern/forcefield/_atomdata.h	/^		std::string residue;$/;"	m	struct:molkern::Atomdata_
residue_atomdata_	include/molkern/forcefield/_residue.h	/^		_VectorT residue_atomdata_;$/;"	m	class:molkern::basic_residue_
residue_count	include/molkern/forcefield/_residome_amber.h	/^		const unsigned residue_count = STATIC_DIMENSION(basic_residue_name, fstring);$/;"	m	namespace:molkern::amber
residue_type	include/molkern/forcefield/_residome.h	/^		typedef _Residue residue_type;$/;"	t	class:molkern::basic_residome_
residue_type	include/molkern/forcefield/_residome_amber.h	/^		typedef _Base::residue_type  residue_type;$/;"	t	class:molkern::Residome_
residues_	include/molkern/forcefield/_residome.h	/^		_VectorR residues_;$/;"	m	class:molkern::basic_residome_
resize	include/molkern/complex/_linkcell.h	/^		void resize(real_t rcut, real_t density)$/;"	f	class:molkern::_Link_cell
resize	include/molkern/complex/_region.h	/^	::resize(index_type sz, real_t interaction_radius, const vector_t *T, bool is_print)$/;"	f	class:molkern::Region_
resize	include/molkern/complex/_verlet.h	/^	::resize(real_t rskin, real_t density)$/;"	f	class:molkern::_Verlet_table
resize	include/prgkern/_average.h	/^		void resize(unsigned sz)$/;"	f	class:prgkern::Average_
resize	include/prgkern/_mdense.h	/^		unsigned resize(unsigned n1, unsigned n2) { return _Base::resize_(_Index(n1, n2)); }$/;"	f	class:prgkern::mdense_
resize_	include/prgkern/_dense.h	/^		unsigned resize_(const _Index &n)$/;"	f	class:prgkern::basic_dense_
restype	include/molkern/forcefield/_residue_amber.h	/^			int restype;$/;"	m	struct:molkern::Params::__anon9
result	include/prgkern/_math.h	/^	template <> struct _FLOG2<1> { enum { result = 0 }; };$/;"	e	enum:prgkern::_FLOG2::__anon40
result	include/prgkern/_math.h	/^	template <int N> struct _FLOG2 { enum { result = 1 + _FLOG2<(N >> 1)>::result }; };$/;"	e	enum:prgkern::_FLOG2::__anon39
result	include/prgkern/_type.h	/^	template <bool n> struct Bool2Type_ { enum { result = n }; };$/;"	e	enum:prgkern::Bool2Type_::__anon32
result	include/prgkern/_type.h	/^	template <int n> struct Int2Type_ { enum { result = n }; };$/;"	e	enum:prgkern::Int2Type_::__anon31
result_type	include/prgkern/_random.h	/^		typedef typename boost::normal_distribution<_Real>::result_type result_type;$/;"	t	class:prgkern::normal_distribution_
resx	include/molkern/forcefield/_residue.h	/^		int resx; \/\/ используется как идентификатор отдельной молекулы (в растворе)$/;"	m	struct:molkern::__ResidueAtomdata
resx	include/molkern/forcefield/_residue_amber.h	/^			int resx;  \/\/ используется, чтобы найти связные цепи (молекулы) в растворе$/;"	m	struct:molkern::Params::__anon1
retlen_	include/molkern/complex/_parallel.h	/^		unsigned retlen_; \/\/ длина одной порции результата (в байтах)$/;"	m	class:molkern::Parall_
retval_	include/molkern/complex/_parallel.h	/^		void *retval_; \/\/ адрес начала памяти для сохранения результата$/;"	m	class:molkern::Parall_
retval_	include/molkern/complex/_parallel.h	/^		void *retval_; \/\/ начало массива для складывания результатов (return)$/;"	m	class:molkern::ParallWorker_
rmsd	include/prgkern/_blas1.h	/^	INLINE T rmsd(unsigned n, const T *v1, const T *v2)$/;"	f	namespace:prgkern
rnid	include/molkern/forcefield/_atomdata.h	/^		int rnid[max_bond]; \/\/\/ относительный идентификатор соседа$/;"	m	struct:molkern::Atomdata_
rol0	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> rol0(vecint_<1, int> i) { return i; }$/;"	f	namespace:prgkern
rol0	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol0(vecint_<4, int> i) { return i; }$/;"	f	namespace:prgkern
rol0	include/prgkern/_sse.h	/^	INLINE vecreal_<1, float> rol0(vecreal_<1, float> i) { return i; }$/;"	f	namespace:prgkern
rol0	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rol0(vecreal_<4, float> i) { return i; }$/;"	f	namespace:prgkern
rol0	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> rol0(vecreal_<4, float> f) { return f; }$/;"	f	namespace:prgkern
rol1	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol1(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(2, 1, 0, 3)); }$/;"	f	namespace:prgkern
rol1	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol1(vecint_<4, int> i) { return vecint_<4, int>(i[1], i[2], i[3], i[0]); }$/;"	f	namespace:prgkern
rol1	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rol1(vecreal_<4, float> i) { return vecreal_<4, float>(i[1], i[2], i[3], i[0]); }$/;"	f	namespace:prgkern
rol1	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> rol1(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(2, 1, 0, 3)); }$/;"	f	namespace:prgkern
rol2	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol2(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(1, 0, 3, 2)); }$/;"	f	namespace:prgkern
rol2	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol2(vecint_<4, int> i) { return vecint_<4, int>(i[2], i[3], i[0], i[1]); }$/;"	f	namespace:prgkern
rol2	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rol2(vecreal_<4, float> i) { return vecreal_<4, float>(i[2], i[3], i[0], i[1]); }$/;"	f	namespace:prgkern
rol2	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> rol2(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(1, 0, 3, 2)); }$/;"	f	namespace:prgkern
rol3	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol3(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(0, 3, 2, 1)); }$/;"	f	namespace:prgkern
rol3	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> rol3(vecint_<4, int> i) { return vecint_<4, int>(i[3], i[0], i[1], i[2]); }$/;"	f	namespace:prgkern
rol3	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rol3(vecreal_<4, float> i) { return vecreal_<4, float>(i[3], i[0], i[1], i[2]); }$/;"	f	namespace:prgkern
rol3	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> rol3(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(0, 3, 2, 1)); }$/;"	f	namespace:prgkern
roots_	include/molkern/complex/_archetype.h	/^		std::vector<unsigned>   roots_;     \/\/ стартовые ротамеры (их число равно числу несвязанных цепей)$/;"	m	class:molkern::Archetype_
ror0	include/prgkern/_sse.h	/^	INLINE vecint_<1, int> ror0(vecint_<1, int> i) { return i; }$/;"	f	namespace:prgkern
ror0	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror0(vecint_<4, int> i) { return i; }$/;"	f	namespace:prgkern
ror0	include/prgkern/_sse.h	/^	INLINE vecreal_<1, float> ror0(vecreal_<1, float> i) { return i; }$/;"	f	namespace:prgkern
ror0	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> ror0(vecreal_<4, float> i) { return i; }$/;"	f	namespace:prgkern
ror0	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> ror0(vecreal_<4, float> f) { return f; }$/;"	f	namespace:prgkern
ror1	include/molkern/complex/_region.h	/^	INLINE void ror1(__LJAtom<real_t, int> &atom)$/;"	f	namespace:molkern
ror1	include/molkern/complex/_region.h	/^	INLINE void ror1(__LJAtom<vecreal_<1, real_t>, vecint_ <1, int> > &atom)$/;"	f	namespace:molkern
ror1	include/molkern/complex/_region.h	/^	INLINE void ror1(__LJAtom<vecreal_<4, real_t>, vecint_ <4, int> > &atom)$/;"	f	namespace:molkern
ror1	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror1(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(0, 3, 2, 1)); }$/;"	f	namespace:prgkern
ror1	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror1(vecint_<4, int> i) { return vecint_<4, int>(i[3], i[0], i[1], i[2]); }$/;"	f	namespace:prgkern
ror1	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> ror1(vecreal_<4, float> i) { return vecreal_<4, float>(i[3], i[0], i[1], i[2]); }$/;"	f	namespace:prgkern
ror1	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> ror1(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(0, 3, 2, 1)); }$/;"	f	namespace:prgkern
ror2	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror2(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(1, 0, 3, 2)); }$/;"	f	namespace:prgkern
ror2	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror2(vecint_<4, int> i) { return vecint_<4, int>(i[2], i[3], i[0], i[1]); }$/;"	f	namespace:prgkern
ror2	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> ror2(vecreal_<4, float> i) { return vecreal_<4, float>(i[2], i[3], i[0], i[1]); }$/;"	f	namespace:prgkern
ror2	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> ror2(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(1, 0, 3, 2)); }$/;"	f	namespace:prgkern
ror3	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror3(vecint_<4, int> i) { return _mm_shuffle_epi32(i, _MM_SHUFFLE(2, 1, 0, 3)); }$/;"	f	namespace:prgkern
ror3	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> ror3(vecint_<4, int> i) { return vecint_<4, int>(i[1], i[2], i[3], i[0]); }$/;"	f	namespace:prgkern
ror3	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> ror3(vecreal_<4, float> i) { return vecreal_<4, float>(i[1], i[2], i[3], i[0]); }$/;"	f	namespace:prgkern
ror3	include/prgkern/_sse.h	/^  INLINE vecreal_<4, float> ror3(vecreal_<4, float> f) { return _mm_shuffle_ps(f, f, _MM_SHUFFLE(2, 1, 0, 3)); }$/;"	f	namespace:prgkern
rotamer_angle	include/molkern/forcefield/_rotamer.h	/^	INLINE real_t rotamer_angle(const A *atoms, const Rotamer_ &rotamer1,$/;"	f	namespace:molkern
rotamer_angle	include/molkern/forcefield/_rotamer.h	/^	INLINE real_t rotamer_angle(const vector_t &A, const vector_t &B,$/;"	f	namespace:molkern
rotamer_from	include/molkern/forcefield/_rotamer.h	/^		unsigned rotamer_from;$/;"	m	struct:molkern::RotamerConnect_
rotamer_moment	include/molkern/forcefield/_rotamer.h	/^	INLINE real_t rotamer_moment(const A *atoms, const Rotamer_ *rotamer,$/;"	f	namespace:molkern
rotamer_paste	include/molkern/forcefield/_rotamer.h	/^	inline void rotamer_paste(A1 *a1, const A2 *a2, const Rotamer_ &rotamer1,$/;"	f	namespace:molkern
rotamer_to	include/molkern/forcefield/_rotamer.h	/^		unsigned rotamer_to;$/;"	m	struct:molkern::RotamerConnect_
rotamer_type	include/molkern/complex/_archetype.h	/^		typedef _Rotamer      rotamer_type;$/;"	t	class:molkern::Archetype_
rotamer_type	include/molkern/complex/_complex.h	/^		typedef _Rotamer        rotamer_type;$/;"	t	class:molkern::Complex_
rotamer_type	include/molkern/forcefield/_residue.h	/^		typedef _Rotamer rotamer_type;$/;"	t	class:molkern::basic_residue_
rotamer_vector_	include/molkern/complex/_archetype.h	/^		std::vector<unsigned> rotamer_vector_; \/\/ хранилище номеров атомов для ротамеров$/;"	m	class:molkern::Archetype_
rotamers	include/molkern/forcefield/_residue_amber.h	/^		std::vector<_Rotamer> rotamers;$/;"	m	struct:molkern::Params
rotamers_	include/molkern/complex/_archetype.h	/^		std::vector<_Rotamer>   rotamers_;  \/\/ идентификаторы атомов, входящих в ротамеры$/;"	m	class:molkern::Archetype_
rotamers_	include/molkern/complex/_complex.h	/^		std::vector<_Rotamer> rotamers_; \/\/ цепи всех входящих ротамеров$/;"	m	class:molkern::Complex_
rotamers_	include/molkern/forcefield/_residue.h	/^		std::vector<_Rotamer> rotamers_;$/;"	m	class:molkern::basic_residue_
rotate	include/molkern/complex/_geom_tool.h	/^	INLINE void rotate(_I2T<EULER_ROTATOR_>, Atom *atom, const __Atom *atom__,$/;"	f	namespace:molkern
rotate	include/molkern/complex/_geom_tool.h	/^	INLINE void rotate(_I2T<EULER_ROTATOR_>, Atom *atom, const vector_t &angle, const vector_t &X0,$/;"	f	namespace:molkern
rotate	include/molkern/complex/_geom_tool.h	/^	INLINE void rotate(_I2T<XYZ_ROTATOR_>, Atom *atom, const vector_t &angle, const vector_t &X0,$/;"	f	namespace:molkern
round	include/prgkern/_math.h	/^	INLINE double round(double x)$/;"	f	namespace:prgkern
round	include/prgkern/_sse.h	/^	INLINE vecreal_<1, T> round(vecreal_<1, T> a)$/;"	f	namespace:prgkern
round	include/prgkern/_sse.h	/^	INLINE vecreal_<4, double> round(vecreal_<4, double> a)$/;"	f	namespace:prgkern
round	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> round(vecreal_<4, float> a)$/;"	f	namespace:prgkern
round_minimize_	include/prgkern/_minimize_round.h	/^		T round_minimize_(T &bx, T &f0, T &g0, T (*fn)(unsigned, const T *, T *, void *param), void *param,$/;"	f	class:prgkern::Minimizer_
round_mode_saver_	include/prgkern/_sse.h	/^		round_mode_saver_() : mode_(_MM_GET_ROUNDING_MODE()) {}$/;"	f	struct:prgkern::round_mode_saver_
round_mode_saver_	include/prgkern/_sse.h	/^	struct round_mode_saver_$/;"	s	namespace:prgkern
row_type	include/prgkern/_m3x3dense.h	/^		typedef vdense_<N, T> row_type;$/;"	t	class:prgkern::mdense_
rskin_	include/molkern/complex/_verlet.h	/^		real_t rskin_; \/\/ текущий skin радиус$/;"	m	class:molkern::_Verlet_table
rskin_average_	include/molkern/complex/_verlet.h	/^		real_t rskin_average_; \/\/ среднее <rskin> за прошедшее число шагов$/;"	m	class:molkern::_Verlet_table
rskin_compress_factor	include/molkern/__config.h	/^		real_t rskin_compress_factor;$/;"	m	class:molkern::Configure
rskin_step_	include/molkern/complex/_verlet.h	/^		real_t rskin_step_; \/\/ текущее направление и величина изменения rskin$/;"	m	class:molkern::_Verlet_table
rskin_width	include/molkern/__config.h	/^		real_t rskin_width;$/;"	m	class:molkern::Configure
rsqrt	include/prgkern/_math.h	/^	template <typename T> INLINE T rsqrt(T a) { return T(1.f) \/ sqrt(a); }$/;"	f	namespace:prgkern
rsqrt	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> rsqrt(vecreal_<4, float> a)$/;"	f	namespace:prgkern
rtrim	include/prgkern/_string.h	/^	INLINE std::string rtrim(const std::string &s) { return ba::trim_right_copy(s); }$/;"	f	namespace:prgkern
rtrim	include/prgkern/_string.h	/^	INLINE void rtrim(std::string &s) { ba::trim_right(s); }$/;"	f	namespace:prgkern
run	include/molkern/complex/_mdynamics.h	/^		void run(const _Thermostat *thermostat, _Molecule *molecule,$/;"	f	class:molkern::Integrator_
s_	include/prgkern/_index.h	/^		_Index s_; \/\/\/< размеры области$/;"	m	class:prgkern::index_cast_
sa_	include/prgkern/_rotator.h	/^		T ca_, sa_;$/;"	m	class:prgkern::Rotator
safe_acos	include/prgkern/_math.h	/^	template <typename T> INLINE T safe_acos(T cosphi)$/;"	f	namespace:prgkern
sample_statistics	include/molkern/complex/_ensemble.h	/^		void sample_statistics(_Molecule *molecule)$/;"	f	class:molkern::Ensemble_
sample_statistics	include/molkern/complex/_thermostat.h	/^		void sample_statistics(_Molecule *molecule) const$/;"	f	class:molkern::Thermostat
sampling_time	include/molkern/__config.h	/^		unsigned sampling_time; \/\/ шаг набора статистики (fs)$/;"	m	class:molkern::Configure
sampling_time	include/molkern/__config.h	/^		unsigned sampling_time; \/\/ шаг считывания статистики$/;"	m	struct:molkern::Descriptor_
sampling_time_	include/molkern/complex/_mdynamics.h	/^		unsigned sampling_time_; \/\/ шаг сбора статистики (fs)$/;"	m	class:molkern::Integrator_
save	include/molkern/complex/_archetype.h	/^	::save(_I2T<FORMAT_BMM_>, std::ofstream &file, const _Atom *atoms, bool) const$/;"	f	class:molkern::Archetype_
save	include/molkern/complex/_archetype.h	/^	::save(_I2T<FORMAT_HIN_>, std::ofstream &file, const _Atom *atoms, bool) const$/;"	f	class:molkern::Archetype_
save	include/molkern/complex/_archetype.h	/^	::save(_I2T<FORMAT_MOL2_>, std::ofstream &file, const _Atom *atoms, bool) const$/;"	f	class:molkern::Archetype_
save	include/molkern/complex/_archetype.h	/^	::save(_I2T<FORMAT_PDB_>, std::ofstream &file, const _Atom *atoms,$/;"	f	class:molkern::Archetype_
save	include/molkern/complex/_archetype.h	/^	::save(const std::string &filename, const _Atom *atoms, bool prn_hydrogens) const$/;"	f	class:molkern::Archetype_
save	include/molkern/complex/_complex.h	/^		template <int FORMAT> void save(_I2T<FORMAT>, std::ofstream &file, bool prn_water=false,$/;"	f	class:molkern::Complex_
save	include/molkern/complex/_complex.h	/^	::save(const std::string &filename, bool prn_water, bool prn_hydrogens,$/;"	f	class:molkern::Complex_
save_data	include/molkern/complex/_linkcell.h	/^	::save_data(__LJAtom<T1, T2> *ljatom1, __LJAtom<T1, T2> *ljatom2, unsigned pos)$/;"	f	class:molkern::_Link_cell
save_data	include/molkern/complex/_linkcell.h	/^	::save_data(__LJAtom<T1, T2> *ljatom1, __LJAtom<T1, T2> *ljatom2, unsigned pos1, unsigned pos2)$/;"	f	class:molkern::_Link_cell
save_data	include/molkern/complex/_verlet.h	/^	::save_data(vector_t *F, const __LJAtom<T1, T2> *ljatoms, const std::vector<unsigned> &row)$/;"	f	class:molkern::_Verlet_table
scalar_product	include/prgkern/_blas1.h	/^	INLINE T scalar_product(unsigned n, const T *x, const T *y)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_blas1.h	/^	INLINE T scalar_product(unsigned n, const T *x, const T *y, const T *z)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_index.h	/^	INLINE T scalar_product(const index_<1, T> &v1, const index_<1, T> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_index.h	/^	INLINE T scalar_product(const index_<2, T> &v1, const index_<2, T> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_index.h	/^	INLINE T scalar_product(const index_<3, T> &v1, const index_<3, T> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_index.h	/^	INLINE T scalar_product(const index_<4, T> &v1, const index_<4, T> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_index.h	/^	INLINE T scalar_product(const index_<N, T> &v1, const index_<N, T> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_v3dense.h	/^	scalar_product(const vdense_<N, T1> &v1, const vdense_<N, T2> &v2)$/;"	f	namespace:prgkern
scalar_product	include/prgkern/_vdense.h	/^	INLINE T scalar_product(const vdense_<UNLIMITED_, T> &v1,$/;"	f	namespace:prgkern
scaling	include/molkern/complex/_ensemble.h	/^		std::string scaling(_Molecule *molecule)$/;"	f	class:molkern::Ensemble_
scaling	include/molkern/complex/_thermostat.h	/^		std::string scaling(_Molecule *molecule) const$/;"	f	class:molkern::Thermostat
sec_	include/prgkern/_time.h	/^		double sec_;$/;"	m	struct:prgkern::system_time_t
seed	include/prgkern/_random.h	/^		void seed()$/;"	f	class:prgkern::randgen
seed	include/prgkern/_random.h	/^		void seed(long s) { idum_ = seed_ctrl_(s); }$/;"	f	class:prgkern::randgen
seed_ctrl_	include/prgkern/_random.h	/^		long seed_ctrl_(long s)	{	return s == RAN0_MASK ? s : s ^ RAN0_MASK; }$/;"	f	class:prgkern::randgen
seq	include/molkern/forcefield/_residue_amber.h	/^			int seq;    \/\/ don't used (number of atom in seq)$/;"	m	struct:molkern::Params::__anon1
seq	include/molkern/forcefield/_residue_amber.h	/^			int seq;$/;"	m	struct:molkern::Params::__anon9
set	include/molkern/complex/_thermostat.h	/^		void set(_I2T<TEMPERATURE_>, _Real temperature)$/;"	f	class:molkern::maxwell_distribution_ensemble_
set	include/molkern/complex/_thermostat.h	/^	INLINE void set(_I2T<TEMPERATURE_>, real_t temperature,$/;"	f	namespace:molkern
set	include/molkern/forcefield/_rotamer.h	/^		void set(_I2T<ATOM_>, unsigned *ndx) { ndx_ = ndx; }$/;"	f	class:molkern::Chain_
set	include/molkern/forcefield/_rotamer.h	/^		void set(_I2T<ATOM_>, unsigned *ndx) { ndx_ = ndx; }$/;"	f	class:molkern::Rotamer_
set_barrier	include/molkern/forcefield/_interactions.h	/^		static void set_barrier(real_t barrier)$/;"	f	struct:molkern::Interaction_
share_	include/molkern/complex/_verlet.h	/^		std::vector<std::vector<unsigned> > share_;$/;"	m	class:molkern::_Verlet_table
share_atoms_	include/molkern/complex/_verlet.h	/^			std::vector<unsigned> share_atoms_; \/\/ разделяемые атомы группы$/;"	m	struct:molkern::_Verlet_table::Group_
shift_factor_	include/molkern/forcefield/_interactions.h	/^		static real_t shift_factor_; \/\/ константа сдвига$/;"	m	struct:molkern::Interaction_
shift_factor_	src/__moldefs.cpp	/^	real_t Interaction_<C612>::shift_factor_;$/;"	m	class:molkern::Interaction_	file:
short_name	include/molkern/forcefield/_residome_amber.h	/^			const char *short_name;$/;"	m	struct:molkern::amber::_Short
short_residue_name_	include/molkern/forcefield/_residome_amber.h	/^		const _Short short_residue_name_[] =$/;"	m	namespace:molkern::amber
sid	include/molkern/forcefield/_atomdata.h	/^		int sid;$/;"	m	struct:molkern::Atomdata_
sigma	include/molkern/complex/_complex.h	/^			real_t sigma; \/\/\/< параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::Complex_::_Atom
sigma	include/molkern/complex/_complex.h	/^			real_t sigma; \/\/\/< параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::Complex_::_LJAtom
sigma	include/molkern/complex/_region.h	/^		T1 sigma; \/\/ параметр LJ 6-12 + 1-4 взаимодействия$/;"	m	struct:molkern::__LJAtom
sigma	include/molkern/forcefield/_atomdata.h	/^		union { real_t radius; real_t sigma; };$/;"	m	union:molkern::Atomdata_::__anon12
sigma	include/molkern/forcefield/_fparams.h	/^		union { real_t radius; real_t sigma; }; \/\/ effective radius of atom$/;"	m	union:molkern::Params::__anon11
sign	include/prgkern/_math.h	/^	template <typename T, typename T2> INLINE T sign(T a, T2 b) { return b >= 0 ? abs(a) : -abs(a); }$/;"	f	namespace:prgkern
sign	include/prgkern/_math.h	/^	template <typename T> INLINE int sign(T a) { return a >= 0 ? (a > 0 ? 1 : 0) : -1; }$/;"	f	namespace:prgkern
signed16_t	include/molkern/__moldefs.h	/^	typedef signed short    signed16_t;$/;"	t	namespace:molkern
signed32_t	include/molkern/__moldefs.h	/^	typedef signed int      signed32_t;$/;"	t	namespace:molkern
signed8_t	include/molkern/__moldefs.h	/^	typedef signed char     signed8_t;$/;"	t	namespace:molkern
sin_angle	include/prgkern/_v3dense.h	/^	INLINE T sin_angle(const vdense_<3, T> &v1, const vdense_<3, T> &v2)$/;"	f	namespace:prgkern
sinc	include/prgkern/_time.h	/^		static void sinc()$/;"	f	class:prgkern::function_timer_t
size	include/prgkern/_fstring.h	/^		unsigned size() const { return sizeof(A); }$/;"	f	class:prgkern::fstring_
size	include/prgkern/_index.h	/^		unsigned size() const { return component_product(s_); }$/;"	f	class:prgkern::index_cast_
size	include/prgkern/_mesh.h	/^		unsigned size() const { return size_; }$/;"	f	class:prgkern::Mesh_
size	include/prgkern/_sse.h	/^		enum { size = 1 };$/;"	e	enum:prgkern::vecbool_::__anon27
size	include/prgkern/_sse.h	/^		enum { size = 1 };$/;"	e	enum:prgkern::vecint_::__anon28
size	include/prgkern/_sse.h	/^		enum { size = 1 };$/;"	e	enum:prgkern::vecreal_::__anon29
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecbool_::__anon21
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecbool_::__anon24
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecint_::__anon22
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecint_::__anon25
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecreal_::__anon23
size	include/prgkern/_sse.h	/^		enum { size = 4 };$/;"	e	enum:prgkern::vecreal_::__anon26
size	include/prgkern/_v3dense.h	/^		unsigned size() const { return N; }$/;"	f	class:prgkern::vdense_
size_	include/prgkern/_mesh.h	/^		unsigned size_; \/\/ должное число элементов в каждой внешней сетке$/;"	m	class:prgkern::Mesh_
slow_thread	include/prgkern/_time.h	/^		static unsigned slow_thread()$/;"	f	class:prgkern::function_timer_t
smooth	include/prgkern/_stencil.h	/^	INLINE void smooth(const S &stencil, T *array_to, unsigned inc_to, const C1 &ndxcast_to,$/;"	f	namespace:prgkern
smooth_fn_	include/prgkern/_stencil.h	/^		T smooth_fn_(T x2, T param) const { return exp( x2 * param); }$/;"	f	class:prgkern::Stencil_
smooth_fn_tune_	include/prgkern/_stencil.h	/^		void smooth_fn_tune_(T xlimit2, T accuracy=0.1)$/;"	f	class:prgkern::Stencil_
sort	include/prgkern/_math.h	/^	template <typename T> INLINE void sort(T &n0, T &n1)$/;"	f	namespace:prgkern
sort	include/prgkern/_math.h	/^	template <typename T> INLINE void sort(T &n0, T &n1, T &n2)$/;"	f	namespace:prgkern
sort	include/prgkern/_math.h	/^	template <typename T> INLINE void sort(T &n0, T &n1, T &n2, T &n3)$/;"	f	namespace:prgkern
sqr	include/prgkern/_math.h	/^	template <typename T> INLINE T sqr(T s) { return s * s; }$/;"	f	namespace:prgkern
sqr	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> sqr(vecreal_<4, float> a) { return _mm_mul_ps(a, a); }$/;"	f	namespace:prgkern
sqr	include/prgkern/_sse.h	/^	INLINE vecreal_<N, T> sqr(vecreal_<N, T> a) { return a * a; }$/;"	f	namespace:prgkern
sqrt	include/prgkern/_sse.h	/^	INLINE vecreal_<4, float> sqrt(vecreal_<4, float> a) { return _mm_sqrt_ps(a); }$/;"	f	namespace:prgkern
sqrt_pi	include/molkern/forcefield/_interactions.h	/^		static const real_t sqrt_pi;$/;"	m	struct:molkern::Interaction_
sqrt_pi	src/__moldefs.cpp	/^	const real_t Interaction_<C612>::sqrt_pi = (real_t)( 1.7724538509055158819194275565678254L);$/;"	m	class:molkern::Interaction_	file:
start_parallel_running	include/molkern/complex/_parallel.h	/^		void start_parallel_running(_Fn fn, void *retval=0, void *params=0)$/;"	f	class:molkern::ParallWorker_
start_parallel_running	include/molkern/complex/_parallel.h	/^		void start_parallel_running(void (Object::*fn)(void *, void *, void *),$/;"	f	class:molkern::Parall_
start_time_	include/prgkern/_time.h	/^		system_time_t start_time_;$/;"	m	class:prgkern::function_timer_t
startatomx	include/molkern/forcefield/_residue_amber.h	/^			int startatomx;$/;"	m	struct:molkern::Params::__anon9
statfile_descriptor	include/molkern/__config.h	/^		_S statfile_descriptor;$/;"	m	class:molkern::Configure
steep	include/molkern/__config.h	/^		int steep; \/\/ число начальных итераций, выполняемых steep методом$/;"	m	class:molkern::Configure
steep	include/molkern/__config.h	/^		int steep;$/;"	m	struct:molkern::Descriptor_
stick_from	include/molkern/forcefield/_rotamer.h	/^		unsigned stick_from;$/;"	m	struct:molkern::RotamerConnect_
stick_to	include/molkern/forcefield/_rotamer.h	/^		unsigned stick_to;$/;"	m	struct:molkern::RotamerConnect_
stick_type	include/molkern/forcefield/_rotamer.h	/^		typedef _Stick  stick_type;$/;"	t	class:molkern::Rotamer_
sticks_	include/molkern/forcefield/_rotamer.h	/^		std::vector<_Stick> sticks_; \/\/ индексы атомов, определяющих угол вращения ротамера$/;"	m	class:molkern::Rotamer_
store	include/prgkern/_sse.h	/^		template <typename S> void store(S *p) const { *p = v_[0]; *(p + 1) = v_[1]; *(p + 2) = v_[2]; *(p + 3) = v_[3]; }$/;"	f	class:prgkern::vecreal_
store	include/prgkern/_sse.h	/^		template <typename S> void store(S *p) const { *p = v_[0]; }$/;"	f	class:prgkern::vecreal_
store	include/prgkern/_sse.h	/^		void store(float *p) const { _mm_storeu_ps(p, f_); }$/;"	f	class:prgkern::vecreal_
store	include/prgkern/_sse.h	/^		void store(int *p) const { _mm_storeu_si128((__m128i*)p, i_); }$/;"	f	class:prgkern::vecint_
stpmax	include/molkern/__config.h	/^		real_t stpmax; \/\/ ограничение по смещению по координатам$/;"	m	class:molkern::Configure
stpmax	include/molkern/__config.h	/^		real_t stpmax;$/;"	m	struct:molkern::Descriptor_
stpmin	include/molkern/__config.h	/^		real_t stpmin; \/\/ минимальное смещение по координатам, обрывающее оптимизацию$/;"	m	class:molkern::Configure
stpmin	include/molkern/__config.h	/^		real_t stpmin;$/;"	m	struct:molkern::Descriptor_
str_	include/molkern/__config.h	/^		std::string str_() const$/;"	f	class:molkern::Configure
sub_iterator	include/prgkern/_iterator.h	/^		sub_iterator() : it_() {}$/;"	f	class:prgkern::sub_iterator
sub_iterator	include/prgkern/_iterator.h	/^		sub_iterator(const Iterator &it) : it_(it) {}$/;"	f	class:prgkern::sub_iterator
sub_iterator	include/prgkern/_iterator.h	/^		sub_iterator(const sub_iterator &it) : it_(it.it_) {}$/;"	f	class:prgkern::sub_iterator
sub_iterator	include/prgkern/_iterator.h	/^	class sub_iterator$/;"	c	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE T summarize(vecreal_<1, T> v) { return v[0]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE double summarize(vecreal_<1, double> v) { return v[0]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE double summarize(vecreal_<4, double> v) { return v[0] + v[1] + v[2] + v[3]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE float summarize(vecreal_<1, float> v) { return v[0]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE float summarize(vecreal_<4, float> v) { return v[0] + v[1] + v[2] + v[3]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE int summarize(vecint_<1, int> v) { return v[0]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	INLINE int summarize(vecint_<4, int> v) { return v[0] + v[1] + v[2] + v[3]; }$/;"	f	namespace:prgkern
summarize	include/prgkern/_sse.h	/^	template <typename T> INLINE T summarize(T v) { return v; }$/;"	f	namespace:prgkern
swap	include/prgkern/_box.h	/^		void swap(Box_ b)$/;"	f	class:prgkern::Box_
swap	include/prgkern/_box.h	/^	INLINE void swap(Box_<N, T> &b1, Box_<N, T> &b2)$/;"	f	namespace:prgkern
swap	include/prgkern/_fstring.h	/^	INLINE void swap(fstring_<A> &s1, fstring_<A> &s2)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<2,T> &n1, index_<2,T> &n2)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<2,T> &ndx)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<3,T> &n1, index_<3,T> &n2)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<3,T> &ndx)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<4,T> &n1, index_<4,T> &n2)$/;"	f	namespace:prgkern
swap	include/prgkern/_index.h	/^	INLINE void swap(index_<4,T> &ndx)$/;"	f	namespace:prgkern
swap	include/prgkern/_v3dense.h	/^	INLINE void swap(vdense_<2, T> &v1, vdense_<2, T> &v2)$/;"	f	namespace:prgkern
swap	include/prgkern/_v3dense.h	/^	INLINE void swap(vdense_<3, T> &v1, vdense_<3, T> &v2)$/;"	f	namespace:prgkern
swap	include/prgkern/_v3dense.h	/^	INLINE void swap(vdense_<4, T> &v1, vdense_<4, T> &v2)$/;"	f	namespace:prgkern
sym_index_	include/prgkern/_index.h	/^		sym_index_() {}$/;"	f	struct:prgkern::sym_index_
sym_index_	include/prgkern/_index.h	/^		sym_index_(T a0)$/;"	f	struct:prgkern::sym_index_
sym_index_	include/prgkern/_index.h	/^		sym_index_(T a0, T a1)$/;"	f	struct:prgkern::sym_index_
sym_index_	include/prgkern/_index.h	/^		sym_index_(T a0, T a1, T a2)$/;"	f	struct:prgkern::sym_index_
sym_index_	include/prgkern/_index.h	/^		sym_index_(T a0, T a1, T a2, T a3)$/;"	f	struct:prgkern::sym_index_
sym_index_	include/prgkern/_index.h	/^	struct sym_index_ : public index_<N, T>$/;"	s	namespace:prgkern
symb_params_	include/molkern/forcefield/_forcefield.h	/^		_VectorS symb_params_;$/;"	m	class:molkern::__Forcefield
system_time_t	include/prgkern/_time.h	/^		system_time_t(double t=0., long ns=0.) : sec_(t), nsec_(ns) {}$/;"	f	struct:prgkern::system_time_t
system_time_t	include/prgkern/_time.h	/^	struct system_time_t$/;"	s	namespace:prgkern
sz_	include/molkern/complex/_region.h	/^		_Index sz_; \/\/ число ячеек по каждой координате$/;"	m	class:molkern::Region_
sz_	include/prgkern/_mesh.h	/^		index_<N, unsigned> sz_; \/\/ пользовательская размерность сетки$/;"	m	class:prgkern::Mesh_
t12_matrix_	include/molkern/complex/_archetype.h	/^		matrix<ACCUMULATE_> t12_matrix_;   \/\/ матрица 1-2 связности всех атомов$/;"	m	class:molkern::Archetype_
t13_matrix_	include/molkern/complex/_archetype.h	/^		matrix<ACCUMULATE_> t13_matrix_;   \/\/ матрица 1-3 связности всех атомов$/;"	m	class:molkern::Archetype_
t14_matrix_	include/molkern/complex/_archetype.h	/^		matrix<ACCUMULATE_> t14_matrix_;   \/\/ матрица 1-4 связности всех атомов$/;"	m	class:molkern::Archetype_
t_	include/molkern/complex/_region.h	/^		vecreal_<4, real_t> t_, _1t_;$/;"	m	class:molkern::Region_
target_energy_	include/molkern/complex/_ensemble.h	/^		real_t target_energy_; \/\/ константа данного ансамбля$/;"	m	class:molkern::Ensemble_
target_pressure_	include/molkern/complex/_ensemble.h	/^		real_t target_pressure_;$/;"	m	class:molkern::Ensemble_
target_temperature_	include/molkern/complex/_ensemble.h	/^		real_t target_temperature_; \/\/ константа данного ансамбля$/;"	m	class:molkern::Ensemble_
tau2_	include/molkern/forcefield/_interactions.h	/^		static real_t tau2_; \/\/\/< квадрат точки сшивки псевдопотенциала tau2 = sqr(r \/ sigma)$/;"	m	struct:molkern::Interaction_
tau2_	src/__moldefs.cpp	/^	real_t Interaction_<C612>::tau2_;$/;"	m	class:molkern::Interaction_	file:
tb_matrix_	include/molkern/complex/_archetype.h	/^		matrix<ACCUMULATE_> tb_matrix_; \/\/ матрица, позволяющая найти все связи атома$/;"	m	class:molkern::Archetype_
temperature	include/molkern/__config.h	/^		real_t temperature; \/\/ температура ансамбля$/;"	m	struct:molkern::Descriptor_
temperature	include/molkern/__config.h	/^		real_t temperature; \/\/ целевая температура$/;"	m	class:molkern::Configure
temperature	include/molkern/complex/_thermostat.h	/^		_Real temperature() const { return temperature_; }$/;"	f	class:molkern::maxwell_distribution_
temperature_	include/molkern/complex/_thermostat.h	/^		_Real temperature_; \/\/ температура распределений$/;"	m	class:molkern::maxwell_distribution_ensemble_
temperature_	include/molkern/complex/_thermostat.h	/^		_Real temperature_;$/;"	m	class:molkern::maxwell_distribution_
test_Wolfe_	include/prgkern/_minimize.h	/^		bool test_Wolfe_(unsigned n, T xa, T fa, T ga, T xb, T fb, T gb, T wolfe1, T wolfe2) const$/;"	f	class:prgkern::Line_minimizer_
test_Wolfe_	include/prgkern/_minimize_round.h	/^			bool test_Wolfe_(unsigned n, T xa, T fa, T ga, T xb, T fb, T gb, T wolfe1, T wolfe2) const$/;"	f	class:prgkern::Round_minimizer_
test_tolerance_	include/prgkern/_minimize.h	/^		bool test_tolerance_(unsigned n, T xa, T fa, T ga, T xb, T fb, T gb, T xtol, T ftol, T gtol) const$/;"	f	class:prgkern::Line_minimizer_
test_tolerance_	include/prgkern/_minimize_round.h	/^			bool test_tolerance_(unsigned n, T xa, T fa, T ga, T xb, T fb, T gb, T xtol, T ftol, T gtol) const$/;"	f	class:prgkern::Round_minimizer_
thread_	include/molkern/complex/_parallel.h	/^		std::vector<boost::thread *> thread_; \/\/ потоки$/;"	m	class:molkern::ParallWorker_
thread_	include/molkern/complex/_parallel.h	/^		std::vector<boost::thread *> thread_; \/\/ потоки$/;"	m	class:molkern::Parall_
thread_count	include/molkern/complex/_parallel.h	/^		unsigned thread_count() const { return thread_count_; }$/;"	f	class:molkern::ParallWorker_
thread_count	include/molkern/complex/_parallel.h	/^		unsigned thread_count() const { return thread_count_; }$/;"	f	class:molkern::Parall_
thread_count_	include/molkern/complex/_parallel.h	/^		unsigned thread_count_; \/\/ число потоков для обработки$/;"	m	class:molkern::ParallWorker_
thread_count_	include/molkern/complex/_parallel.h	/^		unsigned thread_count_; \/\/ число потоков для обработки$/;"	m	class:molkern::Parall_
thread_data_	include/molkern/complex/_parallel.h	/^			thread_data_(ParallWorker_ *worker, unsigned nth) : worker_(worker), nth_(nth) {}$/;"	f	struct:molkern::ParallWorker_::thread_data_
thread_data_	include/molkern/complex/_parallel.h	/^			thread_data_(Parall_ *worker, unsigned nth) : worker_(worker), nth_(nth) {}$/;"	f	struct:molkern::Parall_::thread_data_
thread_data_	include/molkern/complex/_parallel.h	/^		struct thread_data_$/;"	s	class:molkern::ParallWorker_
thread_data_	include/molkern/complex/_parallel.h	/^		struct thread_data_$/;"	s	class:molkern::Parall_
threads	include/molkern/__config.h	/^		int threads; \/\/ число потоков выполнения$/;"	m	class:molkern::Configure
time	include/prgkern/_time.h	/^		static double time() { return accumulate_time[NT]; }$/;"	f	class:prgkern::function_timer_t
tm_	include/molkern/__moldefs.h	/^		unsigned tm_;$/;"	m	struct:molkern::model_time_t
to_lower	include/prgkern/_fstring.h	/^	INLINE fstring to_lower(const fstring &s)$/;"	f	namespace:prgkern
to_lower	include/prgkern/_fstring.h	/^	INLINE void to_lower(fstring &s)$/;"	f	namespace:prgkern
to_lower	include/prgkern/_string.h	/^	INLINE std::string to_lower(const std::string &s) { return ba::to_lower_copy(s); }$/;"	f	namespace:prgkern
to_lower	include/prgkern/_string.h	/^	INLINE void to_lower(std::string &s) { ba::to_lower(s); }$/;"	f	namespace:prgkern
to_upper	include/prgkern/_fstring.h	/^	INLINE fstring to_upper(const fstring &s)$/;"	f	namespace:prgkern
to_upper	include/prgkern/_fstring.h	/^	INLINE void to_upper(fstring &s)$/;"	f	namespace:prgkern
to_upper	include/prgkern/_string.h	/^	INLINE std::string to_upper(const std::string &s) { return ba::to_upper_copy(s); }$/;"	f	namespace:prgkern
to_upper	include/prgkern/_string.h	/^	INLINE void to_upper(std::string &s) { ba::to_upper(s); }$/;"	f	namespace:prgkern
top	include/prgkern/_average.h	/^		const S &top() const$/;"	f	class:prgkern::Average_
top	include/prgkern/_box.h	/^		_Vector &top() { return u_; }$/;"	f	class:prgkern::Box_
top	include/prgkern/_box.h	/^		const _Vector &top() const { return u_; }$/;"	f	class:prgkern::Box_
top	include/prgkern/_index.h	/^		_Index top() const { return b_ + s_; }$/;"	f	class:prgkern::index_cast_
tor12s_	include/molkern/complex/_archetype.h	/^		std::set<unsigned>  tor12s_; \/\/ номера связей в bonds, которые принадлежат центрам торсионов$/;"	m	class:molkern::Archetype_
torsion_type	include/molkern/complex/_archetype.h	/^		typedef _Torsion      torsion_type;$/;"	t	class:molkern::Archetype_
torsions_	include/molkern/complex/_archetype.h	/^		std::vector<_Torsion>   torsions_;  \/\/ все дигедралы молекулы$/;"	m	class:molkern::Archetype_
translation	include/molkern/forcefield/_residue_amber.h	/^			real_t translation[3];$/;"	m	struct:molkern::Params::__anon4
translation_vector	include/molkern/complex/_region.h	/^		vector_t translation_vector() const { return vector_t(T_[0], T_[1], T_[2]); }$/;"	f	class:molkern::Region_
translation_vector	include/molkern/complex/_region.h	/^		vector_t translation_vector(unsigned pos1, unsigned pos2) const$/;"	f	class:molkern::Region_
trim	include/prgkern/_string.h	/^	INLINE std::string trim(const std::string &s) { return ba::trim_copy(s); }$/;"	f	namespace:prgkern
trim	include/prgkern/_string.h	/^	INLINE std::string trim(const std::string &s, const char *subs)$/;"	f	namespace:prgkern
trim	include/prgkern/_string.h	/^	INLINE void trim(std::string &s) { ba::trim(s); }$/;"	f	namespace:prgkern
trim	include/prgkern/_string.h	/^	INLINE void trim(std::string &s, const char *subs)$/;"	f	namespace:prgkern
truncate	include/prgkern/_sse.h	/^	INLINE vecint_<4, int> truncate(vecreal_<4, float> a)$/;"	f	namespace:prgkern
tune_param_	include/prgkern/_stencil.h	/^		T tune_param_; \/\/\/< параметр тьюнинга внутренней функции$/;"	m	class:prgkern::Stencil_
type	include/molkern/forcefield/_residue_amber.h	/^			fstring type;$/;"	m	struct:molkern::Params::__anon1
type	include/prgkern/_type.h	/^	template <> struct extended<char> { typedef short type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<double> { typedef double type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<float> { typedef float type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<int> { typedef int type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<short> { typedef int type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<unsigned char> { typedef unsigned short type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<unsigned int> { typedef unsigned int type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct extended<unsigned short> { typedef unsigned int type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_type.h	/^	template <> struct maxtype<double, double> { typedef double type; };$/;"	t	struct:prgkern::maxtype
type	include/prgkern/_type.h	/^	template <> struct maxtype<double, float> { typedef double type; };$/;"	t	struct:prgkern::maxtype
type	include/prgkern/_type.h	/^	template <> struct maxtype<float, double> { typedef double type; };$/;"	t	struct:prgkern::maxtype
type	include/prgkern/_type.h	/^	template <> struct maxtype<float, float> { typedef float type; };$/;"	t	struct:prgkern::maxtype
type	include/prgkern/_v3dense.h	/^	{ typedef vdense_<N, typename extended<T>::type > type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_vdense.h	/^	template <unsigned N> struct extended<vdense_<N, double> > { typedef vdense_<N, double> type; };$/;"	t	struct:prgkern::extended
type	include/prgkern/_vdense.h	/^	template <unsigned N> struct extended<vdense_<N, float> > { typedef vdense_<N, double> type; };$/;"	t	struct:prgkern::extended
typex	include/molkern/forcefield/_residue_amber.h	/^			int typex;  \/\/ don't used$/;"	m	struct:molkern::Params::__anon1
u_	include/prgkern/_box.h	/^		_Vector u_; \/\/\/< правый верхний край$/;"	m	class:prgkern::Box_
uniq_atoms_	include/molkern/complex/_verlet.h	/^			std::vector<unsigned> uniq_atoms_[MAX_GROUP_ELEM];$/;"	m	struct:molkern::_Verlet_table::Group_
unsigned16_t	include/molkern/__moldefs.h	/^	typedef unsigned short  unsigned16_t;$/;"	t	namespace:molkern
unsigned32_t	include/molkern/__moldefs.h	/^	typedef unsigned int    unsigned32_t;$/;"	t	namespace:molkern
unsigned8_t	include/molkern/__moldefs.h	/^	typedef unsigned char   unsigned8_t;$/;"	t	namespace:molkern
unsigned_t	include/molkern/__moldefs.h	/^	typedef unsigned unsigned_t;$/;"	t	namespace:molkern
update	include/molkern/complex/_linkcell.h	/^		void update(bool print=NO_PRINT) { update_(); }$/;"	f	class:molkern::_Link_cell
update	include/molkern/complex/_verlet.h	/^		void update(bool print=NO_PRINT)$/;"	f	class:molkern::_Verlet_table
update	include/prgkern/_minimize_lbfgs.h	/^		void update(_Real *d, _Real f, const _Real *x, const _Real *g)$/;"	f	class:prgkern::Updater
update	include/prgkern/_minimize_lbfgs.h	/^	::update(_Real *d, _Real f, const _Real *x, const _Real *g)$/;"	f	class:prgkern::Updater
update_	include/molkern/complex/_linkcell.h	/^	::update_()$/;"	f	class:molkern::_Link_cell
update_	include/molkern/complex/_verlet.h	/^	::update_()$/;"	f	class:molkern::_Verlet_table
update_	include/molkern/complex/_verlet.h	/^	::update_(unsigned pos)$/;"	f	class:molkern::_Verlet_table
update_	include/molkern/complex/_verlet.h	/^	::update_(unsigned pos, unsigned pos__)$/;"	f	class:molkern::_Verlet_table
urange_iterator	include/prgkern/_iterator.h	/^	typedef range_iterator_<unsigned>  urange_iterator;$/;"	t	namespace:prgkern
use_hydrogens	include/molkern/__config.h	/^		bool use_hydrogens; \/\/ использовать водороды файла (может пригодиться для FORMAT_BMM_)$/;"	m	struct:molkern::Descriptor_
use_hydrogens	include/molkern/__config.h	/^		bool use_hydrogens; \/\/ наличие водородов в выводе$/;"	m	struct:molkern::Descriptor_
use_water	include/molkern/__config.h	/^		bool use_water; \/\/ использовать молекулы кислорода (водные мостики) файла$/;"	m	struct:molkern::Descriptor_
use_water	include/molkern/__config.h	/^		bool use_water; \/\/ наличие молкул воды в выводе$/;"	m	struct:molkern::Descriptor_
v	include/molkern/forcefield/_fparams.h	/^		real_t v[maxf]; \/\/ potential$/;"	m	struct:molkern::Params
v_	include/prgkern/_fstring.h	/^		char v_[sizeof(A)];$/;"	m	class:prgkern::fstring_
v_	include/prgkern/_iterator.h	/^		S *v_; \/\/ опорный массив$/;"	m	class:prgkern::array_iterator
v_	include/prgkern/_iterator.h	/^		const S *v_; \/\/ опорный массив$/;"	m	class:prgkern::const_array_iterator
v_	include/prgkern/_m3x3dense.h	/^		row_type v_[N];$/;"	m	class:prgkern::mdense_
v_	include/prgkern/_sse.h	/^		T v_[1];$/;"	m	class:prgkern::vecreal_
v_	include/prgkern/_sse.h	/^		T v_[4];$/;"	m	class:prgkern::vecreal_
v_	include/prgkern/_sse.h	/^		int v_[1];$/;"	m	class:prgkern::vecbool_
v_	include/prgkern/_sse.h	/^		int v_[1];$/;"	m	class:prgkern::vecint_
v_	include/prgkern/_sse.h	/^		int v_[4];$/;"	m	class:prgkern::vecbool_
v_	include/prgkern/_sse.h	/^		int v_[4];$/;"	m	class:prgkern::vecint_
v_	include/prgkern/_v3dense.h	/^		T v_[N];$/;"	m	class:prgkern::vdense_
valency_order	include/molkern/forcefield/_atomdata.h	/^	inline float valency_order(char c)$/;"	f	namespace:molkern
value	include/prgkern/_math.h	/^	template <int S> struct Degree<S, 0> { enum { value = 1 }; };$/;"	e	enum:prgkern::Degree::__anon38
value	include/prgkern/_math.h	/^	{ enum { value = S * Degree<S, DEGREE-1>::value }; };$/;"	e	enum:prgkern::Degree::__anon37
value	include/prgkern/_random.h	/^		_Real value(_Real x)$/;"	f	class:prgkern::normal_distribution_
value_type	include/molkern/complex/_region.h	/^		typedef S                               value_type;$/;"	t	class:molkern::Region_
value_type	include/molkern/complex/_region.h	/^		typedef S value_type;$/;"	t	class:molkern::Node_
value_type	include/molkern/complex/_region.h	/^		typedef void value_type;$/;"	t	class:molkern::Node_
value_type	include/molkern/forcefield/_residue.h	/^		typedef _Pair value_type;$/;"	t	class:molkern::basic_residue_
value_type	include/prgkern/_iterator.h	/^		typedef Member value_type; \/\/ нужен для внешних пользователей$/;"	t	class:prgkern::sub_iterator
value_type	include/prgkern/_iterator.h	/^		typedef S value_type; \/\/ нужен для внешних пользователей$/;"	t	class:prgkern::array_iterator
value_type	include/prgkern/_iterator.h	/^		typedef S value_type; \/\/ нужен для внешних пользователей$/;"	t	class:prgkern::const_array_iterator
value_type	include/prgkern/_m3x3dense.h	/^		typedef T value_type;$/;"	t	class:prgkern::mdense_
value_type	include/prgkern/_sse.h	/^		typedef T value_type;$/;"	t	class:prgkern::vecreal_
value_type	include/prgkern/_sse.h	/^		typedef float value_type;$/;"	t	class:prgkern::vecreal_
value_type	include/prgkern/_sse.h	/^		typedef int value_type;$/;"	t	class:prgkern::vecbool_
value_type	include/prgkern/_sse.h	/^		typedef int value_type;$/;"	t	class:prgkern::vecint_
value_type	include/prgkern/_v3dense.h	/^		typedef T value_type;$/;"	t	class:prgkern::vdense_
variate_generator_	include/prgkern/_random.h	/^		variate_generator_(Distribution d, Generator g=Generator())$/;"	f	class:prgkern::variate_generator_
variate_generator_	include/prgkern/_random.h	/^	class variate_generator_$/;"	c	namespace:prgkern
vbool_t	include/molkern/__moldefs.h	/^	typedef vecbool_<1, int>     vbool_t;$/;"	t	namespace:molkern
vbool_t	include/molkern/__moldefs.h	/^	typedef vecbool_<4, int>     vbool_t;$/;"	t	namespace:molkern
vdense_	include/prgkern/_v3dense.h	/^		vdense_() {} \/\/ undefined vector, used for efficiency in implementation$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_v3dense.h	/^		vdense_(T s) { for_<0, N>::expand(bll::_1 = s, v_); }$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_v3dense.h	/^		vdense_(T s0, T s1)$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_v3dense.h	/^		vdense_(T s0, T s1, T s2)$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_v3dense.h	/^		vdense_(T s0, T s1, T s2, T s3)$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_v3dense.h	/^	class vdense_$/;"	c	namespace:prgkern
vdense_	include/prgkern/_vdense.h	/^		explicit vdense_(unsigned n) { resize(n, T()); }$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^		vdense_() {}$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^		vdense_(_I2T<ORTOGONAL_UNIT_>, const vdense_ &f, const vdense_ &unit) : _Base(f)$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^		vdense_(_I2T<UNIT_>, const vdense_ &dir) : _Base(dir.size())$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^		vdense_(const T *x1, const T *x2) : _Base(x1, x2) {}$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^		vdense_(unsigned n, const T *x) : _Base(&x[0], &x[n]) {}$/;"	f	class:prgkern::vdense_
vdense_	include/prgkern/_vdense.h	/^	class vdense_<UNLIMITED_, T> : public basic_dense_<1, T>$/;"	c	namespace:prgkern
vecbool_	include/prgkern/_sse.h	/^		vecbool_() : b_(_mm_setzero_ps()) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_() { SCALAR_OPERATOR(v_, =, 0); }$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(__m128 b) : b_(b) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(__m128i b) : b_((__m128)b) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(bool b) : b_(_mm_cmpgt_ps(_mm_set1_ps(b), _mm_setzero_ps())) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(bool b)$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(bool v0)$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(bool v0, bool v1, bool v2, bool v3)$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(const vecbool_ &b) : b_(b.b_) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(const vecbool_ &b) { VECTOR_OPERATOR(v_, =, b); }$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(int b) : b_(_mm_cmpgt_ps(_mm_set1_ps((unsigned)b), _mm_setzero_ps())) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^		vecbool_(unsigned b) : b_(_mm_cmpgt_ps(_mm_set1_ps(b), _mm_setzero_ps())) {}$/;"	f	class:prgkern::vecbool_
vecbool_	include/prgkern/_sse.h	/^	template <>	class vecbool_<1, int>$/;"	c	namespace:prgkern
vecbool_	include/prgkern/_sse.h	/^	template <>	class vecbool_<4, int>$/;"	c	namespace:prgkern
vecbool_	include/prgkern/_sse.h	/^	template <> class vecbool_<4, int>$/;"	c	namespace:prgkern
vecint_	include/prgkern/_sse.h	/^		vecint_() : i_(_mm_setzero_si128()) {}$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_() { SCALAR_OPERATOR(v_, =, 0); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(__m128i i) : i_(i) {}$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(const vecbool_<1, int> &b) { VECTOR_OPERATOR(v_, = , b); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(const vecbool_<4, int> &b) { VECTOR_OPERATOR(v_, = , b); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(const vecint_ &i) : i_(i.i_) {}$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(const vecint_ &i) { VECTOR_OPERATOR(v_, =, i); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(int i) : i_(_mm_set1_epi32(i)) {}$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(int i) { SCALAR_OPERATOR(v_, =, i); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(int i0, int i1, int i2, int i3) { MULTISCALAR_OPERATOR(v_, =, i0, i1, i2, i3); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(int i0, int i1, int i2, int i3) { i_ = _mm_set_epi32(i3, i2, i1, i0); }$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^		vecint_(vecbool_<4, int> b) : i_((__m128i)b) {}$/;"	f	class:prgkern::vecint_
vecint_	include/prgkern/_sse.h	/^	template <> class vecint_<1, int>$/;"	c	namespace:prgkern
vecint_	include/prgkern/_sse.h	/^	template <> class vecint_<4, int>$/;"	c	namespace:prgkern
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(S f) { SCALAR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(S f0, S f1, S f2, S f3) { MULTISCALAR_OPERATOR(v_, =, f0, f1, f2, f3); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(const S *f) { VECTOR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(const vecint_<1, S> &f) { VECTOR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(const vecint_<4, S> &f) { VECTOR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(const vecreal_<1, S> &f) { VECTOR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		template <typename S> vecreal_(const vecreal_<4, S> &f) { VECTOR_OPERATOR(v_, =, f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_() : f_(_mm_setzero_ps()) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_() { SCALAR_OPERATOR(v_, =, 0.f); }$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_(__m128 f) : f_(f) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_(const float *f) : f_(_mm_loadu_ps(f)) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_(const vecreal_ &f) : f_(f.f_) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_(float f) : f_(_mm_set1_ps(f)) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^		vecreal_(float f0, float f1, float f2, float f3) : f_(_mm_set_ps(f3, f2, f1, f0)) {}$/;"	f	class:prgkern::vecreal_
vecreal_	include/prgkern/_sse.h	/^	template <typename T> class vecreal_<1, T>$/;"	c	namespace:prgkern
vecreal_	include/prgkern/_sse.h	/^	template <typename T> class vecreal_<4, T>$/;"	c	namespace:prgkern
vecreal_	include/prgkern/_sse.h	/^	template<> class vecreal_<4, float>$/;"	c	namespace:prgkern
vector_product	include/prgkern/_v3dense.h	/^	INLINE void vector_product(vdense_<3, T1> &r,$/;"	f	namespace:prgkern
vector_product	include/prgkern/_v3dense.h	/^	vector_product(const vdense_<3, T1> &v1, const vdense_<3, T2> &v2)$/;"	f	namespace:prgkern
vector_t	include/molkern/__moldefs.h	/^	typedef vdense_<3, real_t> vector_t;$/;"	t	namespace:molkern
velement_count	include/prgkern/_sse.h	/^	template <typename T> INLINE unsigned velement_count(unsigned count)$/;"	f	namespace:prgkern
verlet_forces_	include/molkern/complex/_verlet.h	/^		std::vector<std::vector<vector_t> > verlet_forces_;$/;"	m	class:molkern::_Verlet_table
verlet_groups_	include/molkern/complex/_verlet.h	/^		std::vector<Group_> verlet_groups_;$/;"	m	class:molkern::_Verlet_table
verlet_offsets_	include/molkern/complex/_verlet.h	/^		std::vector<vector_t> verlet_offsets_; \/\/ координаты атомов для контроля перестройки таблицы$/;"	m	class:molkern::_Verlet_table
verlet_table_	include/molkern/complex/_verlet.h	/^		std::vector<std::vector<unsigned> > verlet_table_; \/\/ Верлет таблица$/;"	m	class:molkern::_Verlet_table
vint_t	include/molkern/__moldefs.h	/^	typedef vecint_ <1, int>     vint_t;$/;"	t	namespace:molkern
vint_t	include/molkern/__moldefs.h	/^	typedef vecint_ <4, int>     vint_t;$/;"	t	namespace:molkern
vm_	include/molkern/__config.h	/^		boost::program_options::variables_map vm_;$/;"	m	class:molkern::Configure
volume	include/prgkern/_box.h	/^		T volume() const$/;"	f	class:prgkern::Box_
vreal_t	include/molkern/__moldefs.h	/^	typedef vecreal_<1, real_t>  vreal_t;$/;"	t	namespace:molkern
vreal_t	include/molkern/__moldefs.h	/^	typedef vecreal_<4, real_t>  vreal_t;$/;"	t	namespace:molkern
wait	include/molkern/complex/_parallel.h	/^		void wait() { post_barrier_->wait(); }$/;"	f	class:molkern::ParallWorker_
wait	include/molkern/complex/_parallel.h	/^		void wait() { post_barrier_->wait(); }$/;"	f	class:molkern::Parall_
water	include/molkern/__config.h	/^		_S water; \/\/ Формат строки "-wSPCBOX,{0|C|R|X}"$/;"	m	class:molkern::Configure
wolfe1	include/molkern/__config.h	/^		real_t wolfe1; \/\/ параметр, принимающий промежуточную точку как допустимую (энергия)$/;"	m	class:molkern::Configure
wolfe1	include/molkern/__config.h	/^		real_t wolfe1;$/;"	m	struct:molkern::Descriptor_
wolfe2	include/molkern/__config.h	/^		real_t wolfe2; \/\/ параметр, принимающий промежуточную точку как допустимую (градиент)$/;"	m	class:molkern::Configure
wolfe2	include/molkern/__config.h	/^		real_t wolfe2;$/;"	m	struct:molkern::Descriptor_
work_dir	include/molkern/__config.h	/^		_S work_dir; \/\/ директория, откуда забираются файлы молекул$/;"	m	class:molkern::Configure
worker_	include/molkern/complex/_parallel.h	/^			ParallWorker_ *worker_; \/\/ ссылка на нахождение данных$/;"	m	struct:molkern::ParallWorker_::thread_data_
worker_	include/molkern/complex/_parallel.h	/^			Parall_ *worker_; \/\/ ссылка на нахождение данных$/;"	m	struct:molkern::Parall_::thread_data_
write	include/molkern/complex/_archetype.h	/^		write(_I2T<GRADIENT_>, real_t *g, unsigned freedom_type, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write	include/molkern/complex/_complex.h	/^		unsigned write(_I2T<GRADIENT_>, real_t *g, const _Atom *atoms)$/;"	f	class:molkern::Complex_
write	include/molkern/complex/_molecule.h	/^		template <typename _Atom> unsigned write(_I2T<GRADIENT_>, real_t *g, const _Atom *atoms) const$/;"	f	class:molkern::Molecule_
write_gradient_	include/molkern/complex/_archetype.h	/^		write_gradient_(_I2T<YES_ATOM_>, real_t *g, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_gradient_	include/molkern/complex/_archetype.h	/^		write_gradient_(_I2T<YES_CM_ | NO_UNION_>, real_t *g, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_gradient_	include/molkern/complex/_archetype.h	/^		write_gradient_(_I2T<YES_CM_ | YES_UNION_>, real_t *g, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_gradient_	include/molkern/complex/_archetype.h	/^		write_gradient_(_I2T<YES_ROTAMER_>, real_t *g, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_header	include/molkern/complex/_complex.h	/^	::write_header(_I2T<FORMAT_BMM_>, std::ofstream &file, const std::string &header) const$/;"	f	class:molkern::Complex_
write_header	include/molkern/complex/_complex.h	/^	::write_header(_I2T<FORMAT_HIN_>, std::ofstream &file, const std::string &header) const$/;"	f	class:molkern::Complex_
write_header	include/molkern/complex/_complex.h	/^	::write_header(_I2T<FORMAT_MOL2_>, std::ofstream &file, const std::string &header) const$/;"	f	class:molkern::Complex_
write_header	include/molkern/complex/_complex.h	/^	::write_header(_I2T<FORMAT_PDB_>, std::ofstream &file, const std::string &header) const$/;"	f	class:molkern::Complex_
write_position	include/molkern/complex/_archetype.h	/^		write_position(_I2T<MOLECULE_>, real_t *x, unsigned freedom_type, const _Atom *atoms,$/;"	f	class:molkern::Archetype_
write_position	include/molkern/complex/_archetype.h	/^		write_position(_I2T<WATER_>, real_t *x, unsigned freedom_type, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_position_	include/molkern/complex/_archetype.h	/^		write_position_(_I2T<YES_ATOM_>, real_t *x, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
write_position_	include/molkern/complex/_archetype.h	/^		write_position_(_I2T<YES_CM_ | YES_UNION_>, real_t *x, const _Atom *atoms,$/;"	f	class:molkern::Archetype_
write_position_	include/molkern/complex/_archetype.h	/^		write_position_(_I2T<YES_ROTAMER_>, real_t *x, const _Atom *atoms) const$/;"	f	class:molkern::Archetype_
x	include/molkern/complex/_region.h	/^		T1 x, y, z; \/\/ текущие координаты атома$/;"	m	struct:molkern::__LJAtom
x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Position;$/;"	m	struct:molkern::Params::__anon7
x	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Velocity; \/\/ don't used$/;"	m	struct:molkern::Params::__anon10
x_	include/molkern/complex/_complex.h	/^		std::vector<real_t> x_, g_; \/\/ массивы обобщенных координат для оптимизатора$/;"	m	class:molkern::Complex_
x_rotator_	include/prgkern/_rotator.h	/^		Rotator<AXIS_ROTATOR_, T> x_rotator_;$/;"	m	class:prgkern::Rotator
xk__	include/prgkern/_minimize_lbfgs.h	/^		_Vector xk__; \/\/ previous x(k-1)$/;"	m	class:prgkern::Updater
xtol	include/molkern/__config.h	/^		real_t xtol; \/\/ минимальное значение изменения коорд, обрывающее оптимизацию$/;"	m	class:molkern::Configure
xtol	include/molkern/__config.h	/^		real_t xtol;$/;"	m	struct:molkern::Descriptor_
y	include/molkern/complex/_region.h	/^		T1 x, y, z; \/\/ текущие координаты атома$/;"	m	struct:molkern::__LJAtom
y	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Position;$/;"	m	struct:molkern::Params::__anon7
y	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Velocity; \/\/ don't used$/;"	m	struct:molkern::Params::__anon10
y_rotator_	include/prgkern/_rotator.h	/^		Rotator<AXIS_ROTATOR_, T> y_rotator_;$/;"	m	class:prgkern::Rotator
z	include/molkern/complex/_region.h	/^		T1 x, y, z; \/\/ текущие координаты атома$/;"	m	struct:molkern::__LJAtom
z	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Position;$/;"	m	struct:molkern::Params::__anon7
z	include/molkern/forcefield/_residue_amber.h	/^		typedef struct { real_t x, y, z; } _Velocity; \/\/ don't used$/;"	m	struct:molkern::Params::__anon10
z_rotator_	include/prgkern/_rotator.h	/^		Rotator<AXIS_ROTATOR_, T> z_rotator_;$/;"	m	class:prgkern::Rotator
zero_linear	include/prgkern/_math.h	/^	INLINE T zero_linear(T &A, T &B, T xa, T xb, T fa, T fb)$/;"	f	namespace:prgkern
zero_linear	include/prgkern/_math.h	/^	INLINE T zero_linear(T xa, T xb, T fa, T fb)$/;"	f	namespace:prgkern
zero_quadratic	include/prgkern/_math.h	/^	INLINE double zero_quadratic(double xa, double xb, double xc, double fa, double fb, double fc,$/;"	f	namespace:prgkern
zero_trigonometric	include/prgkern/_math.h	/^	INLINE T zero_trigonometric(T xa, T xb, T fa, T fb, unsigned n=2)$/;"	f	namespace:prgkern
~Complex_	include/molkern/complex/_complex.h	/^		~Complex_()$/;"	f	class:molkern::Complex_
~Guard_	include/prgkern/_pproc.h	/^		~Guard_()$/;"	f	class:prgkern::Guard_
~Integrator_	include/molkern/complex/_mdynamics.h	/^		~Integrator_()$/;"	f	class:molkern::Integrator_
~Molecule_	include/molkern/complex/_molecule.h	/^		~Molecule_()$/;"	f	class:molkern::Molecule_
~ParallWorker_	include/molkern/complex/_parallel.h	/^		~ParallWorker_()$/;"	f	class:molkern::ParallWorker_
~Parall_	include/molkern/complex/_parallel.h	/^		~Parall_()$/;"	f	class:molkern::Parall_
~Thermostat	include/molkern/complex/_thermostat.h	/^		~Thermostat()$/;"	f	class:molkern::Thermostat
~function_timer_t	include/prgkern/_time.h	/^		~function_timer_t() { accumulate_time[n_] += double(current_time() - start_time_); }$/;"	f	class:prgkern::function_timer_t
~round_mode_saver_	include/prgkern/_sse.h	/^		~round_mode_saver_() { _MM_SET_ROUNDING_MODE(mode_); }$/;"	f	struct:prgkern::round_mode_saver_
