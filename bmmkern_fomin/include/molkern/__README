------------------------ ОПИСАНИЕ ТЕКУЩЕЙ РЕАЛИЗАЦИИ ---------------------------

Больше НЕ поддерживаются следующие особенности:

- операционная система WINDOWS.
  Обусловлено тем, что программа ориентирована на работу на высокопроизводительных
  кластерах, и не рассчитана на распространение на домашних комппьютерах. А
  основной операционкой для кластеров является всегда UNIX.

- интерерфейс OpenMP, поскольку он реализован с существенными ограничениями для
  C++ языка. Релиз 3.0 преодолевает эти ограничения лишь частично (разрешено
  использовать итераторы в циклах OpenMP). Вместо этого предполагается использовать
  стандартную библиотеку boost::thread.

- дополнительный код, реализующий аналоги BOOST.
  Возможности BOOST все время возрастают и писать аналоги становится бессмысленным.
  Это означает, что BOOST библиотеку необходимо включать всегда.

- специальные оптимизации для последовательного варианта, если они необходимы.

- нецикличные системы.
  Для любой системы необходимо задавать ящик, который циклически дублируется
  на все пространство. Нецикличность убрана, неизвестно как искать соседей
  в случае сильного разбегания атомов вне первоначально заданного ящика.
  Для циклических систем атомы всегда загоняются в заданный ящик, если
  молекула целиком вышла за его пределы.

- размеры региона меньшие, чем 4x4x4 в единицах радиуса взаимодействия.
  Для малых регионов необходимы особые модификации функций поиска ближайшего
  образа атома. Без таких модификаций счет будет быстрее. Оптимизация кода
  должна быть сделана для больших регионов, а не для малых.

- абсолютное позиционирование лиганда около белка.
  Обусловлено тем, что для любых лигандов абсолютное позиционирование неизвестно.
  Лиганды приходят из файла с произвольными, зачастую с потеряными (по z) координатами.
  Если требуется абсолютное позиционирование, например, для продолжения расчета,
  то молекулы могут быть сброшены в единый файл формата BMM. Вместо этого,
  поддерживается позиционирование лиганда в заданной подобласти региона.

ОСОБЕННОСТИ:

- Удаляется движение системы как целое (6 степеней свободы). Удаление делается путем замораживания
	движения как целого для самой большой по массе молекулы, если она дана в единичном экземпляре.
	Если все архетипы предполагают инициирование множества молекул, то эти степени свободы будут
	удаляться вычислительно (высчитывая скорость движения центра инерции и зануляя ее, ...). То есть
	в подобном случае не будет делаться заморозка каких-то молекул.

- атомы водорода сохраняются всегда (!), даже если их сохранение не установлено,
  для форматов HIN, MOL2, BMM. Необходимость их хранения обусловлена форматом.
  Эти форматы хранят связи между атомами. Удаление водородов нарушает правильность
  взаимных ссылок между атомами внутри файлов.

- тип расчета легко изменить заменой определения real_t (typedef float real_t).
  Расширенный тип используется для накопителей сил и энергий. Необходимость
  накопителя для энергий иметь расширенный тип обусловлена большой разностью
  значений потенциальной и кинетических энергий в динамике.
  
- код пишется для векторизованных типов v4_float, v4_int, v4_bool. Эти типы включают в себя
	4 последвательно записанных в памяти простых типа (float, int, int). Это позволяет
	единообразно работать как с последовательным, так и с векторизованным (sse) кодом. 
	Векторизация кода делается автоматически при установке USE_SSE.
	
- v4_bool При работе с этой переменной нужно учесть, что она считается true, если хотя бы
  одна ее компонента отлична от нуля. Таким образом, код, содержащий логические выражения,
  типа v4_bool c = r < rmax, читаеться так "если хотя бы одна комнонента c истинна".
  (!) Использовать осторожно, так как провоцирует ошибки, так как выражение 
  "если все компоненты истинны, ..." не реализовано.
  
- Удалено неявное преобразование v4_float к float и v4_int к int, при котором происходит 
  суммирование компонент векторов. (!) Такое неявное преобразование провоцирует ошибки при
  подключении скалярных функций. Например, при использовании double sqrt(double) с типом
  v4_float происходит неявное преобразование, затем вычисление корня от суммы компонент,
  затем обратное преобразование с дублированием компонент по вектору. Явно, это не то, что 
  хотелось. 
  
-   

ПСЕВДООШИБКИ:

При работе с кодом иногда возникают подозрения на ошибки. Делая проверки, и
затрачивая на это много времени, оказывается, что подозрение не обосновывается,
а проблема была в особенностях хранения данных в программе. Здесь список таких
особенностей и возникающих псевдоошибок.

- расчет энергии кулона для тестовой пары атомов с единичным зарядом дает не
  то, значение, которое следует из простой оценки 1/r. Псевдоошибка заключается
  в том, что забыли о сглаживателе, который вычитает контанту из энергии,
  рассчитанную на rcutoff.

- расчет энергии ван-дер-ваальса дает не то значение, что ожидается. Забыли
  учесть, что при загрузке eps, оно модифицируется на CAL2AUE.

--------------------------------------------------------------------------------
090930. Хранение атомов делается одновременно (и дублировано) в двух структурах.

Первая - это массив, в котором все атомы всех молекул храняться в непрерывной
области памяти. Они упорядочены в том смысле, что лежат группами, то есть
сперва все атомы одной молекулы, затем все атомы другой молекулы. Причем, атомы
молекулы одного типа имеют такой же порядок как и атомы другой молекулы такого
же типа. Такое хранение позволяет эффективно считать все валентные взаимодействия.

Второй тип хранения - совокупность массивов, в каждом из которых лежат атомы,
попавшие в ту или иную ячейку грида. Этот тип хранения позволяет эффективно
считать невалентные взаимодействия, поскольку не требует сортировки на ближние
и дальние. Здесь также лежат полные атомы (есть eps, sigma, charge, X), чтобы
можно было выполнять счет независимо.

Результаты счета (силы) накапливаются в атомах каждого типа хранения независимо.
Это позволяет избежать одновременного обращения на запись из двух независимых
расчетов - невалентных и валентных взаимодействий. Однако, после расчета всех
сил необходимо слияние сил (например, пересылка частичных сил из второго хранилища
в первое).

Почему невозможно организовать хранение в одном хранилище? Это связано с
эффективностью доступа к данным и независимостью счета разных типов взаимодействия.
Хранение в линейном массиве было опробовано во всех ранних версиях МОЛКЕРН.
Проблема, которая эффективно не решалась - расчет невалентных взаимодействий.
Второе хранилище также присутствовало, но оно хранило указатели на атомы
линейного массива. Доступ через указатели перегружал шину данных при доступе
к памяти и это был основной тормоз для CELL реализации (не было абсолютной
скорости).
А хранить данные полностью в гриде, значит иметь проблемы с поиском атомов при
счете связей, валентных и дигедральных углов. Я просто не знаю алгоритма,
который эффективно O(N), может находить тройки и четверки близких атомов.

--------------------------------------------------------------------------------

091013. Если подсчитать массу кубического сантиметра воды исходя из данных по
SPCBOX, то получим вес в 0.975 г. Потеря 25 грамм соответствует требованию
вставки дополнительных 5 молекул воды. Тем не менее, уже в заданном объеме
есть клеши по ван-дер-ваальсовым расстояниям. Есть расстояния O-O в 2.76A, это
при том, что ван-дер-ваальсовый радиус O равен 1.76A. Это говорит о том, что
некоторое количестов клешей должно допускаться при заполнении объема водой.

091014. Код написан так, что независит от смещения за пределы циклического ящика.
Молекулы могут сдвинуться как угодно далеко, это не должно влиять на расчеты, ибо
- связанные взаимодействия зависят только от относительных координат, а не абсолютных
- для несвязующий взаимодействий все координаты приводятся к координатам ящика.
Такой код не требует смещения молекул внутрь ящика, если молекула целиков вышла
за его пределы.


